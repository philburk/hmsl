/* ==================================== JUCER_BINARY_RESOURCE ====================================

   This is an auto-generated file: Any edits you make may be overwritten!

*/

namespace BinaryData
{

//================== action_screen.fth ==================
static const unsigned char temp_binary_data_0[] =
"\\ ACTION-TABLE control screen\n"
"\\ place for 64 actions in four different columns, 16 of each\n"
"\\ priority\n"
"\n"
"\\ Author: Polansky\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"\\ MOD: PLB 3/2/87 Check for ACT-NULL in DO.ACTION.\n"
"\\ MOD: PLB 4/15/87 Need rel->use in table=>grid\n"
"\\ MOD: PLB 5/20/87 Use 0 for text in table->grid.\n"
"\\      Remove TIME@ call before AO.POST\n"
"\\ MOD: PLB 5/24/87 Add TURN.SELF.OFF\n"
"\\ MOD: PLB 5/28/87 Add prob grids.\n"
"\\ MOD: PLB 10/28 Remove ACTION-# references.\n"
"\\ MOD: PLB 11/4/87 Changed DELETE.ACTION: calls to DELETE:\n"
"\\ MOD: PLB 10/17/88 Convert to new control grid design.\n"
"\\ MOD: PLB 9/28/89 Change PUT.XYWH: to WH and screen-x,y.\n"
"\\ MOD: PLB 12/13/89 Got rid of PUT.NUMXY: , add part# to MIN/MAX\n"
"\\ MOD: PLB Changed 0STUFF.TEXT: to }STUFF.text:\n"
"\n"
"anew task-action_screen\n"
"\n"
"\\ =========================================================\n"
"\n"
"ob.check.grid action-grid\n"
"\n"
"\\ move action-table to grid\n"
"\n"
"v: do.action-mode\n"
"\n"
"\\ utility for clearing a cell on action-grid\n"
": CLEAR.ACTION-GRID.CELL  \\ action-# action --- action-# action\n"
"    0  2 pick\n"
"    put.text: action-grid\n"
";\n"
"\n"
"\\ case statement for executing a hit on action-grid\n"
"\\ CASE value is passed from DO.ACTION\n"
": DO.ACTION.OF \\ #, action-add ---\n"
"do.action-mode @\n"
"CASE\n"
"   0 OF act.toggle: [] drop\n"
"     ENDOF\n"
"   1 OF clear.action-grid.cell\n"
"\tdelete: action-table drop\n"
"     ENDOF\n"
"   2 OF clear.action-grid.cell dup\n"
"\tdelete: action-table\n"
"        dup inc.priority: []\n"
"        put.action:  action-table\n"
"        drop\n"
"     ENDOF\n"
"   3 OF clear.action-grid.cell dup delete: action-table\n"
"        dup dec.priority: []\n"
"        put.action:  action-table\n"
"        drop\n"
"     ENDOF\n"
"   4 OF drop  -4 ashift  \\ need priority-#\n"
"        clear.priority: action-table\n"
"     ENDOF\n"
"   5 OF drop drop clear: action-table\n"
"     ENDOF\n"
"   \" DO.ACTION.OF\"   \" Unsupported choice!\" er_return er.report\n"
"ENDCASE\n"
";\n"
"\n"
": ACTION-TABLE=>ACTION-GRID ( -- , fill control grid )\n"
"    64 0\n"
"    DO  \\ first put text in cell\n"
"        i get: action-table\n"
"        dup act-null =\n"
"        IF drop 0\n"
"        ELSE get.name|nfa: []   ( use nfa if appropriate )\n"
"        THEN\n"
"        i put.text: action-grid\n"
"\\ highlight if action on...\n"
"        i get: action-table\n"
"        action.on?: []\n"
"        i put.value: action-grid\n"
"    LOOP\n"
"\\ cfa in action-grid is always do.action.of!!!\n"
";\n"
"\n"
"\\ highest level word which executes in current selected mode...\n"
"\n"
": DO.ACTION  ( flag action-# -- , perform specific operation on action )\n"
"   nip dup         \\ some routines need #\n"
"   get: action-table    ( -- action-# action )\n"
"   dup act-null = not\n"
"   IF do.action.of\n"
"      do.action-mode @ 0 >\n"
"      IF action-table=>action-grid draw: action-grid\n"
"      THEN\n"
"   ELSE 2drop\n"
"   THEN\n"
";\n"
"\n"
"\\ builds empty grid\n"
": BUILD.ACTION-GRID\n"
"   4 16 new: action-grid\n"
"   'c do.action put.down.function: action-grid\n"
"   64 0 DO\n"
"      0 ( text)  i put.text: action-grid\n"
"   LOOP\n"
"   500 215 put.wh: action-grid\n"
";\n"
"\n"
"\\ ----------------------------------------------------------\n"
"OB.RADIO.GRID ACTION-CHOOSER\n"
"\\ word for executing action-chooser\n"
": ACTION.SET.MODE ( value mode -- )\n"
"    do.action-mode !  drop\n"
";\n"
"\n"
": BUILD.ACTION-CHOOSER ( -- )\n"
"   1 6 new: action-chooser\n"
"   'c action.set.mode put.down.function: action-chooser\n"
"   stuff{ \" Toggle\"       \" Delete\"\n"
"     \" Priority+\"    \" Priority-\"\n"
"     \" ClrPriority\"  \" ClrTable\"\n"
"   }stuff.text: action-chooser\n"
"   680  450 put.wh: action-chooser\n"
"   \" Mode\" put.title: action-chooser\n"
";\n"
"\n"
"\\ ----------------------------------------------------------\n"
"OB.CHECK.GRID PERFORM-CHOOSER\n"
"\\ Control MIDI Parser from Action Screen\n"
"\n"
": SET.MIDI.PARSER ( flag -- , turn ON/OFF MIDI-PARSER )\n"
"    midi.clear\n"
"    midi-parser !\n"
";\n"
"\n"
"\\ turn on or off PERFORM, or the posting of the ACTION-TABLE\n"
": TOGGLE.PERFORM ( flag -- )\n"
"    IF   action-table ao.post    \\  .\" posted \" cr\n"
"    ELSE action-table ao.unpost  \\  .\" unposted \" cr\n"
"    THEN\n"
";\n"
"\n"
": PERFORM.FUNC  ( flag part -- )\n"
"    IF set.midi.parser\n"
"    ELSE toggle.perform\n"
"    THEN\n"
";\n"
"\n"
": BUILD.PERFORM-CHOOSER\n"
"   1 2 new: perform-chooser\n"
"   'c perform.func put.down.function: perform-chooser\n"
"   stuff{ \" PERFORM \" \" MIDI Parser\" }stuff.text: perform-chooser\n"
"   \" On/Off\" put.title: perform-chooser\n"
"   725 350 put.wh: perform-chooser\n"
";\n"
"\n"
"\\ =======================================\n"
": PUT.PRIORITY-BEHAVIOR ( VALUE INDEX -- )\n"
"   IF  'c unweighted.behavior put.behavior: action-table\n"
"   ELSE  'c priority.behavior put.behavior: action-table\n"
"   THEN drop\n"
";\n"
"\n"
"OB.RADIO.GRID BEHAVIOR-CHOOSER\n"
"\n"
": BUILD.BEHAVIOR-CHOOSER\n"
"   1 2 new: behavior-chooser\n"
"   'c put.priority-behavior put.down.function: behavior-chooser\n"
"   stuff{ \" Weighted\"  \" Unweighted\" }stuff.text: behavior-chooser\n"
"   \" Behavior\" put.title: behavior-chooser\n"
"   725 350 put.wh: behavior-chooser\n"
";\n"
"\n"
"\\ -----------------------------------------------------------\n"
"\\ Modify priorities from Count Controls\n"
"OB.COUNTER ACTION-PROB-GRID-0\n"
"OB.COUNTER ACTION-PROB-GRID-1\n"
"OB.COUNTER ACTION-PROB-GRID-2\n"
"OB.COUNTER ACTION-PROB-GRID-3\n"
"\n"
": ACTION.SET.PROB  ( value part -- , Set probabilities )\n"
"    2drop\n"
"    0 get.value: action-prob-grid-3\n"
"    0 get.value: action-prob-grid-2\n"
"    0 get.value: action-prob-grid-1\n"
"    0 get.value: action-prob-grid-0\n"
"    put.priority.probs\n"
";\n"
"\n"
": BUILD.SINGLE.PROB ( object -- , Build one of four )\n"
"    >r\n"
"    350 600 r@ put.wh: []\n"
"    0 r@ put.title: []\n"
"    'c action.set.prob r@ put.down.function: []\n"
"    0 0 r@ put.min: []\n"
"    99 0 r@ put.max: []\n"
"    rdrop\n"
";\n"
"\n"
": ACTION.SYNC.PROB  ( priority grid -- )\n"
"    >r action-probs @\n"
"    dup 0 r@ put.value: []\n"
"    2* 99 max 0 r> put.max: []\n"
";\n"
"\n"
": ACTION.SYNC.PROBS ( -- , sync prob display with reality)\n"
"    0 action-prob-grid-0 action.sync.prob\n"
"    1 action-prob-grid-1 action.sync.prob\n"
"    2 action-prob-grid-2 action.sync.prob\n"
"    3 action-prob-grid-3 action.sync.prob\n"
";\n"
"\n"
"840 constant ACTION_PROB_SPACING\n"
"\n"
": BUILD.SET.PROB ( -- , Build four grids )\n"
"    action-prob-grid-0 build.single.prob\n"
"    \" Probs\" put.title: action-prob-grid-0\n"
"    action-prob-grid-1 build.single.prob\n"
"    action-prob-grid-2 build.single.prob\n"
"    action-prob-grid-3 build.single.prob\n"
";\n"
"\n"
"\\ -----------------------------------------------------------\n"
"\\ build entire ACTION-SCREEN\n"
"OB.SCREEN ACTION-SCREEN\n"
"\n"
": ACTION.SYNC.PERFORM  ( -- , execute this when screen drawn )\n"
"\\ Make actions grid show all actions.\n"
"    action-table=>action-grid\n"
"\\ Make sure PERFORM button reflects reality\n"
"    action-table indexof: actobj\n"
"    IF drop 1   ( %Q control grids use 0/1 )\n"
"    ELSE 0\n"
"    THEN\n"
"    0  put.value: perform-chooser\n"
"    midi-parser @ 0= 1+ 1 put.value: perform-chooser\n"
"\\ Sync behavior chooser.\n"
"    get.behavior: action-table\n"
"    'c priority.behavior = IF 0 ELSE 1 THEN\n"
"    1 swap put.value: behavior-chooser\n"
"    action.sync.probs\n"
";\n"
"\n"
": BUILD.ACTION-SCREEN ( -- , build screen , set X,Ys )\n"
"    8 3 new: action-screen\n"
"    action-grid 100 300 add: action-screen\n"
"    action-chooser 3275 200 add: action-screen\n"
"    perform-chooser 2500 200 add: action-screen\n"
"    behavior-chooser 2500 1700 add: action-screen\n"
"    250 >r\n"
"    action-prob-grid-0 2120 r@ add: action-screen\n"
"    action-prob-grid-1 2120 r> action_prob_spacing + dup>r\n"
"            add: action-screen\n"
"    action-prob-grid-2 2120 r> action_prob_spacing + dup>r\n"
"            add: action-screen\n"
"    action-prob-grid-3 2120 r> action_prob_spacing +\n"
"            add: action-screen\n"
"    \" Action Table\" put.title: action-screen\n"
"    'c action.sync.perform put.draw.function: action-screen\n"
"    ascii A put.key: action-screen\n"
";\n"
"\n"
"\\ The following is  used inside\n"
"\\ a response routine for turning an action-off. It can only be\n"
"\\ executed from an ACTION which has already set itself to\n"
"\\ CURRENT-ACTION\n"
": TURN.SELF.OFF  ( -- )\n"
"    current-action @ act.off: []\n"
"    cg-current-screen @ action-screen =\n"
"    IF gr-curwindow @   ( Unhighlight grid cell if drawn. )\n"
"       IF  0  current-action @\n"
"           indexof: action-table\n"
"           IF put.value: action-grid\n"
"           ELSE drop\n"
"           THEN\n"
"       THEN\n"
"    THEN\n"
";\n";

const char* action_screen_fth = (const char*) temp_binary_data_0;

//================== action_table.fth ==================
static const unsigned char temp_binary_data_1[] =
"\\ ACTION-TABLE definition and behaviors (PERFORM environment)\n"
"\\ HMSL\n"
"\\ author Larry Polansky\n"
"\\\n"
"\\ define ACTION-TABLE as a STRUCTURE\n"
"\\\n"
"\\ ACTION-TABLE uses global  variables for length of each priority\n"
"\\ column, and when an action is created these lengths are\n"
"\\ checked to see if there is enough room in that column. There\n"
"\\ are also similar variables for the EXEC count in each column,\n"
"\\ used by the STOCHASTIC PRIORITY  BEHAVIOR.\n"
"\\\n"
"\\ Copyright 1986 Phil Burk, Larry Polansky, David Rosenboom\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 1/27/87 Change <SUPER OB.FRAME to OB.STRUCTURE\n"
"\\      Changed GET.COLL: to GET:\n"
"\\ MOD: PLB 5/20/87 Changed INIT: to clear col-length array\n"
"\\ MOD: PLB 5/23/87 No done? for TASK:\n"
"\\      Optimized UNWEIGHTED.BEHAVIOR\n"
"\\ MOD: PLB 9/3/87 Added 0STUFF.ACTIONS\n"
"\\ MOD: PLB 9/23/87 Changed it to 0STUFF: for class.\n"
"\\ MOD: PLB 10/29/87 Remove ACTION-# references.\n"
"\\          Remove CHOSE.NEXT.ACTION: declaration.\n"
"\\ MOD: PLB 11/3/87 Change DELETE-ACTION-#: to REMOVE:\n"
"\\      Took out DELETE.ACTION: and DELETE.ACTION.IF:\n"
"\\ MOD: PLB 10/18/88 Moved 65 NEW: to BUILD.ACTION_TABLE\n"
"\\ MOD: PLB 6/2/89 Change TASK: and behaviors to work\n"
"\\      with new kind of collection and behaviors.\n"
"\\ MOD: PLB 2/4/91 Changed TASK: from EXECUTE: to TASK:\n"
"\n"
"\\ ================================================================\n"
"MRESET PUT.ACTION:\n"
"\n"
"ANEW TASK-ACTION_TABLE\n"
"\n"
"\\ Note that for early versions of HMSL, there is probably only\n"
"\\ going to be one instance of the class ACTION-TABLE ...\n"
"\n"
"\\ temporary variables used inside calculations to save\n"
"\\ stack brain damage\n"
"v: CURRENT-PRIORITY\n"
"v: TEMP-ACTION \\ used in search for delete from table\n"
"\n"
"method PUT.ACTION:\n"
"method CLEAR.PRIORITY:\n"
"\n"
":CLASS OB.ACTION-TABLE    <SUPER OB.COLLECTION\n"
"\n"
"\\ Redefine task for ACTION-TABLE so that it never ends from a\n"
"\\ behavior, only when perform is clicked off. It doesn't need a\n"
"\\ message-done, because actions are not scheduled!! TASK: for the\n"
"\\ ACTION-TABLE is a key word to understand in seeing how the\n"
"\\ ACTION-TABLE interacts with the HMSL polymorphous executive\n"
"\n"
":m TASK: ( ---  )\n"
"    col.exec.behav 1 =\n"
"    IF get: self  \\  act\n"
"       task: []\n"
"    ELSE .\" Action Table behavior should only pick 1\" cr abort\n"
"    THEN\n"
";m\n"
"\n"
"\\ ================================================================\n"
"\n"
"\\ there still seems to be one last little bug in the action-table\n"
"\\ moving around of actions. it only surfaces when one tries to move\n"
"\\ an action into the last place in a give priority column, it seems\n"
"\\ to dissapear. polansky promises to fix this....\n"
"\n"
"\\ internal DO...LOOP that re-packs a column from which\n"
"\\ an ACTION has been deleted. Used in REMOVE:\n"
"\n"
": PACK.COLUMN ( abs.end.of.col  action-#  --- , re-packs column )\n"
"    over  swap  ( -- end end act# )\n"
"    DO \\ start at 1 past action-# to move down\n"
"        i 1+ get: self    ( -- end action )\n"
"        i  put: self\n"
"    LOOP ( -- end )\n"
"\\ null last position\n"
"    act-null swap put: self\n"
";\n"
"\n"
"\n"
":M REMOVE:  ( action-# --- ,delete and resize )\n"
"    dup temp-action !\n"
"    -4 ashift current-priority !\n"
"    act-null temp-action @ put: self \\ replace with act-null\n"
"\\ Next  test to see if NOT last action in a column\n"
"    current-priority @ get.column.length @\n"
"    temp-action @ 15 and  1+  =  NOT  \\ ---  flag\n"
"    IF  \\ it's not the last in a column...\n"
"       current-priority @ get.column.length @ 1- \\ --- col.length\n"
"       current-priority @ 4 ashift +   \\ --- absolute.end.of.column\n"
"       temp-action @  \\ --- abs.end.col action-#\n"
"       pack.column    \\ move others down\n"
"    THEN\n"
"\\ Always decrement the column length when finished\n"
"    current-priority @ get.column.length decr\n"
";m\n"
"\n"
"\\ ACTIONS are not allowed into the ACTION-TABLE if that priority\n"
"\\ column is filled. You must first drop an action. If an action is already\n"
"\\ in the table, it will be deleted before being put in. This is how\n"
"\\ an action's priority gets changed in the graphic action-table routines.\n"
"\n"
"\\ ======================================================\n"
"\n"
"\\ Basic method for putting an ACTION into the ACTION-TABLE\n"
"\\ syntax: ACT-FOO PUT.ACTION: ACTION-TABLE\n"
"\n"
":M PUT.ACTION:  ( action -- ,puts action into table)\n"
"   dup delete: self  \\ replace any old occurrences\n"
"   dup    ( -- action action )\n"
"   get.priority:  []  dup  ( -- action pri pri )\n"
"   get.column.length  @    ( -- action pri length )\n"
"   dup 15  =\n"
"   IF  ( -- action pri length )\n"
"       cr bell .\" no room in action-table for this priority \"\n"
"       3drop\n"
"   ELSE\n"
"       swap dup    ( -- action length pri pri )\n"
"       get.column.length incr  ( -- action length pri )\n"
"       4 ashift    \\ multiply priority to index into table\n"
"       +   ( -- action cell# , add row number to get absolute cell#)\n"
"       put:  self  \\ put the action in table )\n"
"    THEN\n"
";m\n"
"\n"
"\n"
"\\ clears a column of the action table\n"
":M CLEAR.PRIORITY: ( priority-# --- clear that column )\n"
"    dup 0 >=    \\ valid priority?\n"
"    IF  dup get.column.length disable   \\ reset column length\n"
"\\ offset into ACTION-TABLE, and end of col., for DO...LOOP\n"
"        4 ashift  dup 16  + swap\n"
" \\ first remove all ACTIONs in that priority column\n"
"        DO    act-null  i put: self\n"
"        LOOP\n"
"    ELSE drop\n"
"    THEN\n"
";m\n"
"\n"
"\\ clears action-table\n"
":M CLEAR:\n"
"   4 0\n"
"   DO  i clear.priority: self\n"
"   LOOP\n"
";m\n"
"\n"
":m PRINT: ( -- )\n"
"   .\" ACTION-TABLE contains: \" cr cr\n"
"   64 0\n"
"   DO  i get: self  \\ get the address of the action\n"
"       dup act-null =\n"
"       IF  drop .\" -- \"  ( nothing there )\n"
"       ELSE  name: [] space space       \\ get the name\n"
"       THEN\n"
"\t\\ for each priority  do a coupla CR's\n"
"       i 1+ 16 mod 0=\n"
"       IF cr cr THEN\n"
"    LOOP\n"
";m\n"
"\n"
"\\ Make it easy to load the action table.\n"
":M 0STUFF: ( 0 act-a act-b act-c ... -- , add to table )\n"
"    0depth dup 0>\n"
"    IF  0\n"
"        DO put.action: self\n"
"        LOOP\n"
"    ELSE\n"
"        \" 0STUFF:\" \" Need 0 on stack!\"\n"
"        er_fatal ob.report.error\n"
"    THEN drop\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\\ For PERFORM screen.\n"
"OB.ACTION-TABLE ACTION-TABLE\n"
"\n"
"\\ Fills action-table with act-null and sets length to 64\n"
"\\ 64th cell is act-null, which is executed when action-table is\n"
"\\ empty but behavior is running...\n"
"\n"
": BUILD.ACTION-TABLE\n"
"   65 new: action-table\n"
"   65 0 DO\n"
"      act-null add: action-table\n"
"   LOOP\n"
";\n"
"\n"
"\\ ====================== ACTION-TABLE BEHAVIORS ==================\n"
"\\ Weighted Behavior ----------\n"
"\n"
": CHOOSE.NEXT.PRIORITY (  --- priority)\n"
"     3 priority-prob-sum @ choose\n"
"     3 0\n"
"     DO  dup i action-prob-sums @ <\n"
"         IF ( -- 3 r ) nip i swap  leave\n"
"         THEN\n"
"     LOOP drop\n"
";\n"
"\n"
": ACTION.PRI->ACT#   ( default_collid priority -- collid )\n"
"    dup action-col-lengths @ ( -- 64 pr. length)\n"
"    0=  ( -- 64  priority  flag)\n"
"    IF  drop  ( -- 64)\n"
"    ELSE      ( -- 64 pr.)\n"
"       dup dup action-counters @  ( -- 64 pr. pr. count)\n"
"       swap 4 ashift +  ( -- 64  pr. collid)\n"
"       swap inc.priority.counter ( -- 64 collid)\n"
"       nip \\ get rid of 64\n"
"    THEN\n"
";\n"
"\n"
": PRIORITY.BEHAVIOR   ( action-table -- next_act_id 1 )\n"
"    64  swap action-table = ( --  64 flag)\n"
"    IF\n"
"        choose.next.priority    ( -- 64 pr.)\n"
"        action.pri->act#\n"
"    THEN 1\n"
";\n"
"\n"
"\\ UNWeighted Behavior ------\n"
": UNWEIGHTED.BEHAVIOR ( action-table -- next_act_id 1 )\n"
"     64  swap action-table = ( --  64 flag)\n"
"     IF\n"
"        action.next.priority  ( round robin)\n"
"        action.pri->act#\n"
"    THEN 1\n"
";\n";

const char* action_table_fth = (const char*) temp_binary_data_1;

//================== action_top.fth ==================
static const unsigned char temp_binary_data_2[] =
"\\ Top control file for PERFORM (ACTION-TABLE, etc.)\n"
"\\\n"
"\\ Author: Larry Polansky\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"\\ MOD: PLB 3/6/87 Remove PUT.VALUE: from ACTION.RESET\n"
"\\          Added ACTION.DRAW.SCREEN\n"
"\\ MOD: PLB 4/15/87 Use ACTION.UTILS.INIT\n"
"\\ MOD: PLB 5/20/87 Init DO.ACTION-MODE\n"
"\\      Combine ACTION_INIT and ACTION_TERM files.\n"
"\\      Move NEW:s to BUILD.xx words.\n"
"\\ MOD: PLB 10/28/87 ACTION.RESET now clears ACTION-TABLE.\n"
"\\ MOD: PLB 3/26/90 Made optional module w/ USER.INIT\n"
"\n"
"ANEW TASK-ACTION_TOP\n"
"\n"
"\\ after actions, action-table, and action-screen are set up\n"
"\\ grids : Action-grid; Action-chooser; Perform-chooser; Behavior-chooser\n"
"\n"
": ACTION.RESET ( -- )\n"
"    'c priority.behavior put.behavior: action-table\n"
"    clear: action-table\n"
";\n"
"\n"
": ACTION.INIT ( -- )\n"
"    0 scg.selnt     ( force proper transformation )\n"
"    build.action-table\n"
"    build.action-chooser\n"
"    build.perform-chooser\n"
"    build.action-grid\n"
"    build.behavior-chooser\n"
"    build.set.prob\n"
"    build.action-screen\n"
"    action.reset\n"
"    action.utils.init\n"
"    init.stock.actions\n"
"    0 do.action-mode !\n"
";\n"
"\n"
": ACTION.TERM ( -- )\n"
"    freeall: action-screen\n"
"    free: action-screen\n"
";\n"
"\n"
": USER.INIT user.init action.init ;\n"
": USER.RESET user.reset action.reset ;\n"
": USER.TERM action.term user.term ;\n";

const char* action_top_fth = (const char*) temp_binary_data_2;

//================== action_utils.fth ==================
static const unsigned char temp_binary_data_3[] =
"\\ Utilities to support the Action Table\n"
"\\ Concerned mostly with prioritizing groups of actions.\n"
"\\\n"
"\\ Author: Larry Polansky\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"\\ MOD: PLB 3/7/87 Add MAYBE\n"
"\\ MOD: PLB 4/15/87 Added Variable initialization for Mac\n"
"\\ MOD: PLB 5/20/87 Use ARRAYS for 4 priority levels.\n"
"\n"
"ANEW TASK-ACTION_UTILS\n"
"\n"
"\\ used to see if you want to turn an action off after executing...\n"
"V: CURRENT-ACTION\n"
"\n"
"\\ global counter, used for all actions, updated everytime any action\n"
"\\ is EXECUTE:d. useful for ACTION synchrony\n"
"v: ACTION-GLOBAL-COUNTER\n"
"\n"
"\\  variables for keeping track of column length in ACTION-TABLE\n"
"4 constant ACTION_#PRIORITIES\n"
"action_#priorities array ACTION-COL-LENGTHS\n"
"\n"
"\\ variables used by ACTION-TABLE Behaviors, programmer should keep track\n"
"\\ of these for the 4 priorities when writing a Behavior\n"
"action_#priorities array ACTION-COUNTERS\n"
"\n"
"v: PRIORITY-PROB-SUM \\ used by stochastic, WEIGHTED Behavior\n"
"\n"
"\\ simple names for priorities\n"
"0 k: highest    1 k: high\n"
"2 k: low        3 k: lowest\n"
"\n"
"\\ simple names for priority execution probabilites\n"
"\\ first cell is the probability for the highest probability\n"
"action_#priorities array ACTION-PROBS\n"
"\\ sums of probabilities for quick weighted choose\n"
"action_#priorities array ACTION-PROB-SUMS\n"
"\n"
"\\ set probs for stochastic, WEIGHTED action-table behavior\n"
": PUT.PRIORITY.PROBS \\ lowest, low, high, highest --- \\\n"
"    2dup 4 pick 6 pick \\  --- lst,l,h,hst,h,hst,l,lst\n"
"    + + + \\ sum them --- lst,l,h,hst,sum\n"
"    dup 65535 <\n"
"    IF  priority-prob-sum !\n"
"\\ segment range of priorities for lookup!!!\n"
"        action_#priorities 0\n"
"        DO i action-probs !\n"
"        LOOP\n"
"        0 action_#priorities 0\n"
"        DO  i action-probs @ + ( calc sums )\n"
"            dup i action-prob-sums !\n"
"        LOOP drop\n"
"    ELSE drop drop drop drop drop\n"
"        \" PUT.PRIORITIES\"\n"
"        \" Priorities sum must be less than 65535 !!! \"\n"
"        er_return er.report\n"
"    THEN\n"
";\n"
"\n"
"\\ default probabilities are  a simple fibbonacce sequence\n"
": INIT.PRIORITY.PROBS\n"
"     5 8 13 21 put.priority.probs\n"
";\n"
"\n"
": PRINT.PRIORITY.PROBS cr\n"
"    .\" Priority probabilities are: \" cr\n"
"    .\"    highest \" 0 action-probs  @ . cr\n"
"    .\"    high    \" 1 action-probs  @ . cr\n"
"    .\"    low     \" 2 action-probs  @ . cr\n"
"    .\"    lowest  \" 3 action-probs  @ . cr\n"
";\n"
"\n"
"\\ default stimuli and response: never/do.nothing  put in\n"
"\\ action at init time\n"
": NEVER 0 ;\n"
": ALWAYS 1 ;\n"
": MAYBE ( -- flag , usually false )\n"
"    17 choose 0=\n"
";\n"
": DO.NOTHING drop ;\n"
"\n"
"\\ the following is used to get the current length of\n"
"\\ columns in the ACTION-TABLE\n"
": GET.COLUMN.LENGTH  \\ priority --- address of variable\n"
"    action-col-lengths\n"
";\n"
"\\ get the current counter # in an action-table priority\n"
": GET.PRIORITY.COUNTER  \\ priority --- address of variable\n"
"    action-counters\n"
";\n"
"\n"
": INC.PRIORITY.COUNTER  \\ priority# - incs it mod column length\n"
"     dup dup action-counters @ ( --  # # counter )\n"
"     swap action-col-lengths @ ( --  # counter length )\n"
"     swap 1+ swap MOD          ( --  # counter+1modlength )\n"
"     swap action-counters !\n"
";\n"
"\n"
": RESET.AGC   (  ---  )\n"
"   action-global-counter disable\n"
";\n"
"\n"
": PUT.AGC     ( agc.value --- )\n"
"   action-global-counter !\n"
";\n"
"\n"
": GET.AGC     ( --- agc.value )\n"
"   action-global-counter @\n"
";\n"
"\n"
": ACTION.UTILS.INIT\n"
"    action-global-counter off\n"
"    action_#priorities 0\n"
"    DO  0 i action-col-lengths !\n"
"        0 i action-counters !\n"
"    LOOP\n"
"    init.priority.probs\n"
";\n";

const char* action_utils_fth = (const char*) temp_binary_data_3;

//================== actobj.fth ==================
static const unsigned char temp_binary_data_4[] =
"\\ Active Object List Processor\n"
"\\ This morph contains a list of executable morphs.\n"
"\\ It provides a simple multitasking facility by sending\n"
"\\ task messages to each of it's members in series.\n"
"\\ Morphs can be made active by posting them to this list.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 7/26/86 Made AO.SCAN always process an object even if reset occurs.\n"
"\\ MOD: PLB 7/27/86 Fixed AO.SCAN\n"
"\\ MOD: PLB 7/29/86 Added AO.ACTIVATE and AO.DEACTIVATE\n"
"\\ MOD: PLB 12/9/86 Initialize AO-COUNT at AO.INIT\n"
"\\ MOD: PLB 1/14/87 Make ACTOBJ an OB.OBJLIST, Add AO.EXEC\n"
"\\ MOD: PLB 5/23/87 No error in AO.UNPOST.\n"
"\\      TASK: no longer returns done? flag.\n"
"\\ MOD: PLB 10/18/87 Add AO.RESET\n"
"\\ MOD: PLB 11/3/87 Use DELETE: in AO.UNPOST\n"
"\\ MOD: PLB 11/16/87 Change default size from 32 to 128\n"
"\\ MOD: PLB 2/9/90 Move AO.REPEAT to H:TIME\n"
"\\ MOD: PLB 4/13/90 Moved DO.NEXT.EVENT and SELF.CLOCK to HMSL_TOP\n"
"\\ MOD: PLB 2/18/92 Add SYS.CLEANUP\n"
"     \n"
"ANEW TASK-ACTOBJ\n"
"\n"
"OB.OBJLIST ACTOBJ\n"
"\n"
": AO.POST ( morph -- , post object to active list )\n"
"     add: actobj\n"
";\n"
"\n"
": AO.UNPOST ( morph -- , delete from active list )\n"
"    delete: actobj\n"
";\n"
"\n"
"V: AO-COUNT  ( Keep track of how many times AO.SCAN called. )\n"
"\n"
"\\ Scan entire active object list.\n"
"\\ When repeating loop, call AO.REPEAT and DO.NEXT.EVENT\n"
": (AO.SCAN) ( -- )\n"
"    many: actobj   ( are there any? )\n"
"    IF reset: actobj  ( start at beginning )\n"
"       BEGIN manyleft: actobj\n"
"       WHILE next: actobj   ( get object from list )\n"
"           task: []    ( time slice object )\n"
"       REPEAT\n"
"    THEN\n"
"    1 ao-count +!   ( Track calls for performance analysis. )\n"
";\n"
"\n"
"variable AO-ENABLE\n"
": AO.SCAN ( -- , Time slice next object.)\n"
"\\ Check variable to avoid recursion with SERVICE.TASKS\n"
"    ao-enable @\n"
"    IF  ao-enable off\n"
"        (ao.scan)\n"
"        ao-enable on\n"
"    THEN\n"
";\n"
"\n"
"\\ Set CFA of low level task server. This ensures that ao.scan\n"
"\\ will get called when lengthy words get called , provided they call\n"
"\\ SERVICE.TASKS in their loops.\n"
": AO.ACTIVATE  ( -- , Activate AO.SCAN )\n"
"    ao-enable on\n"
"    'c ao.scan tasks-cfa !\n"
";\n"
": AO.DEACTIVATE  ( -- , Deactivate AO.SCAN )\n"
"    'c noop tasks-cfa !\n"
";\n"
"\n"
"\\ These words are used for testing or for simple sequenceing.\n"
": AO.LOOP ( -- , scan until all done or key hit )\n"
"      ao.activate\n"
"      BEGIN\n"
"           many: actobj 0>\n"
"           ?terminal/64 0= and\n"
"      WHILE\n"
"           ao.scan\n"
"      REPEAT\n"
"      ao.deactivate\n"
";\n"
"\n"
": AO.EXEC ( morph -- , Execute morph then task )\n"
"    start: []\n"
"    ao.loop\n"
";\n"
"\n"
": AO.INIT  ( -- , Allows for 128 active tasks. )\n"
"    128 new: actobj\n"
"    0 ao-count !\n"
"    ao-enable on\n"
";\n"
"\n"
": AO.RESET ( -- , Stop all active objects. )\n"
"    reset: actobj\n"
"    BEGIN\n"
"        manyleft: actobj\n"
"    WHILE\n"
"        next: actobj abort: []\n"
"    REPEAT\n"
"    clear: actobj\n"
"    ao.deactivate\n"
";\n"
"\n"
": AO.TERM\n"
"    free: actobj\n"
";\n"
"\n"
": SYS.INIT sys.init ao.init ;\n"
": SYS.RESET ao.reset sys.reset ;\n"
": SYS.CLEANUP ao.reset sys.cleanup ;\n"
": SYS.START ao.activate sys.stop ;\n"
": SYS.STOP ao.reset ao.deactivate sys.stop ;\n"
": SYS.TASK ao.scan sys.task ;\n"
": SYS.TERM free: actobj sys.term ;\n";

const char* actobj_fth = (const char*) temp_binary_data_4;

//================== allocator.fth ==================
static const unsigned char temp_binary_data_5[] =
"\\ Allocate numbered resources, track with an array.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"\\ MOD: PLB 5/13/87 Add block allocation.\n"
"\\ MOD: PLB 10/22/87 Add MARK: for forced allocation.\n"
"\n"
"MRESET ALLOCATE:\n"
"\n"
"ANEW TASK-ALLOCATOR\n"
"\n"
"METHOD ALLOCATE:\n"
"METHOD ALLOCATE.RANGE:\n"
"METHOD DEALLOCATE:\n"
"METHOD ALLOCATE.BLOCK:\n"
"METHOD ALLOCATE.BLOCK.RANGE:\n"
"METHOD DEALLOCATE.BLOCK:\n"
"METHOD PUT.OFFSET:\n"
"METHOD GET.OFFSET:\n"
"METHOD MARK:\n"
"\n"
":CLASS OB.ALLOCATOR <SUPER OB.BARRAY\n"
"    IV.LONG IV-ALLOC-OFFSET\n"
"\n"
":M INIT: ( -- )\n"
"    init: super\n"
"    0 iv=> iv-alloc-offset\n"
";M\n"
"\n"
":M NEW: ( -- , make sure clear )\n"
"    new: super\n"
"    clear: self\n"
";M\n"
"\n"
":M PUT.OFFSET: ( offset -- )\n"
"    iv=> iv-alloc-offset\n"
";M\n"
"\n"
":M GET.OFFSET: ( -- offset)\n"
"    iv-alloc-offset\n"
";M\n"
"\n"
": <ALLOC.MARK> ( actual_index -- )\n"
"    1 swap +to: self\n"
";\n"
": <ALLOC.UNMARK> ( actual_index -- )\n"
"    dup>r at: self 1- 0 max\n"
"    r> to: self\n"
";\n"
"\n"
"\\ This is used when you want to grab a resource\n"
"\\ and don't care if it's already allocated.\n"
":M MARK: ( index -- , mark a resource as allocated )\n"
"    iv-alloc-offset - <alloc.mark>\n"
";M\n"
"\n"
": <ALLOC.RANGE>  ( hi_index lo_index --  index true | false )\n"
"    false -rot\n"
"    ?DO i at: self 0=\n"
"        IF i <alloc.mark>  ( mark as allocated )\n"
"           drop i iv-alloc-offset + true leave\n"
"        THEN\n"
"    LOOP\n"
";\n"
"\n"
":M ALLOCATE.RANGE: ( lo hi -- index true | false , alloc within range)\n"
"    1+ iv-alloc-offset -\n"
"    swap iv-alloc-offset -\n"
"    <alloc.range>\n"
";M\n"
"\n"
":M ALLOCATE: ( -- index true | false , allocate one if available )\n"
"    size: self 0\n"
"    <alloc.range>\n"
";M\n"
"\n"
":M DEALLOCATE: ( index -- )\n"
"    iv-alloc-offset - <alloc.unmark>\n"
";M\n"
"\n"
": <ALLOC.BLOCK.RANGE>\n"
"( #in_block lo hi -- index true | false , allocate contiguous)\n"
"    >r >r false swap r> r>\n"
"    ?DO  i at: self 0=\n"
"        IF ( -- false #in , contiguous block? )\n"
"           true over i + i\n"
"           ?DO  i at: self\n"
"               IF drop false LEAVE\n"
"               THEN\n"
"           LOOP   ( -- false #in contiguous? )\n"
"           IF  i + i\n"
"               ?DO  i <alloc.mark>  ( mark as allocated )\n"
"               LOOP\n"
"               drop i iv-alloc-offset + true 0 ( sacrifice 0 ) leave\n"
"           THEN\n"
"        THEN\n"
"    LOOP drop\n"
";\n"
"\n"
":M ALLOCATE.BLOCK.RANGE:\n"
"( #in_block lo hi -- index true | false , allocate contiguous)\n"
"    2 pick - 2+ \n"
"    iv-alloc-offset -\n"
"    swap iv-alloc-offset -\n"
"    <alloc.block.range>\n"
";M\n"
"\n"
":M ALLOCATE.BLOCK: ( #in_block -- index true | false , allocate contiguous)\n"
"    size: self \n"
"    over - 1+ 0\n"
"    <alloc.block.range>\n"
";M\n"
"\n"
":M DEALLOCATE.BLOCK: ( index size -- , deallocate contiguous)\n"
"    0 ?DO\n"
"        dup deallocate: self 1+\n"
"    LOOP drop\n"
";M\n"
"\n"
":M PRINT.ELEMENT:  ( index -- )\n"
"    dup iv-alloc-offset + 3 .r\n"
"    at.self\n"
"    IF .\"  In Use\"\n"
"    ELSE .\"  Available\"\n"
"    THEN cr\n"
";M\n"
"\n"
";CLASS\n"
"\n";

const char* allocator_fth = (const char*) temp_binary_data_5;

//================== bevel.fth ==================
static const unsigned char temp_binary_data_6[] =
"\\ Draw gadgets using 3D style rectangles.\n"
"\n"
"ANEW TASK-BEVEL\n"
"\n"
"2 value color_lit\n"
"3 value color_shaded\n"
"\n"
": DRAW.BEVEL { x1 y1 x2 y2 down? -- }\n"
"    gr.color@ >r\n"
"    down? IF color_shaded ELSE color_lit THEN gr.color!\n"
"    x1 y2 gr.move\n"
"    x1 y1 gr.draw x2 y1 gr.draw\n"
"\\\n"
"    down? IF color_lit ELSE color_shaded THEN gr.color!\n"
"    x2 y2 gr.draw x1 y2 gr.draw\n"
"    r> gr.color!\n"
";\n"
"\n"
": DRAW.THICK.BEVEL { x1 y1 x2 y2 down? thickness -- }\n"
"    thickness 0\n"
"    ?DO\n"
"        x1 i + y1 i +\n"
"        x2 i - y2 i -\n"
"        down? draw.bevel\n"
"    LOOP\n"
";\n"
"\n";

const char* bevel_fth = (const char*) temp_binary_data_6;

//================== build_menus.fth ==================
static const unsigned char temp_binary_data_7[] =
"\\ Build menus for HMSL\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 2/26/90 Moved CUSTOM-SCREENS object to H:SCREEN.\n"
"\n"
"ANEW TASK-BUILD_MENUS\n"
"\n"
"variable IF-HMSL-MENUS\n"
"\n"
"defer HMSL.RESET\n"
"\n"
": MAIN.QUIT  ( - )\n"
"    quit-hmsl on\n"
";\n"
"\n"
"133 constant HMSL_MENU_ID\n"
"134 constant CUSTOM_MENU_ID\n"
"\n"
"variable hmsl-menu-ptr\n"
"variable custom-menu-ptr\n"
"\n"
": MENUS.MAKE.SCR  ( -- , set text based on custom screen titles )\n"
"    .\" MENUS.MAKE.SCR - unimplemented!\" cr\n"
";\n"
"\n"
": MENUS.MAKE.HMSL  ( -- , create menus on the fly )\n"
"    .\" MENUS.MAKE.HMSL - unimplemented!\" cr\n"
";\n"
"\n"
": MENUS.DISPOSE ( -- , get rid of them )\n"
"    .\" MENUS.DISPOSE - unimplemented!\" cr\n"
";\n"
"\n"
": MENUS.DRAW ( -- )\n"
"    .\" MENUS.DRAW - unimplemented!\" cr\n"
";\n"
"\n"
": MENUS.UNDRAW  ( -- )\n"
"    .\" MENUS.UNDRAW - unimplemented!\" cr\n"
";\n"
"\n"
": MENUS.INIT ( -- , Build Master Menu)\n"
"    \" MENUS.INIT\" debug.type\n"
"\\   'c menus.draw is draw.hmsl.menus\n"
"\\   'c menus.undraw is undraw.hmsl.menus\n"
";\n"
"\n"
": MENUS.TERM  ( -- )\n"
"\\   'c noop is draw.hmsl.menus\n"
"\\   'c noop is undraw.hmsl.menus\n"
";\n"
"\n"
"\\ This word must be supported on different hosts.\n"
": PROCESS.MAIN.MENU  ( item -- )\n"
"    CASE\n"
"       1 OF hmsl.reset   ENDOF\n"
"       2 OF main.quit    ENDOF\n"
"       notyet\n"
"    ENDCASE\n"
";\n"
"\n"
": PROCESS.CUSTOM.MENU  ( item -- )\n"
"    1- \n"
"    dup many: custom-screens <\n"
"    IF  cg-current-screen @ ?dup\n"
"        IF undraw: []\n"
"        THEN\n"
"        get: custom-screens draw: []\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": PROCESS.MENUS ( -- )\n"
"    .\" PROCESS.MENUS - unimplemented!\" cr\n"
"\\    ev.get.menuitem  swap hmsl_menu_id =\n"
"\\   IF process.main.menu\n"
"\\   ELSE process.custom.menu\n"
"\\   THEN\n"
";\n"
"\n"
": SYS.INIT sys.init menus.init ;\n"
": SYS.TERM menus.term sys.term ;\n";

const char* build_menus_fth = (const char*) temp_binary_data_7;

//================== charmacr.fth ==================
static const unsigned char temp_binary_data_8[] =
"\\ @(#) charmacr.fth 96/06/11 1.1\n"
"\\ These words supports character and string manipulation.\n"
"\\ These words are like the 'C' macros.\n"
"\\\n"
"\\ *********************************************************************\n"
"\\ * HMSL Forth System                                                 *\n"
"\\ * Author: Phil Burk                                                 *\n"
"\\ * Copyright 1989 Phil Burk , All Rights Reserved                    *\n"
"\\ *********************************************************************\n"
"\n"
"ANEW TASK-CHARMACR\n"
"\n"
"HEX\n"
"\n"
": ISUPPER ( char -- true_if_uppercase )\n"
"    41  5A within?\n"
";\n"
"\n"
": ISLOWER ( char -- true_if_lowercase )\n"
"    61 7B within?\n"
";\n"
"\n"
": ISDIGIT ( char -- true_if_digit )\n"
"    30 39 within?\n"
";\n"
"\n"
": TOLOWER ( char -- lowercase_char , convert )\n"
"    dup isupper\n"
"    IF 20 +\n"
"    THEN\n"
";\n"
"\n"
": TOUPPER ( char -- uppercase_char , convert )\n"
"    dup islower\n"
"    IF 20 -\n"
"    THEN\n"
";\n"
"\n"
": ISPRINT ( char -- true_if_printable )\n"
"    20 7E within?\n"
";\n"
"\n"
": ISBLACK ( char -- true_if_black )\n"
"    21 7E within?\n"
";\n"
"\n"
": ISLETTER  ( char -- flag , is char a letter )\n"
"    dup isupper\n"
"    swap islower OR\n"
";\n"
"\n"
": ISSPACE ( char -- flag , SPACE , TAB or NEWLINE )\n"
"    dup BL = \n"
"    over 09 = OR\n"
"    swap 0A = OR\n"
";\n"
"\n"
"DECIMAL\n";

const char* charmacr_fth = (const char*) temp_binary_data_8;

//================== circular.fth ==================
static const unsigned char temp_binary_data_9[] =
"\\ @(#) circular.fth 96/06/11 1.1\n"
"\\ Circular Buffer for FIFO queue.\n"
"\\\n"
"\\ New values will be added to the circular buffer\n"
"\\ using ADD: and read out using NEXT:\n"
"\\\n"
"\\ An error message will be printed if too many values\n"
"\\ are added or removed.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1987 Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ MOD: PLB 11/18/87 Use IV-CIRC-MANY for housekeeping.\n"
"\n"
"EXISTS? OB.ELMNTS NOT .IF\n"
"    MRESET ADD:\n"
".THEN\n"
"\n"
"ANEW TASK-CIRCULAR\n"
"\n"
".NEED ADD:\n"
"METHOD ADD:\n"
"METHOD NEXT:\n"
"METHOD MANY:\n"
".THEN\n"
"\n"
":CLASS OB.CIRCULAR <SUPER  OB.ARRAY\n"
"    IV.LONG IV-CIRC-WRITE  ( points to next empty hole )\n"
"    IV.LONG IV-CIRC-READ   ( points to first unread value )\n"
"        IV.LONG IV-CIRC-MANY\n"
"\n"
":M MANY:  ( -- number_values , number of values in buffer )\n"
"    iv-circ-many\n"
";M\n"
"\n"
":M CLEAR: ( -- )\n"
"    0 iv=> iv-circ-write\n"
"    0 iv=> iv-circ-read\n"
"    0 iv=> iv-circ-many\n"
";M\n"
"\n"
":M NEW: ( #elements -- )\n"
"    new: super\n"
"    clear: self\n"
";M\n"
"\n"
":M ADD: ( value -- , add to FIFO queue )\n"
"    iv-circ-write dup iv-#cells <\n"
"    IF  to.self\n"
"        1 iv+> iv-circ-write\n"
"    ELSE drop 0 to.self\n"
"        1 iv=> iv-circ-write\n"
"    THEN\n"
"    1 iv+> iv-circ-many\n"
"    iv-circ-many iv-#cells >\n"
"    IF \" ADD: OB.CIRCULAR\" \" Too much data in circular buffer!\"\n"
"        er_return ob.report.error\n"
"    THEN\n"
";M\n"
"\n"
":M NEXT: ( -- value , get next value from FIFO )\n"
"    iv-circ-read dup iv-#cells =\n"
"    IF drop 0 0 iv=> iv-circ-read\n"
"    THEN\n"
"    at.self\n"
"    -1 iv+> iv-circ-many\n"
"    iv-circ-many 0<\n"
"    IF \" NEXT: OB.CIRCULAR\" \" Attempt to get more data than there is!\"\n"
"        er_return ob.report.error\n"
"    ELSE\n"
"        1 iv+> iv-circ-read\n"
"    THEN\n"
";M\n"
"\n"
":M PRINT: ( -- )\n"
"    cr many: self 0 max 0\n"
"    ?DO  i iv-circ-read + iv-#cells mod\n"
"        dup . self at: [] . cr\n"
"        ?pause\n"
"    LOOP\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"if-testing @ .IF\n"
"OB.CIRCULAR CIRC-1\n"
": TEST.CIRC\n"
"    8 new: circ-1\n"
"    0 add: circ-1 0\n"
"    50 1\n"
"    DO i add: circ-1 i\n"
"        many: circ-1 2 -\n"
"        IF .\" MANY: doesn't work! = \" many: circ-1 . cr\n"
"        THEN\n"
"        next: circ-1 rot .s = NOT\n"
"        IF .\" Bad Value!\"\n"
"        THEN\n"
"        ?pause\n"
"    LOOP\n"
"    drop\n"
"    free: circ-1\n"
";\n"
".THEN\n";

const char* circular_fth = (const char*) temp_binary_data_9;

//================== collection.fth ==================
static const unsigned char temp_binary_data_10[] =
"\\ Notes: to implement\n"
"\\ - productions also have behavior to select functions\n"
"\\ - players have behavior to select shapes\n"
"\\\n"
"\\ Collections are the primary morph for building hierarchies.\n"
"\\ Collections can contain other morphs, like players,\n"
"\\ structures, productions, or other collections.\n"
"\\ There are two basic kinds of collections, sequential and\n"
"\\ parallel. Sequential collections execute their component\n"
"\\ morphs one after the other.  Parallel collections start\n"
"\\ all their morphs at the same time.  Collections are done\n"
"\\ when the last sub morph finishes.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\n"
"\\ MOD: PLB 10/13/86 Changed to IV.LONG system\n"
"\\ MOD: PLB 1/?\?/87 Changed EXECUTE: strategy.\n"
"\\ MOD: PLB 1/27/87 Added repeat count. Removed auto add:\n"
"\\      to coll-holder. \n"
"\\ MOD: PLB 2/27/87 Changed OB.COLL.LOOP to use late bound EXEC.ONCE:\n"
"\\ MOD: PLB 3/2/87 Add REPEAT to PRINT:\n"
"\\ MOD: PLB 5/23/87 Check REPEAT.COUNT at beginning for zero.\n"
"\\      Add STOP:\n"
"\\ MOD: PLB 5/28/87 Set REPCOUNT in PUT.REPEAT:\n"
"\\      Add 0STUFF:\n"
"\\ MOD: PLB 6/10/87 Add DEFAULT:\n"
"\\ MOD: PLB 11/3/87 Add DELETE:\n"
"\\ MOD: PLB 4/26/88 Add check for overflow in DONE:\n"
"\\ MOD: PLB 4/26/88 Make DELETE: use late bound REMOVE:\n"
"\\      so that actions work.\n"
"\\ MODS to OLD STRUCTURE which was a collection with a behavior.\n"
"\\ MOD: PLB 7/9/86 Created new class called OB.FRAME \n"
"\\      This is essentially a structure without the grid of\n"
"\\      tendencies. These objects can have variable number\n"
"\\      of collections without having to resize the grid.\n"
"\\ MOD: PLB 7/29/86 Added ability to terminate a structure if\n"
"\\      a bahavior returns an index < 0.\n"
"\\ MOD: PLB 10/11/86 Use default behavior, set LASTCOLL to -1 for\n"
"\\      proper sequencing that starts at 0\n"
"\\ MOD: PLB 10/13/86 Change to IV.LONG system.\n"
"\\ MOD: PLB 1/14/87 Converted to new DONE: method.\n"
"\\      Base on EXECUTE and DONE: instead of TASK:\n"
"\\ MOD: PLB 1/27/87 Changed FRAME to STRUCTURE, STRUCTURE to\n"
"\\      TSTRUCTURE, Changed GET.LAST.COLLID: to GET.LAST.ID:\n"
"\\ MOD: PLB 3/1/87 Made behaviors terminate, BEHAVE: updates iv-last-morph.\n"
"\\ MOD: PLB 3/2/87 Support repeat count in struct.\n"
"\\ MOD: PLB 3/7/87 Add error for EXTEND:\n"
"\\ MOD: PLB 5/23/87 Added STOP check, check REPEAT count at beginning.\n"
"\\ MOD: PLB 6/15/87 Add DEFAULT:\n"
"\\ MOD: PLB 10/7/87 Use instance object for Tendency Grid.\n"
"\\ ------------------------------------------------------\n"
"\\\n"
"\\ MOD: PLB 10/21/88 Radical Redesign of COLLECTION, move behavior\n"
"\\ into it from OB.STRUCTURE.  Allowed switching between parallel and\n"
"\\ sequential mode.\n"
"\\ MOD: PLB 8/11/89 Fixed order for Parallel execution.\n"
"\\      Set mode at INIT: instead of default.\n"
"\\ MOD: PLB 8/31/89 Fixed STOP: self bug.\n"
"\\ MOD: PLB 2/6/90 Add FINISH: method.\n"
"\\ MOD: PLB 3/12/90 c/REPITITION/REPETITION/\n"
"\\ MOD: Reorganize STOP code, use TERMINATE:\n"
"\\ MOD: PLB 4/13/90 Added GET.NEXT.TIME: for ACTOBJ\n"
"\\ MOD: PLB 6/11/90 Fixed STOP.DELAY\n"
"\\ MOD: PLB 4/28/91 Add 0 IV=> IV-REPCOUNT to COL.STOP\n"
"\\ 00001 PLB 12/4/91 Reorder START FUNCTION, before start delay\n"
"\\         Add stack checks to start, stop, repeat function calls.\n"
"\\ 00002 PLB 2/6/92 Remove stack checks and cuz of EXEC.STACK?\n"
"\\          Add stack check to COL.EXEC.BEHAV\n"
"\\ 00003 PLB 3/31/92 Ripped out all generic stuff and moved\n"
"\\           it to OB.MORPH\n"
"\\ 00004 PLB 5/21/92 Fix stack check in COL.EXEC.BEHAV\n"
"\\           Put OB.STRUCTURE in a separate file.\n"
"\\ 00005 PLB 5/21/92 Add EDIT: method.\n"
"\\ 00006 PLB 8/3/92 Mac objects now absolute addresses.\n"
"\n"
"ANEW TASK-COLLECTION\n"
"\n"
"\\ Control whether a collection is simply sequential, simply parallel\n"
"\\ or uses a complex behavior.\n"
"METHOD ACT.SEQUENTIAL:         METHOD ACT.PARALLEL:\n"
"METHOD PUT.BEHAVIOR:     METHOD GET.BEHAVIOR:\n"
"\n"
"\\ -----------------------------------------------------------\n"
":CLASS OB.COLLECTION <SUPER OB.MORPH\n"
"    IV.LONG IV-COL-MODE\n"
"    IV.LONG IV-PENDING      ( used for counting unfinished )\n"
"    IV.LONG IV-BEHAVE-CFA   ( CFA of behavior word )\n"
"\n"
"0 constant PARALLEL_MODE\n"
"1 constant SEQUENTIAL_MODE\n"
"2 constant BEHAVIOR_MODE\n"
"\n"
":M ?HIERARCHICAL:  ( -- flag , true if can contain other morphs)\n"
"    true\n"
";M\n"
"\n"
":M INIT: ( -- )\n"
"    init: super\n"
"    parallel_mode iv=> iv-col-mode\n"
";M\n"
"\n"
":M ?NEW:  ( Max_elements -- addr | 0 )\n"
"    1 ?NEW: SUPER   ( declare as one dimensional )\n"
";M\n"
"\n"
":M NEW: ( max_elements -- , abort if error )\n"
"    ?new: self <new:error>\n"
";M\n"
"\n"
"\\ Since this is a one-dimensional list, let's inherit a bunch\n"
"\\ of list methods.\n"
"inherit.method delete: ob.list\n"
"inherit.method 0stuff: ob.list\n"
"inherit.method }stuff: ob.list\n"
"inherit.method freeall: ob.objlist\n"
"inherit.method deinstantiate: ob.objlist\n"
"inherit.method ?instantiate: ob.objlist\n"
"\n"
":M DEINSTANTIATE.HIERARCHY:\n"
"    self ?hierarchical: []\n"
"    IF\n"
"        many: self 0\n"
"        ?DO\n"
"            i get: self deinstantiate.hierarchy: []\n"
"        LOOP\n"
"        deinstantiate: self\n"
"    ELSE\n"
"        free: self\n"
"    THEN\n"
";M\n"
"\n"
":M ACT.SEQUENTIAL: ( -- , behave sequentially )\n"
"    sequential_mode iv=> iv-col-mode\n"
";M\n"
"\n"
":M ACT.PARALLEL: ( -- , behave in parallel )\n"
"    parallel_mode iv=> iv-col-mode\n"
";M\n"
"\n"
":M PUT.BEHAVIOR:  ( cfa-behavior  -- , set behavior to be used)\n"
"    dup iv=> iv-behave-cfa\n"
"    IF behavior_mode\n"
"    ELSE parallel_mode\n"
"    THEN iv=> iv-col-mode\n"
";M\n"
"\n"
":M GET.BEHAVIOR:  ( -- cfa-behavior  , fetch behavior's cfa )\n"
"     iv-behave-cfa\n"
";M\n"
"\n"
":M PRINT.ELEMENT:  ( e# -- , print the element )\n"
"    get: self  ( get morph)\n"
"    dup get.weight: [] 4 .r 4 spaces   ( show weights )\n"
"    name: []\n"
";M\n"
"\n"
":M PRINT: ( -- , print it )\n"
"     print: super\n"
"     iv-col-mode\n"
"     CASE\n"
"        sequential_mode OF .\" Sequential Mode\" cr ENDOF\n"
"        parallel_mode OF .\" Parallel Mode\" cr ENDOF\n"
"        behavior_mode OF .\" Behavior = \"\n"
"            iv-behave-cfa >name id. cr ENDOF\n"
"     ENDCASE\n"
";M\n"
"\n"
"( sequential collections execute the next element after )\n"
"( receiving a done message from the previous. )\n"
": COL.BHV.SEQ ( -- index 1 | 0 )\n"
"    iv-current dup many: self <\n"
"    IF dup 1+ iv=> iv-current 1\n"
"    ELSE drop 0\n"
"    THEN\n"
";\n"
"\n"
"( Parallel collections wait for all DONE: messages )\n"
"( to arrive before signalling completion. )\n"
": COL.BHV.PAR ( -- 0 1 2 ... N , exec all morphs NOW)\n"
"    iv-col-done?\n"
"    IF 0\n"
"    ELSE  many: self dup 1- swap\n"
"        0 ?DO dup i - swap LOOP 1+  set.done: self\n"
"    THEN\n"
";\n"
"\n"
": COL.EXEC.BEHAV ( -- v0 v1 .. vn N | 0 ) \\ 00002\n"
"    depth >r\n"
"    self iv-behave-cfa execute\n"
"    depth 1- over - r> -    \\ 00004 was OVER +\n"
"    IF\n"
"        .s \" COL.EXEC.BEHAV\" \" Stack error in behavior!\"\n"
"        er_fatal ob.report.error\n"
"    THEN\n"
";\n"
"\n"
": COL.BEHAVE ( -- v0 v1 .. vn N | 0 , execute morphs just once )\n"
"    iv-col-mode\n"
"    CASE\n"
"        parallel_mode OF col.bhv.par ENDOF\n"
"        sequential_mode OF col.bhv.seq ENDOF\n"
"        behavior_mode OF col.exec.behav ENDOF\n"
"        \" COL.EXEC.ONCE\" \" Illegal mode!\"\n"
"        er_fatal ob.report.error\n"
"    ENDCASE\n"
";\n"
"\n"
": COL.UPDATE.TIME ( time -- , update maximum time )\n"
"    dup iv-time-next time> \\ !!!!\n"
"    IF iv=> iv-time-next\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": COL.EXEC.LOOP  ( -- )\n"
"\\ Execute morphs until one tasks itself or done.\n"
"    BEGIN\n"
"        0 iv=> iv-pending\n"
"        col.behave dup 0>\n"
"        IF  0\n"
"            DO >r iv-time-next self r> at: self    ?execute: []\n"
"               IF col.update.time\n"
"               ELSE 1 iv+> iv-pending\n"
"               THEN\n"
"            LOOP\n"
"        ELSE drop col.do.repeat reset: self\n"
"        THEN\n"
"        iv-repcount 0= iv-pending 0> or\n"
"    UNTIL\n"
";\n"
"\n"
": COL.STOP.CHILDREN  ( time -- )\n"
"    self ?hierarchical: []\n"
"    IF  reset: self\n"
"        BEGIN manyleft: self\n"
"        WHILE dup next: self\n"
"            0 over put.invoker: [] ( orphan them first )\n"
"            terminate: []\n"
"        REPEAT\n"
"    THEN\n"
"    drop\n"
";\n"
"\n"
":M TERMINATE:  ( time -- , stop all children )\n"
"    iv-if-active\n"
"    IF  \n"
"        dup col.stop.children\n"
"        morph.stop\n"
"    ELSE drop\n"
"    THEN\n"
"\n"
";M\n"
"\n"
":M DONE: ( time sender -- , process completion message from child )\n"
"    mo.track.done drop\n"
"    col.update.time\n"
"\\\n"
"\\ Is this the last one to report back?\n"
"    iv-pending  1-  dup iv=> iv-pending 0=\n"
"    IF\n"
"\\ are there any repetitions left?\n"
"        iv-repcount\n"
"        IF  col.exec.loop  ( give it a chance to finish )\n"
"        THEN\n"
"\\\n"
"\\ is it finally done?\n"
"        iv-repcount 0=\n"
"        IF  iv-time-next morph.stop\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M CUSTOM.EXEC: ( -- time true | false )\n"
"    many: self 0>\n"
"    IF\n"
"        col.exec.loop\n"
"    THEN\n"
"    iv-pending\n"
"    IF false\n"
"    ELSE iv-time-next true\n"
"    THEN\n"
";M\n"
"\n"
":M PRINT.HIERARCHY: ( -- , print name and indent for children )\n"
"    print.hierarchy: super\n"
"    3 morph-indent +!\n"
"    many: self 0\n"
"    ?DO i get: self print.hierarchy: []\n"
"    LOOP\n"
"    -3 morph-indent +!\n"
";M\n"
"\n"
":M 0STUFF: ( 0 m0 m1 ... mN -- , easy build of collection)\n"
"    <0stuff:>\n"
";M\n"
"\n"
":M }STUFF:  ( stuff...  --- , load it into object )\n"
"    stuff.depth >r\n"
"        <}stuff:>\n"
"    r> set.many: self\n"
";M\n"
"\n"
":M CLASS.NAME: ( -- $NAME )\n"
"    \" OB.COLLECTION\"\n"
";M\n"
"\n"
"defer EDIT.COLLECTION\n"
"' drop is edit.collection\n"
"\n"
":M EDIT: ( -- , edit using current editor ) \\ 00005\n"
"    self edit.collection\n"
";M\n"
"\n"
":M DUMP.SOURCE.BODY:\n"
"    dump.morph.body\n"
"\\\n"
"     >newline tab\n"
"     iv-col-mode\n"
"     CASE\n"
"        sequential_mode OF .\" act.sequential: \" ENDOF\n"
"        parallel_mode OF .\" act.sequential: \" ENDOF\n"
"        behavior_mode OF .\" 'c \"\n"
"            iv-behave-cfa cfa. .\" put.behavior: \"\n"
"            ENDOF\n"
"     ENDCASE\n"
"     name: self cr\n"
"\\\n"
"    iv-pntr \n"
"    IF\n"
"        tab max.elements: self . .\"  new: \" name: self cr\n"
"\\\n"
"        many: self 0>\n"
"        IF\n"
"            tab .\" stuff{\" cr\n"
"            tab tab \n"
"            many: self 0\n"
"            ?DO\n"
"                i get: self name: []\n"
"                out @ 60 >\n"
"                IF\n"
"                    cr tab tab\n"
"                ELSE\n"
"                    space\n"
"                THEN\n"
"            LOOP\n"
"            cr\n"
"            tab .\" }stuff: \" name: self cr\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\\ Included for compatibility.\n"
": OB.COLL.PAR ( -- fake old style collection )\n"
"    .\" OB.COLL.PAR is obsolete, use OB.COLLECTION !\" cr\n"
"    ob.collection\n"
";\n"
": OB.COLL.SEQ ( -- fake old style collection )\n"
"    .\" OB.COLL.SEQ is obsolete, use OB.COLLECTION !\" cr\n"
"    ob.collection\n"
"    latest name> >body\n"
"\\ use->rel \\ 00006\n"
"    act.sequential: []\n"
";\n"
"\n"
": BH.RANDOM ( struct --  next-id 1 | 0, choose randomly)\n"
"    many: [] 1+ choose  dup\n"
"    IF 1- 1\n"
"    THEN\n"
";\n"
"\n";

const char* collection_fth = (const char*) temp_binary_data_10;

//================== cond_comp.fth ==================
static const unsigned char temp_binary_data_11[] =
"\\ Conditional Compilation\n"
"\\\n"
"\\ *********************************************************************\n"
"\\ * HMSL Forth System                                                 *\n"
"\\ * Author: Phil Burk                                                 *\n"
"\\ * Copyright 1989 Phil Burk , All Rights Reserved                    *\n"
"\\ *********************************************************************\n"
"\\\n"
"\\ MOD: PLB 10/9/90 Removed check for ?TERMINAL in .ELSE\n"
"decimal\n"
"ANEW TASK-COND_COMP\n"
"\n"
"\\ Lifted from X3J14 dpANS-6 document.\n"
"\n"
": .ELSE  ( -- )\n"
"    1\n"
"    BEGIN                                 \\ level\n"
"      BEGIN\n"
"        BL WORD                           \\ level $word\n"
"        COUNT  DUP                        \\ level adr len len\n"
"      WHILE                               \\ level adr len\n"
"        2DUP  S\" .IF\"  COMPARE 0=\n"
"        IF                                \\ level adr len\n"
"          2DROP 1+                        \\ level'\n"
"        ELSE                              \\ level adr len\n"
"          2DUP  S\" .ELSE\"\n"
"          COMPARE 0=                      \\ level adr len flag\n"
"          IF                              \\ level adr len\n"
"             2DROP 1- DUP IF 1+ THEN      \\ level'\n"
"          ELSE                            \\ level adr len\n"
"            S\" .THEN\"  COMPARE 0=\n"
"            IF\n"
"              1-                          \\ level'\n"
"            THEN\n"
"          THEN\n"
"        THEN\n"
"        ?DUP 0=  IF EXIT THEN             \\ level'\n"
"      REPEAT  2DROP                       \\ level\n"
"    REFILL 0= UNTIL                       \\ level\n"
"    DROP\n"
";  IMMEDIATE\n"
"\n"
": .IF  ( flag -- )\n"
"\t0=\n"
"\tIF POSTPONE .ELSE\n"
"\tTHEN\n"
";  IMMEDIATE\n"
"\n"
": .THEN  ( -- )\n"
";  IMMEDIATE\n"
"\n"
": .NEED ( <name> -- start compiling if not found )\n"
"    [compile] exists? not [compile] .IF\n"
";\n"
"\n"
": $REMOVE\" ( $string -- , remove trailing \" )\n"
"    dup count 1- + c@ ascii \" =\n"
"    IF cr .\" Removing extraneous \" ascii \" emit .\"   from name!\" cr\n"
"        dup c@ 1- swap c!\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n";

const char* cond_comp_fth = (const char*) temp_binary_data_11;

//================== control.fth ==================
static const unsigned char temp_binary_data_12[] =
"\\ Control Class\n"
"\\\n"
"\\ This is a host independant facility for interacting with\n"
"\\ a user.\n"
"\\ Controls reside in a screen and are sent messages\n"
"\\ to draw and to respond to mouse up and down events.\n"
"\\ Control grids display text in a grid, when selected\n"
"\\ with the mouse, they execute an associated CFA.  Different\n"
"\\ grids have different behaviors.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 6/30/86 Added ABS to deltaxy!\n"
"\\ MOD: PLB 7/18/86 Added UNDRAW: and MENUPICK: methods.\n"
"\\ MOD: PLB 7/25/86 Added GR.CHECK call to DRAW:\n"
"\\ MOD: PLB 10/13/86 Converted to use IV.LONG, START.XY: to TOPLEFT:\n"
"\\ MOD: PLB 11/21/86 Add service.tasks to DRAW: , no highlight\n"
"\\      if disabled.\n"
"\\ MOD: PLB 12/3/86 Use GR_SMALL_TEXT GR.HEIGHT!\n"
"\\ MOD: PLB 12/15/86 Base text position on text height.\n"
"\\ MOD: PLB 4/27/87 Clear entire control area in DRAW:\n"
"\\ MOD: PLB 5/28/87 Add PRINT:\n"
"\\ MOD: PLB 8/13/87 Move HIGHLIGHT: start 1,1 in x,y\n"
"\\ MOD: PLB 1/28/87 Add more service.tasks to DRAW:\n"
"\\\n"
"\\ MOD: PLB 2/8/88 REWRITTEN based on new design!!!\n"
"\\ MOD: PLB 3/22/89 Reorganize, not OB.ELMNTS.\n"
"\\ MOD: PLB 9/22/89 Split XYWH into XY & WH\n"
"\\ MOD: PLB 12/12/89 Change to Single/Multi Valued System.\n"
"\\      MIN and MAX have part#s, -1 for all.\n"
"\\ MOD: PLB 2/24/90 Use EXECUTE: method for executing CFAs.\n"
"\\ MOD: PLB 3/90 Fix HIGHLIGHT:\n"
"\\ MOD: PLB 4/15/90 Add PUT.TEXT.FONT: etc.\n"
"\\ MOD: PLB 10/30/90 c/i/r@/ in DRAW.PART:\n"
"\\ MOD: PLB 2/10/91 No reference to GR_BIG_TEXT\n"
"\\ MOD: PLB 5/20/91 Added FREE: SUPER to FREE: OB.CHECK.GRID\n"
"\\ MOD: PLB 7/26/91 Remove ELSE DROP from }STUFF.TEXT:\n"
"\\ 00001 PLB 9/27/91 Add KEY:\n"
"\\ 00002 PLB 9/28/91 Added PUT.ACTIVE: GET.ACTIVE:\n"
"\\ 00003 PLB 11/12/91 Make PUT.ENABLE: use -1\n"
"\\ 00004 PLB 2/6/92 Add EXEC.STACK?\n"
"\\ 00005 PLB 2/12/92 Added PUT.WH.DC:\n"
"\\ 00006 PLB 2/21/92 Add 3D bevels, CG-3D, CG-BEVEL-THICKNESS\n"
"\\ 00007 PLB 2/22/92 Fix GET.INNER.RECT:\n"
"\\ 00008 PLB 2/27/92 Use MOUSE.UP: SUPER in MENU.GRID for cg-last-mx,y\n"
"\\ 00009 PLB 3/10/92 Added PUT.XY.DC:\n"
"\\ 00010 PLB 3/13/92 Removed 1 GR.COLOR! from CG.DRAW.TITLE\n"
"\\ 00011 PLB 5/23/92 Set default height in control.\n"
"\n"
"decimal\n"
"\n"
"ANEW TASK-CONTROL\n"
"\n"
"\\ If you want to put the NFA of a word in a grid cell.\n"
"\\ This word will fix the name, done automatically.\n"
": CG.FIXTEXT ( string1 -- string2 , Make new string if NFA )\n"
"    dup count swap drop 31 >\n"
"    IF nfa->$\n"
"    THEN\n"
";\n"
"\n"
"create &ZERO 0 ,\n"
"\n"
"METHOD GET.RECT:      METHOD GET.INNER.RECT:\n"
"METHOD ?DRAWN:\n"
"METHOD PUT.LASTHIT:   METHOD GET.LASTHIT:\n"
"\n"
"METHOD PUT.VALUE:     METHOD GET.VALUE:\n"
"METHOD PUT.ENABLE:    METHOD GET.ENABLE:\n"
"METHOD PUT.MIN:       METHOD GET.MIN:\n"
"METHOD PUT.MAX:       METHOD GET.MAX:\n"
"METHOD PUT.INCREMENT: METHOD GET.INCREMENT:\n"
"\n"
"( These functions will all be passed the current value and part# )\n"
"METHOD PUT.DOWN.FUNCTION:\n"
"METHOD GET.DOWN.FUNCTION:\n"
"METHOD PUT.UP.FUNCTION:\n"
"METHOD GET.UP.FUNCTION:\n"
"METHOD PUT.MOVE.FUNCTION:\n"
"METHOD GET.MOVE.FUNCTION:\n"
"\n"
"METHOD MOUSE.DOWN:    METHOD EXEC.DOWN:\n"
"METHOD MOUSE.UP:\n"
"METHOD MOUSE.MOVE:\n"
"METHOD EXECUTE:\n"
"\n"
"METHOD PUT.DRAW.FUNCTION:\n"
"METHOD GET.DRAW.FUNCTION:\n"
"METHOD PUT.UNDRAW.FUNCTION:\n"
"METHOD GET.UNDRAW.FUNCTION:\n"
"\n"
"METHOD PUT.XY:        METHOD GET.XY:\n"
"METHOD PUT.XY.DC:     METHOD GET.XY.DC:\n"
"METHOD PUT.WH:        METHOD GET.WH:\n"
"METHOD PUT.WH.DC:     METHOD GET.WH.DC:\n"
"METHOD DRAW:          METHOD UNDRAW:\n"
"METHOD XY.DRAW:       METHOD XY.UNDRAW:\n"
"\n"
"METHOD PUT.DATA:      METHOD GET.DATA:\n"
"METHOD PUT.TITLE:     METHOD GET.TITLE:\n"
"\n"
"GR_XOR_SUPPORTED [IF]\n"
"METHOD HIGHLIGHT:\n"
"[THEN]\n"
"\n"
"METHOD DRAW.PART:\n"
"METHOD ?HIT:\n"
"\n"
"METHOD PUT.TEXT.FUNCTION:  METHOD GET.TEXT.FUNCTION:\n"
"METHOD PUT.TEXT.SIZE:      METHOD GET.TEXT.SIZE:\n"
"METHOD PUT.TEXT.FONT:      METHOD GET.TEXT.FONT:\n"
"METHOD KEY: \\ 00001\n"
"METHOD PUT.ACTIVE:         METHOD GET.ACTIVE: \\ 00002\n"
"\n"
"( Define FLAG bits )\n"
"1 CONSTANT CG_ENABLE_MASK\n"
"\n"
"\\ Define variables used to track mouse.\n"
"\n"
"variable CG-FIRST-MX\n"
"variable CG-FIRST-MY\n"
"variable CG-LAST-MX\n"
"variable CG-LAST-MY\n"
"\n"
"variable CG-3D  \\ if true, draw using 3D bevel technique\n"
"cg-3d off\n"
"variable CG-BEVEL-THICKNESS\n"
"2 cg-bevel-thickness !\n"
"\n"
": CG.DEBUG.DRAW  ( -- , help debug drawing )\n"
"    if-debug @\n"
"    IF\n"
"        >newline .\" Drawing \" self name: [] cr\n"
"    THEN\n"
";\n"
"\n"
"( Define OB.CONTROL Class )\n"
":CLASS OB.CONTROL <SUPER OBJECT\n"
"\\ Positions and sizes are stored in Device Coordinates,\n"
"\\ or DC, for speed.  They are specified in World Coordinates,\n"
"\\ or WC, for portability.\n"
"    IV.SHORT IV-CG-LEFTX\n"
"    IV.SHORT IV-CG-TOPY\n"
"    IV.SHORT IV-CG-WIDTH\n"
"    IV.SHORT IV-CG-HEIGHT\n"
"    IV.SHORT IV-CG-DRAWN  ( true if currently drawn )\n"
"    IV.SHORT IV-CG-ACTIVE  ( true if currently the active control )\n"
"\\\n"
"    IV.LONG  IV-CG-DATA   ( User data )\n"
"    IV.LONG  IV-CG-TITLE\n"
"\\\n"
"    IV.LONG  IV-CG-VALUE    ( for single valued controls )\n"
"    IV.SHORT IV-CG-FLAG\n"
"    IV.SHORT IV-CG-LASTHIT  ( last part hit )\n"
"\\\n"
"    IV.LONG  IV-CG-DRAW-CFA\n"
"    IV.LONG  IV-CG-UNDRAW-CFA\n"
"    IV.LONG  IV-CG-DOWN-CFA   ( function to execute when down )\n"
"    IV.LONG  IV-CG-MOVE-CFA   ( function to execute when moved )\n"
"    IV.LONG  IV-CG-UP-CFA   ( function to execute when up )\n"
"    IV.LONG IV-CG-TEXT-CFA\n"
"    IV.LONG IV-CG-TEXT-SIZE\n"
"    IV.LONG IV-CG-TEXT-FONT\n"
"\\\n"
"    IV.LONG IV-CG-MIN\n"
"    IV.LONG IV-CG-MAX\n"
"    IV.LONG IV-CG-INCR\n"
"\n"
"\n"
":M INIT:  ( -- , INITIALIZE grid )\n"
"    init: super\n"
"    10 iv=> iv-cg-leftx\n"
"    20 iv=> iv-cg-topy\n"
"    40 iv=> iv-cg-width\n"
"    16 iv=> iv-cg-height \\ 00011\n"
"    0 iv=> iv-cg-title ( nothing drawn )\n"
"    0 iv=> iv-cg-draw-cfa\n"
"    0 iv=> iv-cg-undraw-cfa\n"
"    -1 iv=> iv-cg-min ( for true )\n"
"    1 iv=> iv-cg-max\n"
"    1 iv=> iv-cg-incr\n"
"    0 iv=> iv-cg-value\n"
"    cg_enable_mask iv=> iv-cg-flag\n"
"    0 iv=> iv-cg-drawn\n"
"    0 iv=> iv-cg-active \\ 00002\n"
"    gr_small_text iv=> iv-cg-text-size\n"
"    0 iv=> iv-cg-text-font\n"
";M\n"
"\n"
":M MANY:  ( -- n , number of values )\n"
"    1\n"
";M\n"
":M FREE:  ( -- , dummy to allow easier frees from object list )\n"
";M\n"
"\n"
"\\ Methods for setting up a control, specify appearance, etc.\n"
":M PUT.XY: ( leftx topy -- )\n"
"    scg.wc->dc\n"
"    iv=> iv-cg-topy    iv=> iv-cg-leftx\n"
";M\n"
"    \n"
":M GET.XY: ( -- leftx topy )\n"
"    iv-cg-leftx iv-cg-topy\n"
"    scg.dc->wc\n"
";M\n"
"\n"
":M PUT.XY.DC: ( leftx topy -- , device coordinates, pixels 00009 ) \n"
"    iv=> iv-cg-topy    iv=> iv-cg-leftx\n"
";M\n"
"\n"
":M GET.XY.DC: ( -- leftx topy )\n"
"    iv-cg-leftx iv-cg-topy\n"
";M\n"
"\n"
"\\ Set width, height -------------------\n"
":M PUT.WH: ( width height -- )\n"
"    scg.delta.wc->dc\n"
"    iv=> iv-cg-height    iv=> iv-cg-width\n"
";M\n"
"\n"
":M PUT.WH.DC: ( width height -- )\n"
"    iv=> iv-cg-height    iv=> iv-cg-width\n"
";M\n"
"    \n"
":M GET.WH: ( -- width height )\n"
"    iv-cg-width iv-cg-height\n"
"    scg.delta.dc->wc\n"
";M\n"
"    \n"
":M GET.WH.DC: ( -- width height )\n"
"    iv-cg-width iv-cg-height\n"
";M\n"
"\n"
"\\ --------------------------------------\n"
":M PUT.ACTIVE:  ( active? -- , set active or not 00002 )\n"
"      iv=> iv-cg-active\n"
";M\n"
":M GET.ACTIVE: ( -- active? )\n"
"      iv-cg-active \n"
";M\n"
"\n"
":M PUT.DATA:  ( data -- , user settable data value )\n"
"      iv=> iv-cg-data\n"
";M\n"
":M GET.DATA: ( -- data )\n"
"      iv-cg-data \n"
";M\n"
"\n"
":M PUT.TEXT.FUNCTION: ( cfa -- )\n"
"    iv=> iv-cg-text-cfa\n"
";M\n"
":M GET.TEXT.FUNCTION: ( -- cfa )\n"
"    iv-cg-text-cfa\n"
";M\n"
"\n"
":M PUT.TEXT.SIZE: ( size -- )\n"
"    iv=> iv-cg-text-size\n"
";M\n"
":M GET.TEXT.SIZE: ( -- size )\n"
"    iv-cg-text-size\n"
";M\n"
"\n"
":M PUT.TEXT.FONT: ( font -- )\n"
"    iv=> iv-cg-text-font\n"
";M\n"
":M GET.TEXT.FONT: ( -- font )\n"
"    iv-cg-text-font\n"
";M\n"
":M PUT.LASTHIT:  ( part# -- )\n"
"    iv=> iv-cg-lasthit\n"
";M\n"
":M GET.LASTHIT: ( -- part# )\n"
"    iv-cg-lasthit\n"
";M\n"
"\n"
":M PUT.DOWN.FUNCTION: ( cfa --  , cfa to execute when mouse down )\n"
"     iv=> iv-cg-down-cfa\n"
";M\n"
":M GET.DOWN.FUNCTION:  ( -- cfa )\n"
"    iv-cg-down-cfa\n"
";M\n"
":M PUT.MOVE.FUNCTION: ( cfa --  , cfa to execute when mouse moves )\n"
"     iv=> iv-cg-move-cfa\n"
";M\n"
":M GET.MOVE.FUNCTION:  ( -- cfa )\n"
"    iv-cg-move-cfa\n"
";M\n"
":M PUT.UP.FUNCTION: ( cfa --  , cfa to execute when mouse up )\n"
"     iv=> iv-cg-up-cfa\n"
";M\n"
":M GET.UP.FUNCTION:  ( -- cfa )\n"
"    iv-cg-up-cfa\n"
";M\n"
"\n"
":M PUT.DRAW.FUNCTION: ( cfa --  , cfa to execute when drawn )\n"
"     iv=> iv-cg-draw-cfa\n"
";M\n"
":M GET.DRAW.FUNCTION:  ( -- cfa )\n"
"     iv-cg-draw-cfa\n"
";M\n"
"\n"
":M PUT.UNDRAW.FUNCTION: ( cfa --  , cfa to execute when undrawn )\n"
"     iv=> iv-cg-undraw-cfa\n"
";M\n"
":M GET.UNDRAW.FUNCTION:  ( -- cfa )\n"
"     iv-cg-undraw-cfa\n"
";M\n"
"\n"
": CG.CLIP.VALUE ( value -- value' )\n"
"    iv-cg-min iv-cg-max clipto\n"
";\n"
"\n"
":M PUT.VALUE: ( value part -- )\n"
"    drop cg.clip.value iv=> iv-cg-value\n"
";M\n"
":M GET.VALUE: ( part -- value )\n"
"    drop iv-cg-value\n"
";M\n"
"\n"
": CG.CLIP.PART ( part -- , clip value of part to limits )\n"
"    dup self get.value: []\n"
"    swap self put.value: []\n"
";\n"
"\n"
": CG.CLIP.ALL  ( -- , clip all values )\n"
"    self many: [] 0\n"
"    ?DO i cg.clip.part\n"
"    LOOP\n"
";\n"
"\n"
":M PUT.ENABLE: ( flag part -- , enable or disable cell )\n"
"      drop iv-cg-flag swap\n"
"      IF cg_enable_mask OR\n"
"      ELSE cg_enable_mask invert and\n"
"      THEN iv=> iv-cg-flag\n"
";M\n"
":M GET.ENABLE:  ( part -- flag , Check for enable bit )\n"
"      drop iv-cg-flag cg_enable_mask and\n"
";M\n"
"\n"
":M PUT.MIN: ( min part -- , set minimum value for control )\n"
"    drop iv=> iv-cg-min cg.clip.all\n"
";M\n"
":M GET.MIN: ( part -- min , get minimum value for control )\n"
"    drop iv-cg-min\n"
";M\n"
"\n"
":M PUT.MAX: ( max part -- , set maximum value for control )\n"
"    drop iv=> iv-cg-max cg.clip.all\n"
";M\n"
":M GET.MAX: ( part -- max , get maximum value for control )\n"
"    drop iv-cg-max \n"
";M\n"
"\n"
":M PUT.INCREMENT: ( incr -- , set increment for control )\n"
"    iv=> iv-cg-incr\n"
";M\n"
":M GET.INCREMENT: ( -- incr , get increment value for control )\n"
"    iv-cg-incr\n"
";M\n"
"\n"
":M PUT.TITLE:  ( $title -- , SET control title )\n"
"      iv=> iv-cg-title\n"
";M\n"
":M GET.TITLE:  ( -- $title , GET control title )\n"
"      iv-cg-title \n"
";M\n"
"\n"
": CG.DRAW.TITLE ( -- , Draw title by control )\n"
"    get.title: self   ?dup\n"
"    IF\n"
"        iv-cg-text-size gr.height! \\ 1 gr.color!\n"
"        iv-cg-text-font gr.font!\n"
"        iv-cg-leftx iv-cg-topy  3 -\n"
"        rot gr.xytext\n"
"     THEN\n"
";\n"
"\n"
":M GET.RECT:  ( part -- x1 y1 x2 y2 , in DC )\n"
"    drop iv-cg-leftx iv-cg-topy\n"
"    over iv-cg-width +\n"
"    over iv-cg-height +\n"
";M\n"
"\n"
":M GET.INNER.RECT: { part | thick -- x1 y1 x2 y2 , in DC }\n"
"    cg-3d @\n"
"    IF\n"
"        cg-bevel-thickness @ -> thick\n"
"    ELSE\n"
"        1 -> thick\n"
"    THEN\n"
"    part self get.rect: []\n"
"    thick - >r\n"
"    thick - >r\n"
"    thick + >r\n"
"    thick + r> r> r>\n"
";M\n"
"\n"
":M ?DRAWN:  ( -- flag , true if currently drawn )\n"
"    iv-cg-drawn\n"
";M\n"
"\n"
":M DRAW:   ( -- , Draw control)\n"
"    cg.debug.draw\n"
"    gr.check  ( make sure there is a window open )\n"
"    iv-cg-draw-cfa ?dup\n"
"    IF\n"
"        0 exec.stack? \\ 00004\n"
"    THEN\n"
"\\\n"
"    service.tasks\n"
"    1 gr.color! \\ 00010\n"
"    cg.draw.title\n"
"    true iv=> iv-cg-drawn\n"
";M\n"
"\n"
":M UNDRAW:  ( -- )\n"
"    iv-cg-undraw-cfa ?dup\n"
"    IF\n"
"        0 exec.stack? \\ 00004\n"
"    THEN\n"
"    false iv=> iv-cg-drawn\n"
";M\n"
"\n"
":M ?HIT: ( x y -- true_if_hit )\n"
"    iv-cg-topy dup iv-cg-height + 1- within?\n"
"    IF iv-cg-leftx dup iv-cg-width + 1- within?\n"
"    ELSE drop false\n"
"    THEN\n"
";M\n"
"\n"
":M EXECUTE: ( cfa | 0 -- , execute DOWN/MOVE/UP function )\n"
"    ?dup\n"
"    IF  >r\n"
"        iv-cg-lasthit dup self get.value: []\n"
"        swap\n"
"        r> -2 exec.stack? \\ 00004\n"
"    THEN\n"
";M\n"
"\n"
"\\ Stubs to be defined in later classes\n"
":M EXEC.DOWN:  ( -- , do down functions )\n"
";M\n"
"\n"
":M MOUSE.DOWN: (  x y -- trapped? , process mouse DOWN event )\n"
"    2dup self ?hit: []\n"
"    IF  cg-first-my !   cg-first-mx !\n"
"        iv-cg-lasthit self get.enable: []\n"
"        IF  self exec.down: [] true\n"
"            iv-cg-down-cfa self execute: []\n"
"        ELSE bell false  ( beep if disabled )\n"
"        THEN\n"
"    ELSE 2drop false\n"
"    THEN\n"
";M\n"
"\n"
":M MOUSE.UP:  ( x y -- , do up functions )\n"
"    cg-last-my !   cg-last-mx !\n"
"    iv-cg-up-cfa self execute: []\n"
";M\n"
"\n"
":M MOUSE.MOVE:  ( x y -- , do move functions )\n"
"    cg-last-my !   cg-last-mx !\n"
"    iv-cg-move-cfa self execute: []\n"
";M\n"
"\n"
":M KEY: ( character -- , process keyboard input 00001 )\n"
"    drop\n"
";M\n"
"\n"
": PRINT.XYWH ( x y w h -- )\n"
"    .\"   Top Left X,Y = \" 2swap swap . . cr\n"
"    .\"   Width, Height    = \" swap . . cr\n"
";\n"
"\n"
":M PRINT: ( -- )\n"
"    cr\n"
"    .\" Device Coordinates!\" cr\n"
"    get.xy.dc: self\n"
"    get.wh.dc: self print.xywh\n"
"    .\" World Coordinates!\" cr\n"
"    get.xy: self\n"
"    get.wh: self print.xywh\n"
"    .\" User Data = \" iv-cg-data . cr\n"
"    .\" Title   = \" iv-cg-title dup\n"
"    IF $.\n"
"    ELSE .\n"
"    THEN cr\n"
"    .\" Part#  Value     Min     Max\" cr\n"
"    self many: [] 0\n"
"    ?DO  i 4 .r i self get.value: []  8 .r\n"
"        i self get.min: [] 8 .r\n"
"        i self get.max: [] 8 .r cr\n"
"    LOOP\n"
"    .\" Draw.Function   = \" iv-cg-draw-cfa cfa. cr\n"
"    .\" Undraw.Function = \" iv-cg-undraw-cfa cfa. cr\n"
"    .\" Text.Function   = \" iv-cg-text-cfa cfa. cr\n"
"    .\" Down.Function   = \" iv-cg-down-cfa cfa. cr\n"
"    .\" Move.Function   = \" iv-cg-move-cfa cfa. cr\n"
"    .\" Up.Function     = \" iv-cg-up-cfa cfa. cr\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"METHOD PUT.TEXT:      METHOD GET.TEXT:\n"
"METHOD }STUFF.TEXT:\n"
"METHOD COLOR.PART:\n"
"METHOD CLEAR.PART:\n"
"\n"
":CLASS OB.CONTROL.GRID <SUPER OB.CONTROL\n"
"    OB.ARRAY IV-CG-VALUES\n"
"    OB.BARRAY IV-CG-FLAGS\n"
"\\ Layout of parts\n"
"    IV.SHORT IV-CG-NUMX\n"
"    IV.SHORT IV-CG-NUMY\n"
"\n"
": CG.PUT.ENABLE ( flag part# -- )\n"
"    dup>r at: iv-cg-flags swap\n"
"    IF cg_enable_mask OR\n"
"    ELSE cg_enable_mask invert and\n"
"    THEN r> to: iv-cg-flags\n"
";\n"
"\n"
":M PUT.ENABLE: ( flag part# -- , enable or disable cell )\n"
"    dup 0<\n"
"    IF\n"
"\\ do them all if part# is less then zero, 00003\n"
"        drop\n"
"        many: iv-cg-flags 0\n"
"        ?DO\n"
"            dup i cg.put.enable\n"
"        LOOP\n"
"        drop\n"
"    ELSE\n"
"        cg.put.enable\n"
"    THEN\n"
";M\n"
":M GET.ENABLE:  ( part# -- flag , Check for enable bit )\n"
"      at: iv-cg-flags cg_enable_mask and\n"
";M\n"
"\n"
":M FREE: ( -- , free allocated memory )\n"
"    free: iv-cg-values\n"
"    free: iv-cg-flags\n"
";M\n"
"\n"
":M NEW:  ( nx ny -- , Specify number of cells )\n"
"    self free: []\n"
"    2dup iv=> iv-cg-numy iv=> iv-cg-numx\n"
"    * dup new: iv-cg-values\n"
"    0 cg.clip.value fill: iv-cg-values\n"
"    new: iv-cg-flags\n"
"    cg_enable_mask fill: iv-cg-flags  ( set all enabled as default )\n"
";M\n"
"\n"
":M MANY:  ( -- n , number of values )\n"
"    size: iv-cg-values\n"
";M\n"
"\n"
": CG.PART.TOPLEFT  ( index -- x y )\n"
"     iv-cg-numx  /mod iv-cg-height  * iv-cg-topy  +\n"
"     swap iv-cg-width  * iv-cg-leftx  + swap\n"
";\n"
"\n"
":M GET.RECT:  ( index -- x1 y1 x2 y2 , in DC )\n"
"    dup 0<\n"
"    IF  drop iv-cg-leftx iv-cg-topy\n"
"        over iv-cg-width iv-cg-numx * +\n"
"        over iv-cg-height iv-cg-numy * +\n"
"    ELSE\n"
"        cg.part.topleft\n"
"        2dup iv-cg-height  +\n"
"        swap iv-cg-width  + swap\n"
"        cg-3d @   \\ inset bottom left corner to avoid overlap\n"
"        IF\n"
"            1- >r 1- r>\n"
"\\           cg-bevel-thickness @ - >r \n"
"\\           cg-bevel-thickness @ - r>\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
": INSET.RECTANGLE  ( x1 y1 x2 y2 -- x1+1 y1+1 x2-1 y2-1 )\n"
"    1- >r 1- >r 1+ >r 1+ r> r> r>   ( move in one pixel)\n"
";\n"
"\n"
":M COLOR.PART:   ( part color -- , color that parts rectangle )\n"
"    gr.color@ >r\n"
"    gr.color!\n"
"    get.inner.rect: self\n"
"    gr.rect ( paint background )\n"
"    r> gr.color!\n"
";M\n"
"\n"
":M CLEAR.PART:   ( part -- , clear that parts rectangle )\n"
"    0 color.part: self\n"
";M\n"
"\n"
":M ?HIT:   ( x y -- true_if_hit , report if hit , DC)\n"
"      iv-cg-topy  iv-cg-height  iv-cg-numy  ug.?hit\n"
"      IF  swap  ( -- ypart x )\n"
"          iv-cg-leftx  iv-cg-width  iv-cg-numx  ug.?hit\n"
"          IF  swap iv-cg-numx  * +\n"
"              iv=> iv-cg-lasthit true\n"
"          ELSE drop false\n"
"          THEN\n"
"      ELSE drop 0\n"
"      THEN\n"
";M\n"
"\n"
"GR_XOR_SUPPORTED [IF]\n"
":M HIGHLIGHT:   ( part -- , Highlight cell )\n"
"    iv-cg-drawn\n"
"    IF  gr.color@ swap get.inner.rect: self\n"
"        gr.highlight\n"
"        gr.color!\n"
"    ELSE drop\n"
"    THEN\n"
";M\n"
"[THEN]\n"
"\n"
":M PUT.VALUE: ( value part -- )\n"
"     >r cg.clip.value r> to: iv-cg-values\n"
";M\n"
":M GET.VALUE:  ( part -- value )\n"
"     at: iv-cg-values\n"
";M\n"
"\n"
": CG.DRAW.PART.BEVEL { part down? -- }\n"
"     part self get.rect: []\n"
"     down?\n"
"     2 draw.thick.bevel\n"
";\n"
"\n"
":M DRAW:   ( -- , Draw control grid )\n"
"    draw: super\n"
"    0 gr.color!\n"
"    -1 get.rect: self gr.rect\n"
"    service.tasks\n"
"    1 gr.color!\n"
"    service.tasks\n"
"    cg-3d @ 0=\n"
"    IF\n"
"        get.xy.dc: self\n"
"        get.wh.dc: self\n"
"        iv-cg-numx iv-cg-numy ug.grid  ( draw grid )\n"
"    THEN\n"
"    service.tasks\n"
"\\\n"
"\\ Draw each part\n"
"    size: iv-cg-values ?dup\n"
"    IF  0\n"
"        DO\n"
"\\\n"
"\\ draw 3d bevel if desired\n"
"            cg-3d @\n"
"            IF\n"
"                i 0 cg.draw.part.bevel\n"
"            THEN\n"
"\\\n"
"            i self draw.part: []\n"
"            service.tasks\n"
"        LOOP\n"
"    ELSE\n"
"        cg-3d @\n"
"        IF\n"
"            0 0 cg.draw.part.bevel\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M PRINT:\n"
"    print: super\n"
"    space space iv-cg-numy . .\"  rows and \"\n"
"        iv-cg-numx . .\"  columns.\" cr\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\\ CHECK GRIDCONTROL ----------------------------------------------\n"
"\n"
":CLASS OB.CHECK.GRID <SUPER OB.CONTROL.GRID\n"
"    ob.array  iv-cg-texts\n"
"\n"
":M FREE:  ( -- )\n"
"    free: super\n"
"    free: iv-cg-texts\n"
";M\n"
"\n"
":M NEW: ( nx ny -- )\n"
"    2dup new: super\n"
"    * new: iv-cg-texts\n"
"    &zero fill: iv-cg-texts\n"
";M\n"
"\n"
":M PRINT: ( -- )\n"
"    print: super\n"
"    size: iv-cg-texts 0\n"
"    ?DO i at: iv-cg-texts $type cr\n"
"    LOOP\n"
";M\n"
"\n"
": GR.START.DIM ( part# -- )\n"
"    drop 2 gr.color!\n"
";\n"
": GR.END.DIM ( part# -- )\n"
"    drop 1 gr.color!\n"
";\n"
"\n"
":M DRAW.PART: ( part -- , draw a single part of a control )\n"
"    >r\n"
"\n"
"\\ draw background based on the value\n"
"    r@ get.value: self\n"
"    IF r@ gr_yellow color.part: self\n"
"    ELSE r@ clear.part: self\n"
"    THEN\n"
"\n"
"\\ get text for this part\n"
"    iv-cg-text-cfa dup\n"
"    IF r@ swap 1 exec.stack?  ( addr count , 00004 )\n"
"    ELSE drop r@ at: iv-cg-texts ?dup\n"
"        IF cg.fixtext count\n"
"        ELSE 0 0\n"
"        THEN\n"
"    THEN service.tasks\n"
"\\\n"
"    dup  ( -- addr count count )\n"
"    IF\n"
"\\ dim the text if disabled\n"
"        r@ get.enable: self 0=\n"
"        IF r@ gr.start.dim\n"
"        THEN\n"
"\n"
"        service.tasks\n"
"        r@ cg.part.topleft\n"
"        iv-cg-text-size dup gr.height!\n"
"        + 1+ swap 6 + swap  ( calc bottom left )\n"
"        iv-cg-text-font gr.font!\n"
"        gr.move   gr.type\n"
"\\\n"
"        r@ get.enable: self 0=\n"
"        IF r@ gr.end.dim\n"
"        THEN\n"
"    ELSE 2drop\n"
"    THEN\n"
"\n"
"    rdrop\n"
";M\n"
"\n"
":M PUT.TEXT: ( string part# --  , text to appear in grid cell )\n"
"    tuck to: iv-cg-texts\n"
"    iv-cg-drawn\n"
"    IF dup self clear.part: []\n"
"       dup self draw.part: []\n"
"    THEN drop\n"
";M\n"
"\n"
":M GET.TEXT:  ( part# -- string , string may need cg.fixtext )\n"
"     at: iv-cg-texts\n"
";M\n"
"\n"
":M }STUFF.TEXT: ( stuff{ t0 t1 t2 ... -- , put many texts )\n"
"\\ Scan For 0 to count objects.\n"
"    stuff.depth\n"
"    dup 0>\n"
"    IF  dup 0\n"
"        DO 1- tuck ( t t tn-1 n tn n ) self put.text: []\n"
"        LOOP\n"
"        drop\n"
"    ELSE\n"
"        0< IF \" }STUFF.TEXT\" \" STUFF{ required before text!\"\n"
"              er_fatal ob.report.error\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
"GR_XOR_SUPPORTED [IF]\n"
":M PUT.VALUE:  ( value part# -- ,  toggle if changed )\n"
"    dup get.value: self ( -- newv part oldv )\n"
"    rot tuck ( -- part newv oldv newv )\n"
"    - ( toggle if different )\n"
"    IF   over highlight: self\n"
"    THEN\n"
"    swap put.value: super\n"
";M\n"
"[ELSE]\n"
":M PUT.VALUE:  ( value part# -- ,  toggle if changed )\n"
"    tuck put.value: super\n"
"    iv-cg-drawn\n"
"    IF draw.part: self\n"
"    ELSE drop\n"
"    THEN\n"
";M\n"
"[THEN]\n"
"\n"
":M EXEC.DOWN: ( -- , perform modal action then cfa )\n"
"    iv-cg-lasthit    get.value: self   ( -- v )\n"
"    0= iv-cg-lasthit put.value: self\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\\ CHECK BOX CONTROL ----------------------------------------------\n"
":CLASS OB.MENU.GRID <SUPER OB.CHECK.GRID\n"
"\n"
":M MOUSE.UP: ( x y -- , turn off now )\n"
"    iv-cg-lasthit    get.value: self   ( -- v )\n"
"    0= iv-cg-lasthit put.value: self\n"
"    mouse.up: super \\ 00008\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\\ RADIO GRID CONTROL ------------------------------------------------\n"
":CLASS OB.RADIO.GRID <SUPER OB.CHECK.GRID\n"
"\n"
":M NEW:  ( nx ny -- , set default on )\n"
"    new: super\n"
"    true iv-cg-lasthit\n"
"    size: iv-cg-values 1- min   to: iv-cg-values\n"
";M\n"
"\n"
":M PUT.VALUE:  ( value part# -- , turn others off )\n"
"    over\n"
"    IF  size: iv-cg-values 0\n"
"        ?DO 0 i put.value: super\n"
"        LOOP\n"
"    THEN\n"
"    put.value: super\n"
";M\n"
"\n"
":M EXEC.DOWN:    ( -- , turn off all others )\n"
"    true iv-cg-lasthit put.value: self\n"
";M\n"
"\n"
";CLASS\n";

const char* control_fth = (const char*) temp_binary_data_12;

//================== ctrl_count.fth ==================
static const unsigned char temp_binary_data_13[] =
"\\ Select object and counter control definitions\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 10/11/86 Add CUSTOM.EXEC: SUPER to CUSTOM.EXEC: to fix\n"
"\\      wierd highlighting.\n"
"\\ MOD: PLB 8/8/88 Convert to new system.\n"
"\\ MOD: PLB 1/23/90 Fixed and disabled CG.HIT.MIDDLE, don't zero.\n"
"\\ MOD: PLB 2/6/90 Moved out TEXT.FUNCTION:\n"
"\\ 00001 PLB 2/21/92 Added 3D insets.\n"
"\n"
"ANEW TASK-CTRL_COUNT\n"
"\n"
":CLASS OB.COUNTER <SUPER OB.CONTROL\n"
"\n"
":M INIT: ( -- )\n"
"    init: super\n"
"    0 iv=> iv-cg-min\n"
";M\n"
"\n"
": CG.DRAW.UPARROW ( -- )\n"
"    iv-cg-leftx 1+ iv-cg-topy iv-cg-height 4/ + 2dup gr.move\n"
"    iv-cg-leftx iv-cg-width 2/ + iv-cg-topy 1+ gr.draw\n"
"    iv-cg-leftx 1- iv-cg-width +\n"
"        iv-cg-topy iv-cg-height 4/ + gr.draw gr.draw\n"
";\n"
"\n"
": CG.DRAW.DOWNARROW ( -- )\n"
"    iv-cg-leftx 1+ iv-cg-topy iv-cg-height 2/ dup 2/ + +\n"
"    2dup gr.move\n"
"    iv-cg-leftx iv-cg-width 2/ + iv-cg-topy iv-cg-height + 1- gr.draw\n"
"    iv-cg-leftx 1- iv-cg-width +\n"
"        iv-cg-topy iv-cg-height 2/ dup 2/ + + gr.draw gr.draw\n"
";\n"
"\n"
": CG.DRAW.BOX  ( -- , clear and draw box around control )\n"
"    0 gr.color!\n"
"    -1 get.rect: self gr.rect\n"
"    1 gr.color!\n"
"    cg-3d @\n"
"    IF\n"
"        -1 0 cg.draw.part.bevel\n"
"    ELSE\n"
"        -1 get.rect: self ug.box\n"
"    THEN\n"
";\n"
"\n"
": CG.DRAW.ARROWS\n"
"    cg.draw.box\n"
"    cg.draw.uparrow\n"
"    cg.draw.downarrow\n"
"\\\n"
"\\ position for text\n"
"    iv-cg-leftx 2+\n"
"        iv-cg-topy iv-cg-height 2/ dup 2/ + 4- + ( x y ) gr.move\n"
";\n"
"\n"
": CG.DRAW.VALUE  ( -- )\n"
"    cg.draw.arrows\n"
"    0 get.value: self\n"
"    iv-cg-text-cfa ?dup\n"
"    IF execute\n"
"    ELSE n>text\n"
"    THEN\n"
"    dup 256 u>\n"
"    IF\n"
"        \" CG.DRAW.VALUE\" \" Text too long\"\n"
"        er_return ob.report.error\n"
"        2drop\n"
"    ELSE gr.type\n"
"    THEN\n"
";\n"
"\n"
":M DRAW: ( -- , Draw value )\n"
"    draw: super\n"
"    cg.draw.value\n"
";M\n"
"\n"
":M ?HIT: ( x y -- true_if_hit )\n"
"    swap iv-cg-leftx dup iv-cg-width + 1- within?\n"
"    IF iv-cg-topy  iv-cg-height 4/  4  ug.?hit\n"
"       IF iv=> iv-cg-lasthit true\n"
"       ELSE false\n"
"       THEN\n"
"    ELSE drop false\n"
"    THEN\n"
";M\n"
"\n"
": CG.HIT.MIDDLE  ( -- , zero if numeric )\n"
"    iv-cg-text-cfa 0=\n"
"    IF 0 0 self put.value: []\n"
"    THEN\n"
";\n"
"\n"
":M EXEC.DOWN: ( -- , change number as needed )\n"
"    iv-cg-lasthit\n"
"    CASE\n"
"       0 OF iv-cg-value iv-cg-incr + dup iv-cg-max >\n"
"              IF drop iv-cg-min\n"
"              THEN   0 put.value: self ENDOF\n"
"       1 OF ( cg.hit.middle ) ENDOF\n"
"       2 OF ( cg.hit.middle ) ENDOF\n"
"       3 OF iv-cg-value iv-cg-incr - dup iv-cg-min <\n"
"              IF drop iv-cg-max\n"
"              THEN   0 put.value: self ENDOF\n"
"    ENDCASE\n"
"    cg.draw.value\n"
";M\n"
"\n"
";CLASS\n";

const char* ctrl_count_fth = (const char*) temp_binary_data_13;

//================== ctrl_fader.fth ==================
static const unsigned char temp_binary_data_14[] =
"\\ Fader control class.\n"
"\\ Useful for on screen mixers or other continuous controllers.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright Phil Burk 1989\n"
"\\\n"
"\\ MOD: PLB 6/14/90  Moved Fader numeric display down 2 pixels\n"
"\\ MOD: PLB 1/28/91  Shrank Fader range for better updating,\n"
"\\           PUT.VALUE: now updates display if drawn.\n"
"\\ MOD: PLB 6/5/91 Fixed knob updating, with Darren Gibbs\n"
"\n"
"ANEW TASK-CTRL_FADER\n"
"\n"
"METHOD PUT.KNOB.SIZE:\n"
"METHOD GET.KNOB.SIZE:\n"
"METHOD IF.SHOW.VALUE:\n"
"\n"
":CLASS OB.FADER <SUPER OB.CONTROL\n"
"    iv.short IV-CG-YOFF\n"
"    iv.short IV-CG-KNOB-SIZE\n"
"    iv.short IV-CG-KNOB-Y\n"
"    iv.short IV-CG-SHOWV?\n"
"\n"
":M INIT:\n"
"    init: super\n"
"    10 iv=> iv-cg-knob-size\n"
"    true iv=> iv-cg-showv?\n"
";M\n"
"\n"
":M PUT.KNOB.SIZE: ( size -- , set in world coordinates )\n"
"    0 swap scg.delta.wc->dc 1 max\n"
"    iv=> iv-cg-knob-size drop\n"
";M\n"
"\n"
":M GET.KNOB.SIZE: ( -- size )\n"
"    iv-cg-knob-size\n"
"    0 swap scg.delta.dc->wc\n"
";M\n"
"\n"
":M IF.SHOW.VALUE:  ( flag -- )\n"
"    iv=> iv-cg-showv?\n"
";M\n"
"\n"
": CG.FADER.VAL>Y   ( value -- y , y for top of knob )\n"
"    iv-cg-min -\n"
"    iv-cg-height iv-cg-knob-size - 2-\n"
"    iv-cg-max iv-cg-min - 1 max */\n"
"    iv-cg-topy iv-cg-height + iv-cg-knob-size - 1- swap -\n"
";\n"
"\n"
": CG.FADER.Y>VAL   ( y -- val )\n"
"    iv-cg-topy iv-cg-height + iv-cg-knob-size - 1- swap -\n"
"    iv-cg-max iv-cg-min -\n"
"    iv-cg-height iv-cg-knob-size - 2- 1 max */\n"
"    iv-cg-min + cg.clip.value\n"
";\n"
"\n"
": CG.KNOB.AT.Y  ( y -- , draws the knob at Y )\n"
"    dup iv=> iv-cg-knob-y\n"
"    iv-cg-leftx 2+ swap\n"
"    iv-cg-leftx iv-cg-width + 2- over iv-cg-knob-size +\n"
"    gr.rect\n"
";\n"
"\n"
": CG.FADER.KNOB  ( -- , draw knob of fader )\n"
"    iv-cg-value cg.fader.val>y ( y position of knob )\n"
"    cg.knob.at.y\n"
";\n"
"\n"
": CG.FADER.VALUE ( -- , display value of fader )\n"
"    iv-cg-showv?\n"
"    IF  iv-cg-topy iv-cg-height + 14 +\n"
"        iv-cg-leftx iv-cg-width 2/ +  ( middle )\n"
"        iv-cg-value n>text gr.textlen 2/ -\n"
"        swap gr.move iv-cg-value gr.number\n"
"    THEN\n"
";\n"
"\n"
":M DRAW: ( -- )\n"
"    draw: super\n"
"    cg.draw.box\n"
"    cg.fader.knob\n"
"    cg.fader.value\n"
";M\n"
"\n"
":M PUT.VALUE: ( value part -- , set value , update display )\n"
"    ?drawn: self\n"
"    IF  0 gr.color!\n"
"        iv-cg-knob-y cg.knob.at.y\n"
"        cg.fader.value\n"
"    THEN\n"
"\\\n"
"    put.value: super\n"
"\\\n"
"    ?drawn: self\n"
"    IF  1 gr.color!\n"
"        cg.fader.knob\n"
"        cg.fader.value\n"
"    THEN\n"
";M\n"
"\n"
":M ?HIT:  ( mx my -- true_if_hit )\n"
"    swap iv-cg-leftx dup iv-cg-width + 1- within?\n"
"    IF dup iv-cg-topy dup iv-cg-height + 1- within?\n"
"       IF  ( -- y )\n"
"           0 get.value: self cg.fader.val>y 2dup <\n"
"           IF 2drop 0 \\ above knob\n"
"           ELSE dup iv-cg-knob-size + within?\n"
"               IF 1 \\ on knob\n"
"               ELSE 2 \\ below knob\n"
"               THEN\n"
"           THEN  iv=> iv-cg-lasthit true\n"
"       ELSE drop false\n"
"       THEN\n"
"    ELSE drop false\n"
"    THEN\n"
";M\n"
"\n"
":M EXEC.DOWN: ( -- )\n"
"    iv-cg-lasthit\n"
"    CASE\n"
"    1 OF  ev.track.on\n"
"          cg-first-my @ iv-cg-value cg.fader.val>y -\n"
"          iv=> iv-cg-yoff\n"
"      ENDOF\n"
"    0 OF iv-cg-value get.increment: self +\n"
"         0 self put.value: []\n"
"      ENDOF\n"
"    2 OF iv-cg-value get.increment: self -\n"
"         0 self put.value: []\n"
"      ENDOF\n"
"    ENDCASE\n"
";M\n"
"\n"
":M MOUSE.MOVE: ( x y -- )\n"
"    nip    3 gr.color!\n"
"    iv-cg-yoff - cg.fader.y>val\n"
"    0 get.value: self over =\n"
"    IF drop\n"
"    ELSE 0 self put.value: []\n"
"        iv-cg-move-cfa self execute: []\n"
"    THEN\n"
";M\n"
"\n"
":M MOUSE.UP:  ( x y )\n"
"    mouse.up: super\n"
"    iv-cg-lasthit 1 =\n"
"    IF  ev.track.off\n"
"    THEN\n"
"    self draw: []\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"    \n";

const char* ctrl_fader_fth = (const char*) temp_binary_data_14;

//================== ctrl_numeric.fth ==================
static const unsigned char temp_binary_data_15[] =
"\\ Numeric Grid - numbers on grid, click on one, move up or down\n"
"\\ to change number.\n"
"\\ Move to the right for coarse control,\n"
"\\  to the left for fine control.\n"
"\\\n"
"\\ Copyright 1989 Phil Burk\n"
"\\\n"
"\\ MOD: PLB 2/10/91 Use GR.START.DIM\n"
"\\ MOD: PLB 6/3/91 c/gr.height@/iv-cg-text-size/\n"
"\\ MOD: PLB 6/24/91 set default max to 127\n"
"\\ 00001 PLB 2/21/92 Inset further if 3D\n"
"\n"
"\n"
"ANEW TASK-CTRL_NUMERIC\n"
"\n"
"variable CG-PREV-MX\n"
"variable CG-PREV-MY\n"
"variable CG-PREV-TIME\n"
"variable CG-DELTA-MODE\n"
"0 constant CG_POS_MODE\n"
"1 constant CG_SPEED_MODE\n"
"\n"
":CLASS OB.NUMERIC.GRID <SUPER OB.CHECK.GRID\n"
"    ob.elmnts iv-cg-limits  ( dim 0 = min, dim 1 = max )\n"
"\n"
":M PUT.MIN: ( value part -- , set min )\n"
"    dup 0<\n"
"    IF  swap  many: iv-cg-limits 0\n"
"        ?DO dup i 0 ed.to: iv-cg-limits  ( set each one )\n"
"        LOOP\n"
"        swap put.min: super\n"
"    ELSE dup>r 0 ed.to: iv-cg-limits r> cg.clip.part\n"
"    THEN\n"
";M\n"
"\n"
":M GET.MIN: ( part -- value , get min )\n"
"    dup 0<\n"
"    IF get.min: super\n"
"    ELSE 0 ed.at: iv-cg-limits\n"
"    THEN\n"
";M\n"
"\n"
":M PUT.MAX: ( value part -- , set max )\n"
"    dup 0<\n"
"    IF  swap  many: iv-cg-limits 0\n"
"        ?DO dup i 1 ed.to: iv-cg-limits  ( set each one )\n"
"        LOOP\n"
"        swap put.max: super\n"
"    ELSE dup>r 1 ed.to: iv-cg-limits r> cg.clip.part\n"
"    THEN\n"
";M\n"
":M GET.MAX: ( part -- value , get max )\n"
"    dup 0<\n"
"    IF get.min: super\n"
"    ELSE 1 ed.at: iv-cg-limits\n"
"    THEN\n"
";M\n"
"\n"
":M INIT: ( -- )\n"
"    init: super\n"
"    0 iv=> iv-cg-min\n"
"    127 iv=> iv-cg-max\n"
";M\n"
"\n"
": NCG.CLIP.VALUE ( value part -- value' part )\n"
"    dup>r get.min: self\n"
"    r@ get.max: self clipto r>\n"
";\n"
"\n"
":M PUT.VALUE: ( value part -- )\n"
"    dup>r\n"
"    ncg.clip.value  to: iv-cg-values\n"
"\\ update drawing of self if needed\n"
"    ?drawn: self\n"
"    IF  r@ clear.part: self\n"
"        r@ self draw.part: []\n"
"    THEN\n"
"    rdrop\n"
";M\n"
"\n"
":M GET.VALUE:  ( part -- value )\n"
"     at: iv-cg-values\n"
";M\n"
"\n"
":M FREE:  ( -- )\n"
"    free: iv-cg-limits\n"
"    free: super\n"
";M\n"
"\n"
":M NEW: ( nx ny -- )\n"
"    2dup new: super\n"
"    * dup 2 new: iv-cg-limits\n"
"    set.many: iv-cg-limits\n"
"    -1 get.min: self -1 put.min: self  ( update parts )\n"
"    -1 get.max: self -1 put.max: self\n"
";M\n"
"\n"
":M DRAW.PART: ( part -- , draw a single part of a control )\n"
"    >r\n"
"\\\n"
"\\ Use smaller characters or color 2 if the cell is disabled.\n"
"    r@ get.enable: self 0=\n"
"    IF gr.start.dim\n"
"    THEN\n"
"    service.tasks\n"
"\\ Position in cell\n"
"    r@ cg.part.topleft\n"
"    iv-cg-text-size + 1+ swap ( -- y x )\n"
"    r@ get.value: self n>text gr.textlen - ( right justify )\n"
"\\\n"
"\\ move in farther if using 3D bevel, 00001\n"
"    cg-3d @\n"
"    IF\n"
"        cg-bevel-thickness @ -\n"
"    ELSE\n"
"        1-\n"
"    THEN\n"
"    iv-cg-width + swap gr.move\n"
"\\\n"
"\\ Draw number\n"
"    r@ get.value: self gr.number\n"
"    r@ get.enable: self 0=\n"
"    IF gr.end.dim\n"
"    THEN\n"
"    rdrop\n"
";M\n"
"\n"
": NG.DRAW.LABELS  ( -- , draw side labels )\n"
"    iv-cg-numy 0\n"
"    ?DO iv-cg-text-cfa\n"
"       IF i iv-cg-text-cfa 1 exec.stack?  ( -- addr c )\n"
"       ELSE i get.text: self count\n"
"       THEN\n"
"       ?dup\n"
"       IF\n"
"\\ right justify text\n"
"            2dup gr.textlen  ( -- a c xpixels )\n"
"            iv-cg-leftx 2- swap -  ( -- addr count x' )\n"
"            iv-cg-topy i 1+ iv-cg-height * + 4- gr.move\n"
"            gr.type\n"
"       ELSE drop\n"
"       THEN\n"
"    LOOP\n"
";\n"
"\n"
":M DRAW:  ( -- )\n"
"    draw: super\n"
"    ng.draw.labels\n"
";M\n"
"\n"
": CG.BELOW.MIDDLE? ( -- flag )\n"
"     iv-cg-lasthit iv-cg-numx  / iv-cg-height  * iv-cg-topy  +\n"
"     iv-cg-height 2/ +  ( y midline of part hit )\n"
"     cg-first-my @ <\n"
";\n"
"\n"
": CG.CHANGE.VALUE  ( delta -- , used to change value )\n"
"    iv-cg-lasthit get.value: self +\n"
"    iv-cg-lasthit put.value: self\n"
";\n"
"\n"
":M EXEC.DOWN: ( -- )\n"
"\\ Increment or decrement if above or below line\n"
"    get.increment: self    cg.below.middle?\n"
"    IF negate\n"
"    THEN   cg.change.value\n"
"\\\n"
"\\ Set up for tracking.\n"
"    ev.track.on\n"
"    cg-first-mx @ cg-prev-mx !\n"
"    cg-first-my @ cg-prev-my !\n"
"    \\ iv-cg-lasthit highlight: self\n"
";M\n"
"\n"
": CG.CALC.DELTA.POS  ( -- dv , delta based on x position)\n"
"    cg-prev-my @ cg-last-my @ -  ( dy , with up=positive)\n"
"    cg-last-mx @ cg-first-mx @ - ( -- dy xdist )\n"
"    iv-cg-width 2* + 0 max\n"
"    iv-cg-width 5 * min    ( active 2widths to either side )\n"
"\\ biggest = range/height/4\n"
"\\ dv = ( biggest + 5*width/height) * dy / 5*width\n"
"    iv-cg-lasthit get.max: self\n"
"    iv-cg-lasthit get.min: self - ( range )\n"
"    iv-cg-height 4* / 1 max   *\n"
"    iv-cg-width 5 * dup>r iv-cg-height / +\n"
"    * r> /\n"
"    dup\n"
"    IF  cg-last-mx @ cg-prev-mx !\n"
"        cg-last-my @ cg-prev-my !\n"
"    THEN\n"
";\n"
"\n"
": CG.CALC.DV  { dy dt height range -- dv }\n"
"    dy dup abs *\n"
"    5 ashift height /  ( scale by pixels per active area )\n"
"    dt / ( scaled by time )\n"
"    range 8 max *\n"
"    -12 ashift\n"
";\n"
"1 cg-delta-mode !\n"
"\n"
": CG.CALC.DELTA.SPEED  ( -- dv , delta based on speed)\n"
"    cg-prev-my @ cg-last-my @ -  ( dy , with up=positive)\n"
"    time@ cg-prev-time @ over cg-prev-time ! - ( dt )\n"
"    6 ashift rtc.rate@ /  ( normalize to 64 ticks/second )\n"
"    1 64 clipto\n"
"    iv-cg-height  ( height of active area )\n"
"    iv-cg-lasthit get.max: self\n"
"    iv-cg-lasthit get.min: self - ( range )\n"
"    ( -- dy dt height range ) cg.calc.dv\n"
"    dup\n"
"    IF  cg-last-mx @ cg-prev-mx !\n"
"        cg-last-my @ cg-prev-my !\n"
"    THEN\n"
";\n"
"\n"
": CG.CALC.DELTA  ( -- dv , use chosen mode )\n"
"    cg-delta-mode @\n"
"    CASE\n"
"        cg_pos_mode OF cg.calc.delta.pos ENDOF\n"
"        cg_speed_mode OF cg.calc.delta.speed ENDOF\n"
"        .\" Illegal CG-DELTA-MODE\" cr 0\n"
"    ENDCASE\n"
";\n"
"\n"
":M MOUSE.MOVE:   ( x y -- , process mouse MOVE event )\n"
"    cg-last-my !   cg-last-mx !\n"
"    cg.calc.delta ?dup\n"
"    IF  iv-cg-lasthit get.value: self >r\n"
"        cg.change.value\n"
"        iv-cg-lasthit get.value: self r> -\n"
"        IF iv-cg-move-cfa self execute: []  ( only call if value changes )\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M MOUSE.UP:  ( x y -- , process mouse UP event )\n"
"    ev.track.off\n"
"    iv-cg-lasthit clear.part: self\n"
"    iv-cg-lasthit draw.part: self\n"
"    mouse.up: super\n"
";M\n"
"\n"
";CLASS\n"
"\n";

const char* ctrl_numeric_fth = (const char*) temp_binary_data_15;

//================== ctrl_text.fth ==================
static const unsigned char temp_binary_data_16[] =
"\\ Text Input Control\n"
"\\ Define a grid of text input items.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1991 Phil Burk\n"
"\\\n"
"\\ 00001 PLB 2/6/92 Use EXEC.STACK?\n"
"\n"
"ANEW TASK-CTRL_TEXT\n"
"decimal\n"
"\n"
"\\ -----------------------------------------------\n"
": $INSERT.CHAR { char cursor $string -- }\n"
"\\\n"
"\\ check for string overflow\n"
"    $string c@ 255 = abort\" $INSERT.CHAR - string is full!\"\n"
"\\\n"
"\\ check for past end\n"
"    $string c@ cursor\n"
"    < abort\" $INSERT.CHAR - cursor past end of string!\"\n"
"\\\n"
"\\ move characters up\n"
"    $string c@ cursor >\n"
"    IF\n"
"        $string 1+ cursor + \\ source\n"
"        dup 1+ \\ dest\n"
"        $string c@ cursor - \\ many\n"
"        move\n"
"    THEN\n"
"\\\n"
"\\ put in character\n"
"    char $string 1+ cursor + c!\n"
"\\\n"
"\\ increment count\n"
"    $string c@ 1+ $string c!\n"
";\n"
"\n"
": $REMOVE.CHAR { cursor $string -- }\n"
"\\ check for past end\n"
"    $string c@ cursor\n"
"    < abort\" $REMOVE.CHAR - cursor past end of string!\"\n"
"\\\n"
"\\ move characters down\n"
"    cursor 0>\n"
"    IF\n"
"        $string 1+ cursor + \\ source\n"
"        dup 1- \\ dest\n"
"        $string c@ cursor - \\ many\n"
"        move\n"
"\\\n"
"\\ decrement count\n"
"        $string c@ 1- $string c!\n"
"    THEN\n"
";\n"
"\n"
": $CHOP.RANGE { start end $string -- }\n"
"\\ check for past end\n"
"    $string c@ start end max\n"
"    < abort\" $CHOP.RANGE - cursor past end of string!\"\n"
"\\\n"
"\\ move characters down\n"
"    end 0>\n"
"    IF\n"
"        $string 1+ end + \\ source\n"
"        $string 1+ start + \\ dest\n"
"        $string c@ end - \\ many\n"
"        move\n"
"\\\n"
"\\ decrement count\n"
"        $string c@ end start - - $string c!\n"
"    THEN\n"
";\n"
"\n"
"\\ -----------------------------------------------\n"
"\\ One Line Text Editing Control\n"
"\n"
"METHOD PUT.CR.FUNCTION:\n"
"METHOD GET.CR.FUNCTION:\n"
"METHOD PUT.FILTER.FUNCTION:\n"
"METHOD GET.FILTER.FUNCTION:\n"
"METHOD PUT.LEAVE.FUNCTION:\n"
"METHOD GET.LEAVE.FUNCTION:\n"
"METHOD PUT.JUSTIFY:\n"
"METHOD GET.JUSTIFY:\n"
"\n"
"0 value CG_TXED_START\n"
"0 value CG_TXED_END\n"
"0 value CG_TXED_ANCHOR\n"
"0 value CG_TXED_LAST\n"
"0 value CG_TXED_PART  \\ currently highlighted part\n"
"\n"
":CLASS OB.TEXT.GRID <SUPER OB.CONTROL.GRID\n"
"    iv.long  IV-CG-TEXT-CR-CFA\n"
"    iv.long  IV-CG-TEXT-FILTER-CFA\n"
"    iv.long  IV-CG-TEXT-LEAVE-CFA\n"
"    iv.short IV-CG-TEXT-MAX  \\ maximum number of characters in string\n"
"    iv.short IV-CG-TEXT-JUST  \\ 0,1,2 for left,center,right justify\n"
"    ob.barray IV-CG-TEXT-BUF  \\ contains N Forth strings\n"
"\n"
":M PUT.CR.FUNCTION: ( cfa -- )\n"
"    iv=> iv-cg-text-cr-cfa\n"
";M\n"
"\n"
":M GET.CR.FUNCTION: ( -- cfa )\n"
"    iv-cg-text-cr-cfa\n"
";M\n"
"\n"
":M PUT.FILTER.FUNCTION: ( cfa -- )\n"
"    iv=> iv-cg-text-filter-cfa\n"
";M\n"
"\n"
":M GET.FILTER.FUNCTION: ( -- cfa )\n"
"    iv-cg-text-filter-cfa\n"
";M\n"
"\n"
":M PUT.LEAVE.FUNCTION: ( cfa -- )\n"
"    iv=> iv-cg-text-leave-cfa\n"
";M\n"
"\n"
":M GET.LEAVE.FUNCTION: ( -- cfa )\n"
"    iv-cg-text-leave-cfa\n"
";M\n"
"\n"
"\n"
":M PUT.JUSTIFY: ( justification -- )\n"
"    iv=> iv-cg-text-just\n"
";M\n"
"\n"
":M GET.JUSTIFY: ( -- justification )\n"
"    iv-cg-text-just\n"
";M\n"
"\n"
":M GET.TEXT: ( part -- $text )\n"
"    iv-cg-text-max 1+ * data.addr: iv-cg-text-buf +\n"
";M\n"
"\n"
": CT.CUR.TEXT ( -- $text )\n"
"    cg_txed_part get.text: self\n"
";\n"
"\n"
":M PUT.TEXT: ( $text part -- )\n"
"    over c@ iv-cg-text-max >\n"
"    IF\n"
"        . $type .\" too long in PUT.TEXT: \" name: self cr\n"
"    ELSE\n"
"        0 -> cg_txed_start \\ highlight entire text\n"
"        over c@ -> cg_txed_end\n"
"        get.text: self $move\n"
"    THEN\n"
";M\n"
"\n"
":M GET.VALUE: ( part -- n )\n"
"    get.text: self number?\n"
"    IF\n"
"        drop\n"
"    ELSE\n"
"        .\" Invalid number in \" name: self cr\n"
"        0 \\ have to return something !\n"
"    THEN\n"
";M\n"
"\n"
":M PUT.VALUE: ( n part -- )\n"
"    get.text: self >r\n"
"    n>text ( addr count )\n"
"    dup r@ c!\n"
"    r> 1+ swap cmove\n"
";M\n"
"\n"
":M INIT:\n"
"    init: super\n"
"    0 iv=> iv-cg-text-max\n"
"    0 iv=> iv-cg-text-cr-cfa\n"
"    0 iv=> iv-cg-text-filter-cfa\n"
";M\n"
"\n"
":M NEW: ( numx numy numchars -- )\n"
"    >r 2dup .s new: super\n"
"    * r> dup iv=> iv-cg-text-max  \\ remember new: calls SELF FREE: []\n"
"    1+ * new: iv-cg-text-buf\n"
"    clear: iv-cg-text-buf\n"
";M\n"
"\n"
":M FREE:\n"
"    free: super\n"
"    free: iv-cg-text-buf\n"
"    0 iv=> iv-cg-text-max\n"
";M\n"
"\n"
"3 value CT_TEXT_DESCENT\n"
"\n"
": CT.PART>XY { part | x1 y1 x2 y2 -- x y }\n"
"    part get.rect: self -> y2 -> x2 -> y1 -> x1\n"
"    iv-cg-text-just\n"
"    CASE\n"
"        0 OF x1 2+ y2 ct_text_descent - ENDOF\n"
"        1 OF x2 x1 + 2/  \\ center\n"
"            part get.text: self count gr.textlen 2/ -\n"
"            y2 ct_text_descent -\n"
"        ENDOF\n"
"        2 OF x2 4 -\n"
"            part get.text: self count gr.textlen -\n"
"            y2 ct_text_descent -\n"
"        ENDOF\n"
"    ENDCASE\n"
";\n"
"\n"
": CT.BASE.XY ( -- x y )\n"
"    cg_txed_part ct.part>xy\n"
";\n"
"\n"
": CT.INDEX>XY  ( index -- x y )\n"
"    ct.cur.text 1+ swap gr.textlen\n"
"    ct.base.xy >r + r>\n"
";\n"
"\n"
": IN.RECT? { mx my x1 y1 x2 y2 -- in_rectangle? }\n"
"    mx x1 x2 within? dup\n"
"    IF\n"
"        drop\n"
"        my y1 y2 within?\n"
"    THEN\n"
";\n"
"\n"
": CT.XY>INDEX { mx my | indx x1 y1 x2 y2 -- indx true | false }\n"
"    cg_txed_part get.rect: self -> y2 -> x2 -> y1 -> x1\n"
"    my y1 y2 within?\n"
"    IF\n"
"        mx ct.base.xy drop - -> mx  \\ offset from first char\n"
"\\ scan all characters in case we have a proportional font\n"
"        ct.cur.text c@   dup -> indx   0\n"
"        ?DO\n"
"            ct.cur.text 1+ i 1+ gr.textlen\n"
"            mx >\n"
"            IF\n"
"            i -> indx\n"
"                LEAVE\n"
"            THEN\n"
"        LOOP\n"
"        indx true\n"
"    ELSE\n"
"        FALSE\n"
"    THEN\n"
";\n"
"\n"
": CT.HIGHLIGHT ( -- , highlight selected region )\n"
"    gr.mode@\n"
"    gr.color@\n"
"    cg_txed_start ct.index>xy gr.height@ -\n"
"    cg_txed_end ct.index>xy ( -- x1 y1 x2 y2 )\n"
"\\\n"
"\\ force minimum width of 3 pixels\n"
"    >r 2 pick 3 + max r>\n"
"\\\n"
"\\ draw in XOR mode\n"
"    gr_xor_mode gr.mode!\n"
"    gr_white gr.color!\n"
"    gr.rect\n"
"    \n"
"    gr.color!\n"
"    gr.mode!\n"
";\n"
"\n"
":M DRAW.PART: ( part -- )\n"
"    dup clear.part: self\n"
"    dup ct.part>xy gr.move\n"
"    dup get.text: self  gr.text\n"
"    iv-cg-active\n"
"    IF\n"
"        dup cg_txed_part =\n"
"        IF ct.highlight\n"
"        THEN\n"
"    THEN\n"
"    drop\n"
";M\n"
"\n"
": CT.CHOP ( -- , chop selected range )\n"
"    cg_txed_start cg_txed_end\n"
"    2dup -\n"
"    IF\n"
"        ct.cur.text $chop.range\n"
"        cg_txed_start -> cg_txed_end\n"
"    ELSE\n"
"        2drop\n"
"    THEN\n"
";\n"
"\n"
": CT.DELETE ( -- , delete char in front of cursor )\n"
"    cg_txed_start cg_txed_end\n"
"    2dup -\n"
"    IF\n"
"        ct.cur.text $chop.range\n"
"    ELSE\n"
"        \\ no text range selected\n"
"        drop 1+ dup ct.cur.text c@ <=  \\ before end?\n"
"        IF\n"
"            ct.cur.text  $remove.char\n"
"        ELSE drop\n"
"        THEN\n"
"    THEN\n"
"    cg_txed_start -> cg_txed_end\n"
";\n"
"\n"
": CT.BACKSPACE ( -- )\n"
"    cg_txed_start cg_txed_end\n"
"    2dup -\n"
"    IF\n"
"        ct.cur.text $chop.range\n"
"        cg_txed_start -> cg_txed_end\n"
"    ELSE\n"
"        \\ no text range selected\n"
"        drop\n"
"        ct.cur.text  $remove.char\n"
"        cg_txed_start 1- 0 max\n"
"        dup -> cg_txed_start -> cg_txed_end\n"
"    THEN\n"
";\n"
"\n"
": CT.INSERT { char | xl xr x1 x2 -- }\n"
"    ct.chop\n"
"    ct.cur.text c@ iv-cg-text-max <\n"
"    IF \n"
"        char cg_txed_start ct.cur.text  $insert.char\n"
"        cg_txed_start 1+\n"
"        dup -> cg_txed_start -> cg_txed_end\n"
"\\\n"
"\\ check for past end of box\n"
"        ct.base.xy drop -> xl \\ start of text\n"
"        xl ct.cur.text count gr.textlen + -> xr \\ end of text\n"
"        cg_txed_part get.rect: self drop -> x2 drop -> x1\n"
"        xL x1 x2 within? not  \\ left edge outside box ?\n"
"        xR x1 x2 within? not OR \\ right edge outside box ?\n"
"        IF\n"
"            ct.backspace beep\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
": CT.LEFT ( -- , move cursor one to left )\n"
"    cg_txed_start 1- 0 max -> cg_txed_start\n"
"    cg_txed_start -> cg_txed_end\n"
";\n"
": CT.RIGHT ( -- , move cursor one to right )\n"
"    cg_txed_start 1+ ct.cur.text c@ min -> cg_txed_start\n"
"    cg_txed_start -> cg_txed_end\n"
";\n"
"\n"
": CT.SHIFT.LEFT ( -- , move cursor fully to left )\n"
"    0 dup -> cg_txed_start\n"
"    -> cg_txed_end\n"
";\n"
": CT.SHIFT.RIGHT ( -- , move cursor fully to right )\n"
"    ct.cur.text c@ dup -> cg_txed_start\n"
"    -> cg_txed_end\n"
";\n"
"\n"
"$ 7F constant DELETE_CHAR\n"
"\n"
": CT.DO.KEY { character | redraw? -- , do editing based on char }\n"
"    true -> redraw?\n"
"    ct.highlight\n"
"    character\n"
"    CASE\n"
"\\\n"
"        character isprint\n"
"        ?OF character ct.insert\n"
"        ENDOF\n"
"\\\n"
"        8\n"
"        OF ct.backspace\n"
"        ENDOF\n"
"\\\n"
"        delete_char\n"
"        OF ct.delete\n"
"        ENDOF\n"
"\\\n"
"        left_arrow OF ct.left ENDOF\n"
"        right_arrow OF ct.right ENDOF\n"
"        shift_left_arrow OF ct.shift.left ENDOF\n"
"        shift_right_arrow OF ct.shift.right ENDOF\n"
"\\\n"
"        $ 0D \\ carriage return\n"
"        OF \n"
"            iv-cg-text-cr-cfa ?dup\n"
"            IF  >r ct.cur.text cg_txed_part r>\n"
"                -2 exec.stack?\n"
"            THEN\n"
"            false -> redraw?\n"
"        ENDOF\n"
"    ENDCASE\n"
"    redraw?\n"
"    IF\n"
"        cg_txed_part draw.part: self\n"
"    THEN\n"
";\n"
"\n"
":M KEY: ( character -- )\n"
"\\ decide whether this is an OK character\n"
"    iv-cg-text-filter-cfa ?dup\n"
"    IF >r dup r> 0 exec.stack?\n"
"    ELSE true\n"
"    THEN  ( char ok? )\n"
"\\\n"
"    IF\n"
"        ct.do.key\n"
"    ELSE\n"
"        drop beep\n"
"    THEN\n"
";M\n"
"\n"
": CT.DO.LEAVE ( n -- , execute LEAVE function )\n"
"    iv-cg-text-leave-cfa ?dup\n"
"    IF  >r dup get.text: self  swap r>\n"
"        -2 exec.stack?\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": CT.UPDATE.STATUS ( -- update control variables )\n"
"    iv-cg-lasthit -> cg_txed_part\n"
"    cg-first-mx @ cg-first-my @ ct.xy>index not\n"
"    IF 0\n"
"    THEN\n"
"    dup -> cg_txed_end\n"
"    dup -> cg_txed_start\n"
"    dup -> cg_txed_anchor\n"
"    -> cg_txed_last\n"
";\n"
"\n"
":M PUT.ACTIVE: ( flag -- , make selected, handle highlighting )\n"
"    depth 1- >r\n"
"\\ turn off current highlighting if any\n"
"    iv-cg-drawn iv-cg-active and\n"
"    IF\n"
"        ct.highlight\n"
"        cg_txed_part ct.do.leave\n"
"    THEN\n"
"\\\n"
"    dup put.active: super\n"
"\\\n"
"\\ change select and highlighting info\n"
"    IF\n"
"        ct.update.status\n"
"\\\n"
"\\ highlight if now active\n"
"        iv-cg-drawn\n"
"        IF\n"
"            ct.highlight\n"
"        THEN\n"
"\\\n"
"\\ no part currently active\n"
"    ELSE\n"
"        -1 -> cg_txed_part\n"
"    THEN\n"
"    depth r> - abort\" MOUSE.DOWN: - stack change!\"\n"
";M\n"
"\n"
":M MOUSE.DOWN: ( x y -- trapped? )\n"
"    depth 1- >r\n"
"    mouse.down: super\n"
"\\\n"
"\\ If the same control is still active, but we have moved to\n"
"\\ a new part, then call LEAVE.FUNCTION\n"
"    dup\n"
"    IF\n"
"        iv-cg-active\n"
"        IF\n"
"            cg_txed_part iv-cg-lasthit = not\n"
"            IF\n"
"                cg_txed_part ct.do.leave\n"
"            THEN\n"
"\\\n"
"\\ we know we are active so change highlighting\n"
"            iv-cg-drawn\n"
"            IF\n"
"                ct.highlight\n"
"                ct.update.status\n"
"                ct.highlight\n"
"            THEN\n"
"        THEN\n"
"    THEN\n"
"\\\n"
"    ev.track.on\n"
"    depth r> - abort\" MOUSE.DOWN: - stack change!\"\n"
";M\n"
"\n"
":M MOUSE.MOVE:  ( x y -- )\n"
"    2dup mouse.move: super\n"
"    ct.xy>index\n"
"    IF\n"
"        dup cg_txed_last - \\ has the index changed, prevent flicker\n"
"        IF\n"
"            ct.highlight\n"
"            dup -> cg_txed_last \n"
"            cg_txed_anchor 2sort\n"
"            -> cg_txed_end -> cg_txed_start\n"
"            ct.highlight\n"
"        ELSE drop\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M MOUSE.UP:  ( x y -- )\n"
"    mouse.up: super\n"
"    ev.track.off\n"
";M\n"
"\n"
":M PRINT: ( -- )\n"
"    print: super\n"
"    many: self 0\n"
"    ?DO\n"
"        i . i get.text: self $type cr\n"
"    LOOP\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\n"
": CT.FILTER.NUMERIC  ( char -- ok? , filter characters for number )\n"
"    >r\n"
"    r@ isdigit\n"
"    r@ ascii . = OR\n"
"    r@ ascii , = OR\n"
"    r@ ascii - = cg_txed_start 0= AND OR\n"
"    r@ toupper ascii E = OR\n"
"    r@ isprint not OR\n"
"    rdrop\n"
";\n"
"\n"
": CT.FILTER.NOTE ( key -- ok? )\n"
"    >r\n"
"    r@ isprint not\n"
"    r@ tolower ascii a ascii g within? OR\n"
"    r@ tolower ascii # = OR\n"
"    r@ isdigit OR\n"
"    rdrop\n"
";\n"
"\n"
"\n"
"false [IF]\n"
"\n"
"OB.TEXT.GRID CT1\n"
"OB.TEXT.GRID CT2\n"
"OB.MENU.GRID RG1\n"
"OB.SCREEN SCR1\n"
"\n"
": SHOW.TEXT ( $text part -- )\n"
"    . .\" Text = \" $type cr\n"
";\n"
"\n"
": SHOW.VALUE ( $text part -- )\n"
"    . .\" Value = \" number?\n"
"    IF\n"
"        d.\n"
"    ELSE\n"
"        .\" Bad!\"\n"
"    THEN\n"
"    cr\n"
";\n"
"    \n"
": CT.INIT\n"
"    2 2 new: rg1\n"
"    200 200 put.wh: rg1\n"
"\\\n"
"    2 2 20 new: ct1\n"
"    600 300 put.wh: ct1\n"
"    'c show.text put.cr.function: ct1\n"
"\\\n"
"    1 4 20 new: ct2\n"
"    600 300 put.wh: ct2\n"
"    'c ct.filter.numeric put.filter.function: ct2\n"
"    'c show.value put.cr.function: ct2\n"
"    'c show.value put.leave.function: ct2\n"
"    \n"
"    4 3 new: scr1\n"
"    ct1 200 400 add: scr1\n"
"    ct2 2000 400 add: scr1\n"
"    rg1 200 3000 add: scr1\n"
"    \n"
"    scr1 default-screen !\n"
";\n"
"\n"
": CT.TERM\n"
"    freeall: scr1\n"
"    free: scr1\n"
";\n"
"\n"
"if.forgotten ct.term\n"
"\n"
": CT.TEST\n"
"    ct.init\n"
"    hmsl\n"
"    ct.term\n"
";\n"
"\n"
"[THEN]\n"
"\n";

const char* ctrl_text_fth = (const char*) temp_binary_data_16;

//================== ctrl_xy.fth ==================
static const unsigned char temp_binary_data_17[] =
"\\ XY Continuous Controller\n"
"\\\n"
"\\ This can be used like a continuous joystick for\n"
"\\ theremins, etc.  It can also be used for horizontal\n"
"\\ or vertical faders.\n"
"\\ The control is considered to have 2 parts, horizontal\n"
"\\ and vertical.  Each \"part\" has its own value, min, and max.\n"
"\\\n"
"\\ The UP, DOWN and MOVE functions are passed:\n"
"\\    ( x-value y-value -- )\n"
"\\ instead of\n"
"\\   ( value part# -- )\n"
"\\\n"
"\\ Use PUT.ENABLE: to disable horizontal or vertical motion\n"
"\\ to make this into a 1D fader.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright Phil Burk 1989\n"
"\n"
"ANEW TASK-CTRL_XY\n"
"\n"
"METHOD PUT.KNOB.SIZE:\n"
"METHOD GET.KNOB.SIZE:\n"
"\n"
"METHOD X>VALUE:   METHOD VALUE>X:\n"
"METHOD Y>VALUE:   METHOD VALUE>Y:\n"
"\n"
"3 value HIGHLIGHT_COLOR\n"
"\n"
"0 constant XY_HORIZONTAL_PART\n"
"1 constant XY_VERTICAL_PART\n"
"\n"
":CLASS OB.XY.CONTROLLER <SUPER OB.NUMERIC.GRID\n"
"    iv.short IV-CG-XY-XOFF          \\ offset within knob of click\n"
"    iv.short IV-CG-XY-YOFF\n"
"    iv.short IV-CG-XY-KNOB-XSIZE    \\ in device coordinates\n"
"    iv.short IV-CG-XY-KNOB-YSIZE\n"
"    iv.short IV-CG-XY-KNOB-X        \\ current X position\n"
"    iv.short IV-CG-XY-KNOB-Y        \\ current Y position\n"
"    iv.byte  IV-CG-XY-IN-KNOB?      \\ did mouse click in knob?\n"
"\n"
":M INIT:\n"
"    init: super\n"
"    10 iv=> iv-cg-xy-knob-xsize\n"
"    10 iv=> iv-cg-xy-knob-ysize\n"
";M\n"
"\n"
":M NEW: ( -- , allocate two parts )\n"
"    1 2 new: super ( allocate two parts )\n"
"    1 iv=> iv-cg-numx  ( just one vertical part, and one horizontal )\n"
"    1 iv=> iv-cg-numy\n"
";M\n"
"\n"
":M PUT.KNOB.SIZE: ( size part# -- , set in world coordinates )\n"
"\\ size = 0 means don't display any knob\n"
"\\ size < 0 means size in device coordinates\n"
"    over 0=\n"
"    IF drop iv=> iv-cg-xy-knob-xsize\n"
"       0 iv=> iv-cg-xy-knob-ysize\n"
"    ELSE  ( non-zero )\n"
"        over 0>  ( world coordinates ? )\n"
"        IF\n"
"            IF  0 swap scg.delta.wc->dc\n"
"               iv=> iv-cg-xy-knob-ysize drop\n"
"            ELSE 0 scg.delta.wc->dc\n"
"               drop iv=> iv-cg-xy-knob-xsize\n"
"            THEN\n"
"        ELSE\n"
"            IF  abs iv=> iv-cg-xy-knob-ysize\n"
"            ELSE abs iv=> iv-cg-xy-knob-xsize\n"
"            THEN\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M GET.KNOB.SIZE: ( part -- size )\n"
"    IF  iv-cg-xy-knob-ysize\n"
"        0 swap scg.delta.dc->wc nip\n"
"    ELSE iv-cg-xy-knob-xsize\n"
"        0 scg.delta.dc->wc drop\n"
"    THEN\n"
";M\n"
"\n"
": CG.XY.V>X  ( value -- x , of left edge of knob )\n"
"    xy_horizontal_part get.min: self -\n"
"    iv-cg-width iv-cg-xy-knob-xsize - 2-\n"
"\\\n"
"    xy_horizontal_part get.max: self\n"
"    xy_horizontal_part get.min: self - 1 max */\n"
"    iv-cg-leftx + 1+\n"
";\n"
"\n"
":M VALUE>X:  ( value -- x , x for center of knob )\n"
"    cg.xy.v>x  iv-cg-xy-knob-xsize 2/ +\n"
";M\n"
"\n"
": CG.XY.X>V ( x -- value , x = left of knob )\n"
"    1- iv-cg-leftx -\n"
"    xy_horizontal_part get.max: self\n"
"    xy_horizontal_part get.min: self -\n"
"    iv-cg-width iv-cg-xy-knob-xsize - 2- 1 max */\n"
"    xy_horizontal_part get.min: self +\n"
"    xy_horizontal_part get.min: self\n"
"    xy_horizontal_part get.max: self clipto\n"
";\n"
"\n"
":M X>VALUE:  ( x -- val , x at center of knob )\n"
"    iv-cg-xy-knob-xsize 2/ - cg.xy.x>v\n"
";M\n"
"\n"
": CG.XY.V>Y  ( value -- y , y for top of knob )\n"
"    xy_vertical_part get.min: self -\n"
"    iv-cg-height iv-cg-xy-knob-ysize - 2-\n"
"\\\n"
"    xy_vertical_part get.max: self\n"
"    xy_vertical_part get.min: self - 1 max */\n"
"    iv-cg-topy iv-cg-height + iv-cg-xy-knob-ysize - 1- swap - \n"
";\n"
":M VALUE>Y:  ( value -- y , y for center of knob )\n"
"    cg.xy.v>y iv-cg-xy-knob-ysize 2/ +\n"
";M\n"
"\n"
": CG.XY.Y>V  ( y -- value )\n"
"\\ Calculate pixels from edge\n"
"    iv-cg-topy iv-cg-height + iv-cg-xy-knob-ysize - 1- swap -\n"
"\\ Calculate range\n"
"    xy_vertical_part get.max: self xy_vertical_part get.min: self -\n"
"    iv-cg-height iv-cg-xy-knob-ysize - 2- 1 max */\n"
"    xy_vertical_part get.min: self +\n"
"    xy_vertical_part get.min: self xy_vertical_part get.max: self clipto\n"
";\n"
":M Y>VALUE:   ( y -- val , y at center )\n"
"    iv-cg-xy-knob-ysize 2/ - cg.xy.y>v \n"
";M\n"
"\n"
": CG.UNDRAW.KNOB ( -- , undraw from current position )\n"
"    iv-cg-xy-knob-xsize\n"
"    IF\n"
"        gr.color@\n"
"        0 gr.color!\n"
"        iv-cg-xy-knob-x\n"
"        iv-cg-xy-knob-y\n"
"        over iv-cg-xy-knob-xsize +\n"
"        over iv-cg-xy-knob-ysize +\n"
"        gr.rect\n"
"        gr.color!\n"
"    THEN\n"
";\n"
"\n"
": CG.DRAW.KNOB  ( -- , draw knob of xy controller )\n"
"    iv-cg-xy-knob-xsize\n"
"    IF\n"
"        xy_horizontal_part get.value: self cg.xy.v>x ( x position of knob )\n"
"        dup iv=> iv-cg-xy-knob-x\n"
"        xy_vertical_part get.value: self cg.xy.v>y ( y position of knob )\n"
"        dup iv=> iv-cg-xy-knob-y\n"
"        over iv-cg-xy-knob-xsize +\n"
"        over iv-cg-xy-knob-ysize +\n"
"        gr.rect\n"
"    THEN\n"
";\n"
"\n"
":M DRAW: ( -- )\n"
"    iv-cg-leftx iv-cg-topy\n"
"    over iv-cg-width + over iv-cg-height + ug.box\n"
"    iv-cg-draw-cfa ?execute\n"
"    cg.draw.knob\n"
"    1 gr.color!\n"
"    cg.draw.title\n"
"    ng.draw.labels\n"
";M\n"
"\n"
":M ?HIT:  { mx my -- true_if_hit }\n"
"    false iv=> iv-cg-xy-in-knob?\n"
"    my iv-cg-topy dup iv-cg-height + 1- within?\n"
"    IF mx iv-cg-leftx dup iv-cg-width + 1- within?\n"
"        ( -- true_if_hit )\n"
"        dup\n"
"        IF  \\ is it IN knob?\n"
"            mx\n"
"            iv-cg-xy-knob-x\n"
"            dup iv-cg-xy-knob-xsize + within?\n"
"            IF\n"
"                my\n"
"                iv-cg-xy-knob-y\n"
"                dup iv-cg-xy-knob-ysize + within?\n"
"                iv=> iv-cg-xy-in-knob?\n"
"            THEN\n"
"        THEN\n"
"    ELSE false\n"
"    THEN\n"
";M\n"
"\n"
": CG.UPDATE.KNOB ( -- )\n"
"    cg.undraw.knob\n"
"    cg.draw.knob\n"
";\n"
"\n"
": CG.XY.SETVALS  ( x y --  changed?)\n"
"    xy_vertical_part get.enable: self \\ is Y enabled\n"
"    IF\n"
"        iv-cg-xy-yoff - cg.xy.y>v\n"
"        xy_vertical_part get.value: self over =\n"
"        IF drop false\n"
"        ELSE xy_vertical_part put.value: self true\n"
"        THEN  ( -- ychanged? )\n"
"    ELSE\n"
"        drop false  ( -- x y-not-changed )\n"
"    THEN\n"
"\\\n"
"    swap\n"
"    xy_horizontal_part get.enable: self\n"
"    IF\n"
"        iv-cg-xy-xoff - cg.xy.x>v\n"
"        xy_horizontal_part get.value: self over =\n"
"        IF drop false\n"
"        ELSE xy_horizontal_part put.value: self true\n"
"        THEN  ( -- ychanged? xchanged? )\n"
"    ELSE\n"
"        drop false  ( -- x y-not-changed )\n"
"    THEN\n"
"\\\n"
"    OR  ( if either one changed )\n"
";\n"
"\n"
":M EXEC.DOWN: ( -- )\n"
"    cg-first-mx @ cg-first-my @\n"
"\\\n"
"\\ set offsets for knob\n"
"    iv-cg-xy-in-knob?\n"
"    IF ( -- x y , track knob )\n"
"        dup xy_vertical_part get.value: self cg.xy.v>y -\n"
"        iv=> iv-cg-xy-yoff\n"
"        over xy_horizontal_part get.value: self cg.xy.v>x -\n"
"        iv=> iv-cg-xy-xoff \n"
"    ELSE\n"
"        iv-cg-xy-knob-xsize 2/ iv=> iv-cg-xy-xoff\n"
"        iv-cg-xy-knob-ysize 2/ iv=> iv-cg-xy-yoff\n"
"    THEN\n"
"\\\n"
"\\ update values\n"
"    cg.xy.setvals\n"
"    IF    \n"
"       highlight_color gr.color!\n"
"       cg.update.knob\n"
"    THEN\n"
"    ev.track.on\n"
";M\n"
"\n"
":M MOUSE.DOWN: (  x y -- trapped? , process mouse DOWN event )\n"
"\\ execute even if disabled\n"
"    2dup self ?hit: []\n"
"    IF  cg-first-my !   cg-first-mx !\n"
"        self exec.down: [] true\n"
"        iv-cg-down-cfa self execute: []\n"
"    ELSE 2drop false\n"
"    THEN\n"
";M\n"
"\n"
":M EXECUTE: ( cfa | 0 -- , pass x & y values )\n"
"    ?dup\n"
"    IF\n"
"        >r xy_horizontal_part get.value: self\n"
"        xy_vertical_part get.value: self\n"
"        r> execute\n"
"    THEN\n"
";M\n"
"\n"
":M MOUSE.MOVE: ( x y -- )\n"
"    2dup cg-last-my !   cg-last-mx !\n"
"    cg.xy.setvals\n"
"    IF iv-cg-move-cfa self execute: []\n"
"       highlight_color gr.color!\n"
"       cg.update.knob\n"
"    THEN\n"
";M\n"
"\n"
":M MOUSE.UP:  ( x y -- )\n"
"    1 gr.color!\n"
"    mouse.up: super-dooper\n"
"    ev.track.off\n"
"    cg.update.knob  \n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\\ Utility functions to make an XY controller only vertical or horizontal\n"
": XY.ONLY.HORIZONTAL ( cg-xy -- )\n"
"    >r  0 xy_vertical_part r@ put.enable: [] \\ disable vertical part\n"
"    r@ get.wh.dc: []  \\ ( -- width height )\n"
"    NIP 2- negate \\ subtract borders from HEIGHT\n"
"    xy_vertical_part r> put.knob.size: []\n"
";\n"
"\n"
": XY.ONLY.VERTICAL ( cg-xy -- )\n"
"    >r  0 xy_horizontal_part r@ put.enable: [] \\ disable horizontal part\n"
"    r@ get.wh.dc: []  \\ ( -- width height )\n"
"    DROP 2- negate \\ subtract borders from WIDTH\n"
"    xy_horizontal_part r> put.knob.size: []\n"
";\n"
"\n";

const char* ctrl_xy_fth = (const char*) temp_binary_data_17;

//================== dbl_list.fth ==================
static const unsigned char temp_binary_data_18[] =
"\\ @(#) dbl_list.fth 96/06/11 1.1\n"
"\\ Doubly Linked List Support\n"
"\\ This is similar but not as fancy as an Amiga Exec List\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1991 Phil Burk\n"
"\n"
"ANEW TASK-DBL_LIST\n"
"\n"
":STRUCT DoubleList\n"
"    RPTR dll_Head\n"
"    RPTR dll_Tail\n"
"    RPTR dll_TailPrev\n"
";STRUCT\n"
"\n"
"\n"
":STRUCT DoubleNode\n"
"    RPTR dln_Next\n"
"    RPTR dln_Prev\n"
";STRUCT\n"
"\n"
"\\ List handling macros.\n"
"\n"
": DLL.NODE.INIT  ( node -- , initialize node )\n"
"    >r ( save node address )\n"
"    NULL r@ ..!  dln_next\n"
"    NULL r@ ..!  dln_Prev\n"
"    rdrop\n"
";\n"
"\n"
": DLL.NEWLIST ( list -- , Initialize list header.)\n"
"    dup ..  dll_Tail over ..!  dll_Head\n"
"    dup ..  dll_Head over ..!  dll_TailPrev\n"
"    NULL swap ..!  dll_Tail\n"
";\n"
"\n"
": DLL.EMPTY? ( list -- flag , true if empty )\n"
"    ..@  dll_head ..@  dln_next 0=\n"
";\n"
"\n"
": DLL.FIRST ( list -- first_node , get first node in list )\n"
"    ..@  dll_head\n"
";\n"
"\n"
": DLL.LAST ( list -- last_node , get last node in list )\n"
"    ..@  dll_TailPrev\n"
";\n"
"\n"
": DLL.NEXT ( node -- succeeding_node )\n"
"    ..@  dln_next\n"
";\n"
"\n"
": DLL.PREVIOUS ( node -- succeeding_node )\n"
"    ..@  dln_prev\n"
";\n"
"\n"
": DLL.CONNECT  ( node1 node0 -- , connect node1 after node0)\n"
"    2dup swap ( -- n1 n0 n0 n1 ) ..!  dln_Prev\n"
"    swap swap ( -- n1 n0 ) ..!  dln_next\n"
";\n"
"\n"
": DLL.REMOVE ( node -- , remove from list )\n"
"    dup dll.next\n"
"    over dll.previous\n"
"    dll.connect\n"
"    dll.node.init\n"
";\n"
"\n"
": DLL.ADD.TAIL ( node list -- )\n"
"    2dup dll.last  ( -- n l n lastn )\n"
"    dll.connect\n"
"    ..  dll_tail swap dll.connect\n"
";\n"
"\n"
": DLL.ADD.HEAD ( node list -- )\n"
"    2dup dll.first  ( -- n l n firstn )\n"
"    swap dll.connect\n"
"    dll.connect\n"
";\n"
"\n"
": DLL.INSERT  ( node1 node0 -- , insert n1 after n0 )\n"
"    2dup dll.next swap dll.connect ( n1<->n2 )\n"
"    dll.connect ( n0<->n1 )\n"
";\n"
"\n"
": DLL.END?  ( node -- , is this beyond the last node ? )\n"
"    dll.next 0=\n"
";\n"
"\n"
": DLL.LAST?  ( node -- , is this the last node ? )\n"
"    dll.next dll.end?\n"
";\n"
"\n"
"DEFER DLL.PROCESS.NODE ( node )\n"
"' . is DLL.PROCESS.NODE\n"
"\n"
": DLL.SCAN.LIST ( list -- , dump nodes of list )\n"
"    dll.first\n"
"    BEGIN\n"
"        dup dll.next ?dup\n"
"    WHILE\n"
"        swap dll.process.node\n"
"    REPEAT drop\n"
";\n"
"\n"
"\\ Test code\n"
"true [IF]\n"
"DOubleList LIST1\n"
"DoubleNode NODE1\n"
"DoubleNode NODE2\n"
"DoubleNode NODE3\n"
"DoubleNode NODE4\n"
"DoubleNode NODE5\n"
"\n"
": TEL.INIT\n"
"    list1 dll.newlist\n"
"    node1 dll.node.init\n"
"    node2 dll.node.init\n"
"    node3 dll.node.init\n"
";\n"
"\n"
": TEL.LINK\n"
"    node1 list1 dll.add.tail\n"
"    node2 list1 dll.add.tail\n"
"    node3 list1 dll.add.tail\n"
";\n"
"\n"
": DUMP.NODE ( node -- )\n"
"    dup body> >name id.\n"
"    dll.last? not\n"
"    IF  .\"  -> \" cr?\n"
"    ELSE cr\n"
"    THEN\n"
";\n"
"\n"
": SCANL\n"
"    'c dump.node is dll.process.node\n"
"    list1 dll.scan.list\n"
";\n"
"\n"
"[THEN]\n"
"\n"
"\n";

const char* dbl_list_fth = (const char*) temp_binary_data_18;

//================== deck.fth ==================
static const unsigned char temp_binary_data_19[] =
"\\ @(#) deck.fth 96/06/11 1.1\n"
"\\ test diff\n"
"\\ Model deck of cards.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 8/18/87 Remove card after being dealt to prevent\n"
"\\      endless search.\n"
"\n"
"MRESET DEAL:\n"
"ANEW TASK-DECK\n"
"\n"
"METHOD DEAL:\n"
"METHOD SHUFFLE:\n"
"\n"
":CLASS OB.DECK <SUPER OB.LIST\n"
"\n"
":M DEAL:  ( -- index )\n"
"    many: self ?dup\n"
"    IF  choose\n"
"        dup at: self\n"
"        swap remove: self  ( repack deck )\n"
"    ELSE\n"
"        \" DEAL: OB.DECK\" \" No More Cards Left!\"\n"
"        er_fatal ob.report.error\n"
"    THEN\n"
";M\n"
"\n"
":M SHUFFLE: ( -- )\n"
"    clear: self\n"
"    limit: self 0\n"
"    ?DO i add: self\n"
"    LOOP\n"
";M\n"
"\n"
";CLASS\n";

const char* deck_fth = (const char*) temp_binary_data_19;

//================== elmnts.fth ==================
static const unsigned char temp_binary_data_20[] =
"\\ @(#) elmnts.fth 96/06/11 1.1\n"
"\\ ELEMENTS CLASS\n"
"\\ OB.ELMNTS provides an ordered set of N dimensional elements.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 Delta Research\n"
"\\\n"
"\\ MOD: PLB 7/30/86 Added FILL.DIM:\n"
"\\ NOD: PLB 11/8/86 Put TAB in PRINT.ELEMENT: OB.OBJLIST\n"
"\\ MOD: PLB 11/21/86 Optimized MOVE:\n"
"\\ MOD: PLB 12/26/86 Added DUMP.SOURCE: and DUMP.ELEMENT:\n"
"\\ MOD: PLB 1/14/87 Removed dead code, don't zero data in CLEAR:\n"
"\\ MOD: PLB 2/10/87 FIRST: leaves pointer at second element.\n"
"\\ MOD: PLB 2/13/87 LAST: leaves pointer past last, added\n"
"\\      FOREWARD: , BACKWARD: .\n"
"\\ MOD: PLB 2/19/87 Added EMPTY: method.\n"
"\\ MOD: PLB 5/13/87 Optimized GET: and PUT:\n"
"\\ MOD: PLB 9/3/87 Added DO: for iteration.\n"
"\\ MOD: PLB 9/19/87 Added COPY: , SPLIT: , and SMEAR: .\n"
"\\ MOD: PLB 11/3/87 Add DELETE:\n"
"\\ MOD: PLB 9/13/88 Remove MRESET\n"
"\\ MOD: PLB 1/6/88  Moved increment of IV-MANY in INSERT:\n"
"\\      to fix overwriting bug.\n"
"\\ MOD: PLB 3/8/89 Made DO: work on other Forths, fix FILL.DIM: msg,\n"
"\\ MOD: PLB 5/17/89 Added GOTO: and WHERE:\n"
"\\ MOD: PLB 12/15/89 Added STUFF{ and }NEWSTUFF:\n"
"\\ MOD: PLB 10/30/90 Better protection in CHOP: and SPLIT:\n"
"\\ MOD: PLB 12/1/90 Make NEXTWRAP: loop without error.\n"
"\\ 00001 PLB 1/14/92 Use ?NEW: in ?INSTANTIATE:\n"
"\n"
"ANEW TASK-ELMNTS\n"
"\n"
"\\ Declare OB.ELMNTS methods.\n"
"METHOD RESET:   ( First method )\n"
"METHOD MANY:\n"
"METHOD ED2I:                METHOD I2ED:\n"
"METHOD ED.AT:               METHOD ED.TO:\n"
"METHOD DIMENSION:           METHOD ADD:\n"
"METHOD FIRST:               METHOD LAST:\n"
"METHOD NEXT:                METHOD CURRENT:\n"
"METHOD CHECK.UNDER:         METHOD CHECK.OVER:\n"
"METHOD STRETCH:             METHOD CHOP:\n"
"METHOD REMOVE:              METHOD INSERT:\n"
"METHOD PRINT.ELEMENT:       METHOD PRINT.DIMENSION:\n"
"METHOD SET.MANY:            METHOD EXECUTE:\n"
"METHOD MAX.ELEMENTS:        METHOD MOVE:\n"
"METHOD MANYLEFT:            METHOD I2ADDR:\n"
"METHOD DUMP.SOURCE:         METHOD DUMP.ELEMENT:\n"
"METHOD BACKWARD:            METHOD FOREWARD:\n"
"METHOD FILL.DIM:            METHOD DO:\n"
"METHOD SPLIT:               METHOD SMEAR:\n"
"METHOD COPY:\n"
"METHOD GOTO:                METHOD WHERE:\n"
"METHOD NEXTWRAP:\n"
"\n"
"\\ Variables to avoid stack dancing in elmnts methods\n"
"U: ZZEL1\n"
"U: ZZEL2\n"
"U: ZZEL3\n"
"U: ZZEL4\n"
"U: ZZEL5\n"
"\n"
"( OB.ELMNTS CLASS )\n"
"( This object has an array of \"elements\" where an element is )\n"
"( a set of values.  It is equivalent to a 2 dimensional list. )\n"
"( Each row can be considered an element. )\n"
"( This can also be considered as a set of multidimensional points)\n"
":CLASS OB.ELMNTS   <SUPER OB.ARRAY\n"
"    IV.LONG IV-DIMENSION   ( number of columns )\n"
"    IV.LONG IV-#ELEMENTS ( maximum number of data elements )\n"
"    IV.LONG IV-MANY     ( Count of elements with data in them )\n"
"    IV.LONG IV-CURRENT  ( Current element pointer )\n"
"\n"
":M RESET:     ( -- , Reset pointers )\n"
"    0 iv=> iv-current\n"
";M\n"
"\n"
":M EMPTY:  ( -- , set to no valid data condition )\n"
"    reset: self\n"
"    0 iv=> iv-many\n"
";M\n"
"\n"
":M CLEAR:  (  -- , clear data and reset pointers  )\n"
"    clear: super\n"
"    empty: self\n"
";M\n"
"\n"
":M INIT:  (  --  )\n"
"    init: super\n"
"    reset: self\n"
"    0 iv=> iv-dimension\n"
"    0 iv=> iv-#elements\n"
"    0 iv=> iv-many\n"
";M\n"
"\n"
":M FREE: ( -- , clear some ivars )\n"
"    free: super\n"
"    0 iv=> iv-#elements\n"
"    0 iv=> iv-dimension\n"
";M\n"
"\n"
":M ?NEW:  ( maxindex #dimensions -- addr | 0, allocate data space )\n"
"    2dup *  ?new: super >r\n"
"    iv=> iv-dimension\n"
"    iv=> iv-#elements   ( for keeping track of max data elements )\n"
"    r>\n"
";M\n"
"\n"
":M NEW: ( #cells -- , abort if error )\n"
"    ?new: self <new:error>\n"
";M\n"
"\n"
":M ED2I: ( element# dimension# -- index , calculate  index)\n"
"    swap iv-dimension  *  +\n"
";M\n"
"\n"
":M I2ED: ( index -- element# dimension# )\n"
"    iv-dimension  /mod swap\n"
";M\n"
"\n"
"\\ This is not really fast but is still useful.\n"
":M I2ADDR: ( index -- address , calculate address of item )\n"
"    iv-width * iv-pntr +\n"
";M\n"
"\n"
":M ED.AT:  ( e# d# -- value , fetch value from shape )\n"
"    ed2i: self  at.self\n"
";M\n"
"\n"
":M ED.TO:  ( value e# d# -- , store value in shape )\n"
"    ed2i: self  to.self\n"
";M\n"
"\n"
":M DIMENSION:    ( -- #dimensions , return # of dimensions )\n"
"    iv-dimension\n"
";M\n"
"\n"
":M MAX.ELEMENTS:   ( -- max , max number of elements allowed )\n"
"    iv-#elements\n"
";M\n"
"\n"
"\\ PUT: and GET: have been optimized at the expense of elegance.\n"
"\\ This stores into an entire element (or row).\n"
"\\ The number of data items must match the number of dimensions.\n"
":M PUT:   ( V1 V2 V3 ... VN E# -- , Put values in e#)\n"
"    1+ iv-dimension ?dup\n"
"    IF  dup>r *  ( Calculate index of last value + 1 )\n"
"        r> 0\n"
"        ?DO   ( For all values )\n"
"            1- tuck to.self\n"
"        LOOP drop\n"
"    ELSE\n"
"        \" PUT: OB.ELMNTS\"  \" No memory allocated!\"\n"
"        er_fatal ob.report.error\n"
"    THEN\n"
";M\n"
"\n"
":M GET:   ( E# -- V1 V2 V3 ... VN   , Get values from e#)\n"
"    iv-dimension dup>r *  ( Calculate index of first value )\n"
"    dup r> + swap\n"
"    ?DO   ( For all values )\n"
"        i at.self\n"
"    LOOP\n"
";M\n"
"\n"
":M ADD:  (  v1 v2 ... vn -- , add element to end )\n"
"    iv-many   put: self\n"
"    1 iv+> iv-many\n"
";M\n"
"\n"
":M FIRST:  (  -- v1 v2 ... vn , return 1st element & setpntr=1)\n"
"    0 get: self\n"
"    1 iv=> iv-current\n"
";M\n"
"\n"
":M LAST:  ( -- v1 ... vn , return last element & set pointer )\n"
"    iv-many  dup iv=> iv-current\n"
"    1- get: self\n"
";M\n"
"\n"
":M MANY: ( -- N , Number of elements with valid data )\n"
"    iv-many\n"
";M\n"
"\n"
":M SIZE:  (  -- size , return number of single values  )\n"
"    iv-many   dimension: self *\n"
";M\n"
"\n"
":M MANYLEFT:  ( -- N , # elements remaining after current )\n"
"    iv-many iv-current  -\n"
";M\n"
"\n"
":M CURRENT:  ( -- VAL , Fetch current value )\n"
"    iv-current\n"
"    dup 1+ iv-many  >\n"
"    IF\n"
"        \" CURRENT: OB.ELMNTS\"  \" Past end of list!\"\n"
"        er_fatal ob.report.error\n"
"    THEN    get: self\n"
";M\n"
"\n"
":M NEXT:  ( -- v1 v2 ... vn , return next element and inc pntr)\n"
"    iv-current get: self\n"
"    1 iv+> iv-current\n"
";M\n"
"\n"
":M NEXTWRAP:  ( -- v1 v2 ... vn , wrap if at end )\n"
"    iv-current get: self\n"
"    iv-current 1+ dup iv-many >=\n"
"    IF drop 0\n"
"    THEN iv=> iv-current\n"
";M\n"
"\n"
":M CHECK.UNDER: ( #sub -- underflow? , true if trying to remove too many)\n"
"    iv-many >\n"
";M\n"
"\n"
":M CHECK.OVER: ( #add -- overflow? , true if danger of overflow )\n"
"    iv-many +  max.elements: self >\n"
";M\n"
"\n"
":M MOVE: ( from to count -- , move elements up or down )\n"
"    ?dup\n"
"    IF  iv-width *  iv-dimension * >r ( number of bytes )\n"
"        0 ed2i: self i2addr: self swap\n"
"        0 ed2i: self i2addr: self swap\n"
"        r> move\n"
"    ELSE 2drop\n"
"    THEN\n"
";M\n"
"\n"
"\n"
":M SPLIT: ( start count -- , push data up )\n"
"    zzel5 ! zzel4 !       ( avoid stack dancing )\n"
"    zzel5 @ check.over: self\n"
"    IF  \" SPLIT: OB.ELMNTS\" \" Too many elements\"\n"
"        er_return ob.report.error\n"
"    ELSE\n"
"        zzel4 @ iv-many <\n"
"        IF  zzel4 @ iv-current  <\n"
"            IF    zzel5 @ iv+> iv-current\n"
"            THEN\n"
"            zzel5 @ iv+> iv-many\n"
"\\\n"
"\\ Push others up.\n"
"            zzel4 @ ( -- from )\n"
"            dup zzel5 @ + ( -- from to )\n"
"            iv-many 1 pick - ( -- from to count )\n"
"            move: self\n"
"        ELSE\n"
"            \" SPLIT: OB.ELMNTS\" \" Past last element.\"\n"
"            er_return ob.report.error\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M SMEAR: ( start count -- , copy one element up over others )\n"
"    over + 1+ over 1+\n"
"    ?DO dup get: self\n"
"        i put: self\n"
"    LOOP drop\n"
";M\n"
"\n"
":M STRETCH: ( start count -- , copy element at start up, pushing others)\n"
"    over 1+ iv-many <\n"
"    IF\n"
"        over 1+ over split: self\n"
"    ELSE dup iv+> iv-many\n"
"    THEN\n"
"    smear: self\n"
";M\n"
"\n"
":M INSERT:  ( v1 v2 ...vn index  -- ,insert and expand )\n"
"    1 check.over: self\n"
"    IF  \" INSERT: OB.ELMNTS\" \" Too many elements\"\n"
"        er_return ob.report.error\n"
"        put: self bell\n"
"    ELSE\n"
"        dup iv-current  <  ( -- v1-n index flag )\n"
"        IF 1 iv+> iv-current THEN  ( Adjust pointer )\n"
"        dup iv-many <  ( move if any higher data )\n"
"        IF ( -- v1-n index )\n"
"            dup dup 1+ over iv-many swap - ( v1-n index from to count)\n"
"            move: self\n"
"        THEN ( v1-n index )\n"
"        1 iv+> iv-many\n"
"        put: self   ( put in new element )\n"
"    THEN\n"
";M\n"
"\n"
":M CHOP: ( start count -- , remove a chunk )\n"
"    2dup zzel5 ! zzel4 !       ( avoid stack dancing )\n"
"    + check.under: self\n"
"    IF\n"
"        cr ZZEL4 @ .  ZZEL5 @ .\n"
"        \" CHOP: OB.ELMNTS\" \" Not enough elements\"\n"
"        er_return ob.report.error\n"
"    ELSE\n"
"        zzel4 @ iv-current  <\n"
"        IF    iv-current  zzel5 @ -\n"
"            zzel4 @ max iv=> iv-current\n"
"        THEN\n"
"        zzel5 @ negate iv+> iv-many\n"
"\n"
"\\ Pull others down.\n"
"        zzel4 @ zzel5 @ + ( from )\n"
"        zzel4 @   ( from to )\n"
"        iv-many zzel4 @ - move: self\n"
"    THEN\n"
";M\n"
"\n"
":M REMOVE:  ( index  -- , remove and compress  )\n"
"    1 chop: self\n"
";M\n"
"\n"
":M FILL.DIM:    ( value d# -- , fill a dimension with a value )\n"
"    iv-many ?dup\n"
"    IF  0 DO\n"
"            2dup i swap ed.to: self\n"
"        LOOP 2drop\n"
"    ELSE 2drop \" FILL.DIM:\" \" Empty object!\"\n"
"        er_return ob.report.error\n"
"    THEN\n"
";M\n"
"\n"
":M PRINT.ELEMENT:  ( E# -- , Print an element )\n"
"    dimension: self 0 ?DO\n"
"        dup i ed.at: self 7 .r space\n"
"    LOOP  drop\n"
";M\n"
"\n"
":M PRINT.DIMENSION:  ( D# -- , PRINT A COLUMN )\n"
"    cr iv-many 0 ?DO\n"
"        i .   i over ed.at: self 8 .r  cr\n"
"    LOOP drop\n"
";M\n"
"\n"
":M PRINT:   ( -- , Print the elements of a shape )\n"
"    cr name: self cr\n"
"    .\" ELMT\\DIM \" dimension: self 0 ?DO i  8 .r LOOP cr\n"
"    iv-many dup\n"
"    IF  0\n"
"        DO   ( Use late binding for each element to allow mods)\n"
"            i 6 .r  4 spaces\n"
"            i self print.element: [] cr\n"
"            ?pause\n"
"        LOOP\n"
"    ELSE drop .\"   No Data!!\" cr\n"
"    THEN\n"
";M\n"
"\n"
":M SET.MANY: ( many -- , force add of elements )\n"
"    dup 0 iv-#elements within?\n"
"    IF iv=> iv-many\n"
"    ELSE . \" SET.MANY:\" \" MANY outside range!\"\n"
"        er_fatal ob.report.error\n"
"    THEN\n"
";M\n"
"\n"
":M DUMP.ELEMENT: ( e# -- , print source for one element )\n"
"    self print.element: []\n"
"    .\"  add: \" name: self cr\n"
";M\n"
"\n"
":M DUMP.SOURCE: ( -- , Print source code to recreate object. )\n"
"    iv-pntr  ( check for data )\n"
"\\ Write NEW: for object.\n"
"    IF  cr tab iv-#elements .  iv-dimension .\n"
"        .\"  new: \" name: self cr\n"
"\\ Rcreate individual elements.\n"
"        iv-many 0\n"
"        ?DO  i self dump.element: []\n"
"        LOOP cr\n"
"    THEN\n"
";M\n"
"\n"
":M FOREWARD: ( -- , advance read pointer by one )\n"
"    1 iv+> iv-current\n"
";M\n"
":M BACKWARD: ( -- , move read pointer back by one )\n"
"    -1 iv+> iv-current\n"
";M\n"
"\n"
":M GOTO: ( index -- , set data cursor)\n"
"    iv=> iv-current\n"
";M\n"
"\n"
":M WHERE: ( -- index , where is data cursor? )\n"
"    iv-current\n"
";M\n"
"\n"
":M EXTEND:  ( #elements -- , extend array area )\n"
"    dup iv+> iv-#elements  ( new # elements )\n"
"    iv-dimension *  ( #cells to add )\n"
"    extend: super\n"
";M\n"
"\n"
":M DO: ( function_cfa -- , pass each element to function )\n"
"    iv-many 0\n"
"    ?DO ( don't DUP>R before I for some Forths )\n"
"        i over >r get: self r> execute\n"
"    LOOP drop\n"
";M\n"
"\n"
":M COPY: ( start target count target-object -- , copy data to it )\n"
"    zzel4 ! ( target-object )\n"
"    zzel3 ! ( count )\n"
"    zzel2 ! ( target elmnt# )\n"
"    zzel1 ! ( start elmnt# )\n"
"    zzel1 @ 0 ed2i: self i2addr: self   ( source address )\n"
"    zzel2 @ 0 zzel4 @ ed2i: [] dup>r    ( target unit # )\n"
"    zzel4 @ i2addr: []                  ( target address )\n"
"    zzel3 @ dimension: self * width: self *  ( #bytes to move )\n"
"    zzel4 @ limit: [] ( max target unit # )\n"
"    r> - zzel4 @ width: [] *\n"
"    over <\n"
"    IF . . .\n"
"        \" COPY: OB.ELMNTS\" \" Not enough room in target!\"\n"
"        er_fatal ob.report.error\n"
"    ELSE\n"
"        move\n"
"    THEN\n"
";M\n"
"\n"
":M }STUFF:  ( stuff... -- , stuff data and set many )\n"
"    iv-pntr\n"
"    IF  stuff.depth dimension: self / >r\n"
"        <}stuff:>\n"
"        r> set.many: self\n"
"    ELSE cr .\" Must be NEW:ed before }STUFF:\" cr abort\n"
"    THEN\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"METHOD DELETE:\n"
"METHOD 0STUFF:\n"
"\n"
": 0DEPTH ( 0 ? ? ? -- N | -1, 'pick' position of first 0)\n"
"    -1 ( default count )\n"
"    depth 1\n"
"    ?DO  i pick 0=\n"
"        IF drop i 1- leave\n"
"        THEN\n"
"    LOOP\n"
";\n"
"\n"
"\\ OB.LIST  ------------------------------------------------\n"
"\\ This class is currently implemented as a one dimensional\n"
"\\ OB.ELMNTS array.  Eventually it should be a linked list.\n"
"\n"
":CLASS OB.LIST  <SUPER OB.ELMNTS\n"
"\n"
":M ?NEW:  ( Max_elements -- addr | 0 )\n"
"    1 ?NEW: SUPER   ( declare as one dimensional )\n"
";M\n"
"\n"
":M NEW: ( max_elements -- , abort if error )\n"
"    ?new: self <new:error>\n"
";M\n"
"\n"
":M DUMP.SOURCE: ( -- , Print source code to recreate object. )\n"
"    iv-pntr  ( check for data )\n"
"\\ Write NEW: for object.\n"
"    IF  cr tab iv-#elements . .\"  new: \" name: self cr\n"
"\\ Rcreate individual elements.\n"
"        many: self 0\n"
"        ?DO  i self dump.element: []\n"
"        LOOP cr\n"
"    THEN\n"
";M\n"
"\n"
":M DELETE: ( value -- , delete that value from list )\n"
"    indexof: self\n"
"    IF  remove: self\n"
"    THEN\n"
";M\n"
"\n"
"\\ Define as colon definition so it can be inherited\n"
"\\ by other classes not derived from LIST.\n"
": <0STUFF:> ( 0 m0 m1 ... mN -- , easy build of object list)\n"
"\\ Scan For 0 to count objects.\n"
"    0DEPTH\n"
"    dup 0>\n"
"    IF  dup self new: []  ( 0 m0 m1 ... mN N -- )\n"
"        dup self set.many: []\n"
"        dup 0\n"
"        ?DO 1- tuck self put: []\n"
"        LOOP\n"
"        2drop\n"
"    ELSE\n"
"        0< IF \" 0STUFF:\" \" 0 required before object list!\"\n"
"            er_fatal ob.report.error\n"
"        ELSE drop\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
":M 0STUFF: ( 0 m0 m1 ... mN -- , easy build of list )\n"
"    <0stuff:>\n"
";M\n"
"\n"
":M }STUFF:  ( stuff...  --- , load it into object )\n"
"    stuff.depth >r\n"
"        <}stuff:>\n"
"    r> set.many: self\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\n"
"METHOD FREEALL:\n"
"METHOD ?INSTANTIATE:\n"
"METHOD DEINSTANTIATE:\n"
"\n"
":CLASS OB.OBJLIST <SUPER OB.LIST\n"
"\n"
":M PRINT.ELEMENT: ( E# -- , PRINT OBJECT INFO )\n"
"    get: self dup name: []  tab  .class: []\n"
";M\n"
"\n"
":M DUMP.ELEMENT: ( E# -- , PRINT OBJECT INFO )\n"
"    tab get: self name: []  .\"  add: \" name: self CR\n"
";M\n"
"\n"
":M FREEALL: ( -- , Send free: message to all members. )\n"
"    many: self dup 0>\n"
"    IF  0 DO\n"
"        i get: self free: []\n"
"    LOOP\n"
"    ELSE drop\n"
"    THEN\n"
";M\n"
"\n"
":M DEINSTANTIATE:\n"
"    many: self 0\n"
"    ?DO\n"
"        i get: self deinstantiate\n"
"    LOOP\n"
"    free: self\n"
";M\n"
"\n"
":M ?INSTANTIATE: ( class_cfa many -- class_pfa | 0 )\n"
"    >r >body r>  \\ need pfa for instantiate\n"
"    dup ?new: self \\ 00001\n"
"    IF\n"
"        0\n"
"        ?DO\n"
"            dup <?instantiate> ?dup\n"
"            IF\n"
"                add: self\n"
"            ELSE\n"
"                self deinstantiate: []\n"
"                drop 0 LEAVE\n"
"            THEN\n"
"        LOOP\n"
"    ELSE\n"
"        2drop 0\n"
"    THEN\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\\ For testing.\n"
"if-testing @ [IF]\n"
"ob.elmnts ELM1\n"
": BUILD.ELM1\n"
"    10 2 new: elm1\n"
"    0  0 add: elm1\n"
"    1 11 add: elm1\n"
"    2 22 add: elm1\n"
"    3 33 add: elm1\n"
"    4 44 add: elm1\n"
"    5 55 add: elm1\n"
";\n"
": P1 print: elm1 ;\n"
"OB.ELMNTS ELM2\n"
": P2 print: elm2 ;\n"
"\n"
"[THEN]\n"
"\n";

const char* elmnts_fth = (const char*) temp_binary_data_20;

//================== errormsg.fth ==================
static const unsigned char temp_binary_data_21[] =
"\\ @(#) errormsg.fth 96/06/11 1.1\n"
"\\ Error Reporting\n"
"\\ This is used by ODE.\n"
"\\ I would not recommend using this for other programs.\n"
"\\ It was developed for host independance.\n"
"\\\n"
"\\ For a turnkey application, you may want to modify this code.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 Delta Research\n"
"\\\n"
"\\ MOD: PLB 4/27/88 Toned down error messages, FATAL -> ERROR-STOP\n"
"\\ MOD: PLB 3/21/90 Removed call to TIB.DUMP\n"
"\\ 00001 PLB 1/22/92 Use 0 ERROR instead of ABORT\n"
"\n"
"ANEW TASK-ERRORMSG\n"
"\n"
": $. ( $string -- , print it )\n"
"    count type\n"
";\n"
"\n"
": UNRAVEL  ( -- , show names on stack )\n"
"    >newline .\" Calling sequence:\"\n"
"\\    r0 @ rp@ - cell/ 2+\n"
"\\   50 min 0\n"
"    20 0\n"
"    DO  4 spaces\n"
"        rp@ i 2+ cell* + @\n"
"        dup code> >name ?dup\n"
"        IF id. drop\n"
"        ELSE .hex\n"
"        THEN cr?\n"
"    LOOP cr\n"
";\n"
"\n"
"0 CONSTANT ER_WARNING    ( Declare levels. )\n"
"1 CONSTANT ER_RETURN\n"
"2 CONSTANT ER_FATAL\n"
"\n"
"CREATE ER-TRACEBACK? FALSE ,  ( should we trace back if bombed)\n"
"\n"
": ER.TRACEBACK\n"
"    er-traceback? @\n"
"    IF .\" Calling Sequence: \"\n"
"        unravel cr .\" Hit any key to continue!\" key drop cr\n"
"    THEN\n"
";\n"
"\n"
"( Report location of error and cause, abort if FATAL )\n"
": ER.SHOW ( $PLACE $MESSAGE $LEVEL -- , SHOW ERROR )\n"
"    cr .\" !!! \" $. .\"  in \" swap $.\n"
"    .\"  - \" $. .\" !\" bell cr\n"
";\n"
"\n"
": (ER.REPORT) ( $PLACE $MESSAGE LEVEL -- , reports error )\n"
"\\     cr .\" TIB = \" tib.dump cr\n"
"\\     .\" Hit key to continue.\" cr key drop\n"
"    >newline\n"
"    CASE\n"
"        ER_WARNING OF \" WARNING\" er.show\n"
"        ENDOF\n"
"        ER_RETURN OF er.traceback \" ERROR\" er.show\n"
"        ENDOF\n"
"        ER_FATAL OF er.traceback \" ERROR-STOP\"\n"
"            er.show abort\n"
"        ENDOF\n"
"        .\" Unrecognized Error LEVEL = \" . CR\n"
"        er.traceback \" UNKNOWN\" er.show abort\n"
"    ENDCASE\n"
";\n"
"\n"
"defer ER.REPORT\n"
"'c (er.report) is er.report\n"
"\n"
": TEST.ERROR  \" TEST.ERROR\" \" Something Terrible Happened!\"\n"
"    ER_RETURN   ER.REPORT\n"
";\n"
"\n";

const char* errormsg_fth = (const char*) temp_binary_data_21;

//================== event_list.fth ==================
static const unsigned char temp_binary_data_22[] =
"\\ Schedule Events at a Specified Time\n"
"\\ An event consists of a data1, data2, cfa pair.\n"
"\\ The data will be put on the stack and the CFA executed.\n"
"\\\n"
"\\ Events are added to the list using this word.\n"
"\\ The events are kept in sorted order for speed.\n"
"\\    POST.EVENT  ( time data1 data2 cfa -- , add to event list )\n"
"\\\n"
"\\ Copyright 1989 - Phil Burk, Larry Polansky, David Rosenboom\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 8/17/90 Put proper time in NEXT-EVENT-TIME, S. Brandorff\n"
"\\ 00001 PLB 11/20/91 Use EXIT instead of RETURN\n"
"\\ 00002 PLB 2/18/92 Add SYS.TASK and SYS.CLEANUP\n"
"\\ 00003 PLB 3/12/92 Removed NEXT-EVENT-TIME, used DO LOOP\n"
"\\       in DO.NEXT.EVENT to prevent race condition, c/index/indx/\n"
"\n"
"ANEW TASK-EVENT_LIST\n"
"\n"
"OB.SHAPE EVENT-SHAPE\n"
"\n"
": DO.NEXT.EVENT  ( -- , execute next event )\n"
"    many: event-shape 0\n"
"    ?DO \\ 00003\n"
"        0 at: event-shape ( equivalent to 0 0 ed.at: but faster )\n"
"        doitnow?\n"
"        IF\n"
"            first: event-shape\n"
"\\ remove before EXECUTE in case EXECUTE causes insert\n"
"            0 remove: event-shape\n"
"            -2 exec.stack?\n"
"            drop \\ time\n"
"            many: event-shape 0=\n"
"            IF LEAVE\n"
"            THEN\n"
"        ELSE\n"
"            LEAVE\n"
"        THEN\n"
"    LOOP\n"
";\n"
"\n"
"\\ This is similar to the search.back method but uses TIME>\n"
": EVL.SEARCH.BACK  { time | indx -- index , next highest if false }\n"
"    many: event-shape  dup -> indx   0 \\ 00003\n"
"    ?DO  -1 +-> indx\n"
"        time   indx 0 ed.at: event-shape time>\n"
"        IF 1 +-> indx leave\n"
"        THEN\n"
"    LOOP\n"
"    indx\n"
";\n"
"\n"
": POST.EVENT  ( time data1 data2 cfa -- , add to event list )\n"
"\\ insert before next later time\n"
"    many: event-shape 0=\n"
"    IF\n"
"        add: event-shape\n"
"    ELSE\n"
"        3 pick  ( get time )\n"
"        evl.search.back\n"
"        insert: event-shape\n"
"    THEN\n"
";\n"
"\n"
": EVL.INIT  ( -- , setup job )\n"
"    64 4 new: event-shape\n"
";\n"
"\n"
": EVL.TERM ( -- )\n"
"    free: event-shape\n"
";\n"
"\n"
": SYS.INIT ( -- ) sys.init evl.init ;\n"
": SYS.TERM ( -- ) evl.term sys.term ;\n"
": SYS.RESET ( -- ) sys.reset clear: event-shape ;\n"
": SYS.CLEANUP ( -- ) sys.cleanup clear: event-shape ;\n"
": SYS.TASK ( -- )  do.next.event sys.task ;\n"
"\n"
"if.forgotten evl.term\n"
"\n";

const char* event_list_fth = (const char*) temp_binary_data_22;

//================== exmember.fth ==================
static const unsigned char temp_binary_data_23[] =
"\\ @(#) exmember.fth 96/06/11 1.1\n"
"\\ @(#) member.fth 95/11/09 1.4\n"
"\\ This files, along with c_struct.fth, supports the definition of\n"
"\\ structure members similar to those used in 'C'.\n"
"\\\n"
"\\ Some of this same code is also used by ODE,\n"
"\\ the Object Development Environment.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, Devid Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\\\n"
"\\ MOD: PLB 1/16/87 Use abort\" instead of er.report.\n"
"\\ MOD: PLB 2/19/87 Made OB.MEMBER immediate, use literal.\n"
"\\ MOD: PLB/MDH 6/7/88 Use 16 bit values in member defs.\n"
"\\ MOD: PLB 7/31/88 Add USHORT and UBYTE.\n"
"\\ MOD: PLB 1/20/89 Treat LITERAL as state sensitive.\n"
"\\ MOD: RDG 9/19/90 Add floating point member support.\n"
"\\ MOD: PLB 6/10/91 Add RPTR\n"
"\\ 00001 PLB 8/3/92 Make RPTR a -4 for S@ and S!\n"
"\\ 941102 RDG port to pforth\n"
"\\ 941108 PLB more porting to pforth. Use ?LITERAL instead os smart literal.\n"
"\n"
"ANEW TASK-EXMEMBER\n"
"decimal\n"
"\n"
": FIND.BODY   ( -- , pfa true | $name false , look for word in dict. )\n"
"\\ Return address of parameter data.\n"
"     32 word find\n"
"     IF  >body true\n"
"     ELSE false\n"
"     THEN\n"
";\n"
"\n"
"\\ Variables shared with object oriented code.\n"
"VARIABLE OB-STATE  ( Compilation state. )\n"
"VARIABLE OB-CURRENT-CLASS  ( ABS_CLASS_BASE of current class )\n"
"1 constant OB_DEF_CLASS   ( defining a class )\n"
"2 constant OB_DEF_STRUCT  ( defining a structure )\n"
"4 constant OB_OFFSET_SIZE\n"
"\n"
": OB.OFFSET@ ( member_def -- offset ) @ ;\n"
": OB.OFFSET, ( value -- ) , ;\n"
": OB.SIZE@ ( member_def -- offset )\n"
"        ob_offset_size + @ ;\n"
": OB.SIZE, ( value -- ) , ;\n"
"\n"
"( Members are associated with an offset from the base of a structure. )\n"
": OB.MAKE.MEMBER ( +-bytes -- , make room in an object at compile time)\n"
"       dup >r  ( -- +-b , save #bytes )\n"
"       ABS     ( -- |+-b| )\n"
"       ob-current-class @ ( -- b addr-space)\n"
"       tuck @          ( as #b c , current space needed )\n"
"       over 2 mod 0=        ( even ammount of data? )\n"
"       IF even-up ( make sure words and longs start on even boundary )\n"
"       THEN\n"
"       swap over + rot !    ( update space needed )\n"
"\\ Save data in member definition. %M\n"
"       ob.offset,    ( save old offset for ivar )\n"
"       r> ob.size,   ( store size in bytes for ..! and ..@ )\n"
";\n"
"\n"
"\\ Unions allow one to address the same memory as different members.\n"
"\\ Unions work by saving the current offset for members on\n"
"\\ the stack and then reusing it for different members.\n"
": UNION{  ( -- offset , Start union definition. )\n"
"    ob-current-class @ @\n"
";\n"
"\n"
": }UNION{ ( old-offset -- new-offset , Middle of union )\n"
"    union{     ( Get current for }UNION to compare )\n"
"    swap ob-current-class @ !  ( Set back to old )\n"
";\n"
"\n"
": }UNION ( offset -- , Terminate union definition, check lengths. )\n"
"    union{ = NOT\n"
"    abort\" }UNION - Two parts of UNION are not the same size!\"\n"
";\n"
"\n"
"\\ Make members compile their offset, for \"disposable includes\".\n"
": OB.MEMBER  ( #bytes -- , make room in an object at compile time)\n"
"           ( -- offset , run time for structure )\n"
"    CREATE ob.make.member immediate\n"
"    DOES> ob.offset@  ( get offset ) ?literal\n"
";\n"
"\n"
": OB.FINDIT  ( <thing> -- pfa , get pfa of thing or error )\n"
"    find.body not\n"
"    IF cr count type .\"    ?\??\"\n"
"       true abort\" OB.FINDIT - Word not found!\"\n"
"    THEN\n"
";\n"
"\n"
": OB.STATS ( member_pfa --  offset #bytes )\n"
"    dup ob.offset@ swap\n"
"    ob.size@\n"
";\n"
"\n"
": OB.STATS? ( <member> -- offset #bytes )\n"
"    ob.findit ob.stats\n"
";\n"
"\n"
": SIZEOF() ( <struct>OR<class> -- #bytes , lookup size of object )\n"
"    ob.findit @\n"
"    ?literal\n"
"; immediate\n"
"\n"
"\\ Basic word for defining structure members.\n"
": BYTES ( #bytes -- , error check for structure only )\n"
"    ob-state @ ob_def_struct = not\n"
"    abort\" BYTES - Only valid in :STRUCT definitions.\"\n"
"    ob.member\n"
";\n"
"\n"
"\\ Declare various types of structure members.\n"
"\\ Negative size indicates a signed member.\n"
": BYTE ( <name> -- , declare space for a byte )\n"
"    -1 bytes ;\n"
"\n"
": SHORT ( <name> -- , declare space for a 16 bit value )\n"
"    -2 bytes ;\n"
"\n"
": LONG ( <name> -- )\n"
"    cell bytes ;\n"
"\n"
": UBYTE ( <name> -- , declare space for signed  byte )\n"
"    1 bytes ;\n"
"\n"
": USHORT ( <name> -- , declare space for signed 16 bit value )\n"
"    2 bytes ;\n"
"\n"
"\n"
"\\ Aliases\n"
": APTR    ( <name> -- ) long ;\n"
": RPTR    ( <name> -- ) -4 bytes ; \\ relative relocatable pointer 00001\n"
": ULONG   ( <name> -- ) long ;\n"
"\n"
": STRUCT ( <struct> <new_ivar> -- , define a structure as an ivar )\n"
"    [compile] sizeof() bytes\n"
";\n";

const char* exmember_fth = (const char*) temp_binary_data_23;

//================== float_port.fth ==================
static const unsigned char temp_binary_data_24[] =
"\\ Floating point words from HMSL redefined using ANSI Forth\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 2016 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\n"
"ANEW TASK-FLOAT_PORT\n"
"\n"
": FPINIT ; \\ not needed, floats always available\n"
": FPTERM ;\n"
"\n"
": FMOD ( r1 r2 -f- rem{f1/f2} , calc remainder )\n"
"    fover fover f/\n"
"    f>s s>f\n"
"    f* f-\n"
";\n"
"\n"
": F= ( r1 r2 -f- , -- flag )\n"
"    f- f0=\n"
";\n"
"\n"
": F>  ( r1 r2 -f- , -- flag )\n"
"    fswap f<\n"
";\n"
"\n"
": F>I ( r -f- , -- n )\n"
"    f>s\n"
";\n"
"\n"
": FIX  ( r -f- , -- n , rounds )\n"
"    fround\n"
";\n"
"\n"
": FLOAT ( n -- , -f- r , convert to float )\n"
"    s>f\n"
";\n"
"\n"
": I>F ( n -- , -f- r , convert to float )\n"
"    s>f\n"
";\n"
"\n"
": INT ( r -f- , -- n )\n"
"    f>s\n"
";\n"
"\n"
": F>TEXT ( r -f- addr count , converts fp to text )\n"
"    (f.)\n"
";\n"
"\n"
": F.R ( r -f- , width -- , set width of field, print )\n"
"    >r   \\ save width\n"
"    (f.)\n"
"    r> over - spaces\n"
"    type\n"
";\n"
"\n"
": PLACES ( n -- , sets default number of fractional digits )\n"
"    set-precision    \\ this is not quite right, this sets significant digits\n"
";\n"
"\n"
": FNUMBER? ( $string -- true | false , -f- r )\n"
"    number?       \\ handles both ints and floats\n"
";\n";

const char* float_port_fth = (const char*) temp_binary_data_24;

//================== global_data.fth ==================
static const unsigned char temp_binary_data_25[] =
"\\ Global Data used by many modules in HMSL\n"
"\n"
"ANEW TASK-GLOBAL_DATA\n"
"\n"
"variable HMSL-WINDOW   ( window to use for drawing HMSL )\n"
"\n"
"variable TICKS/BEAT\n"
"40 ticks/beat !\n"
"\n"
"variable TIMESIG-NUMER  ( numerator )\n"
"4 timesig-numer !\n"
"\n"
"variable TIMESIG-DENOM  ( denomonator )\n"
"4 timesig-denom !\n"
"\n"
"variable QUIT-HMSL    ( quit if set true by anyone )\n"
"\n";

const char* global_data_fth = (const char*) temp_binary_data_25;

//================== graph_util.fth ==================
static const unsigned char temp_binary_data_26[] =
"\\ Graphics Utilities for HMSL to support control grids.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 9/30/86 Changed NDUP to XDUP, PICK to PICK83.\n"
"\n"
"ANEW TASK-GRAPH_UTIL\n"
"\n"
"V: UG-DELTAX    V: UG-DELTAY\n"
": UG.HBARS ( X1 Y1 DX DY NBARS -- , Draw NBARS horizontal bars )\n"
"    rot ug-deltax !   swap ug-deltay !   ( Save increments )\n"
"    0 ?DO   ( Loop NBARS Times )\n"
"       2dup gr.move   2dup swap  ug-deltax @ + swap gr.draw\n"
"       ug-deltay @ +\n"
"    LOOP     2drop\n"
";\n"
": UG.VBARS ( X1 Y1 DX DY NBARS -- , Draw NBARS vertical bars )\n"
"    rot ug-deltax !   swap ug-deltay !   ( Save increments )\n"
"    0 ?DO   ( Loop NBARS Times )\n"
"       2dup gr.move   2dup  ug-deltay @ + gr.draw\n"
"       swap ug-deltax @ + swap\n"
"    LOOP     2drop\n"
";\n"
"\n"
": UG.GRID ( X1 Y1 DX DY NX NY -- , DRAW A GRID )\n"
"    6 xdup   ( Duplicate all parameters )\n"
"    rot * swap 1+ ug.vbars   ( DRAW VERTICAL BARS )\n"
"    >r rot * swap r> 1+ ug.hbars ( Horizontal bars )\n"
";\n"
"\n"
": UG.POS2I  ( X X0 DX -- CALCULATE INDEX FOR X )\n"
"     -rot -   dup 0>\n"
"     IF    swap /\n"
"     ELSE  swap / 1-\n"
"     THEN\n"
";\n"
"\n"
": UG.INRANGE ( X X1 X2 -- FLAG , Check for x in range )\n"
"    1- within?\n"
"\\    rot swap over >\n"
"\\    -rot <= and\n"
";\n"
"\n"
": UG.?HIT ( X X0 DX NX -- [INDEX] 0/1 , Calc index if in )\n"
"     >r ug.pos2i dup 0  r> ug.inrange\n"
"     IF 1 ELSE drop 0 THEN\n"
";\n"
"\n"
": UG.BOX ( x1 y1 x2 y2 -- , Draw a box polyline )\n"
"    2over gr.move\n"
"    3 pick83 over gr.draw\n"
"    2dup gr.draw\n"
"    drop over gr.draw\n"
"    gr.draw\n"
";\n";

const char* graph_util_fth = (const char*) temp_binary_data_26;

//================== graphics.fth ==================
static const unsigned char temp_binary_data_27[] =
"\\ Graphics Host Dependant Module\n"
"\\ This module provides simple graphics functions.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 Phil Burk, Larry Polansky, David Rosenboom\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 12/3/86 ADD GR_SMALL_TEXT\n"
"\\ MOD: PLB 12/14/86 Graphics and events in separate HMSL window.\n"
"\\ MOD: PLB 4/15/87 Force font to system font.\n"
"\\ MOD: PLB 6/25/87 GR.INIT to use single task.\n"
"\\ MOD: PLB 7/8/87 Add SYS.INIT\n"
"\\ MOD: PLB 8/3/89 Convert to H4th\n"
"\\ 920708 PLB Allow variable size HMSL window default.\n"
"\\ 930107 PLB Added ?CLOSEBOX\n"
"\n"
"ANEW TASK-GRAPHICS\n"
"\n"
"\\ Define device resolution 00003\n"
"  0 value GR_XMIN\n"
"600 value GR_XMAX\n"
"  4 value GR_YMIN  ( Leave room at top for window bar. )\n"
"400 value GR_YMAX\n"
"\n"
"\\ Define default window 00003\n"
"10 value GR_WINDOW_LEFT\n"
"40 value GR_WINDOW_TOP\n"
"gr_xmax value GR_WINDOW_WIDTH\n"
"gr_ymax value GR_WINDOW_HEIGHT\n"
"\n"
"\\ Define colors in simple pallette\n"
"0 constant GR_WHITE\n"
"1 constant GR_BLACK\n"
"2 constant GR_RED\n"
"3 constant GR_GREEN\n"
"4 constant GR_BLUE\n"
"5 constant GR_CYAN\n"
"6 constant GR_MAGENTA\n"
"7 constant GR_YELLOW\n"
"\n"
"0 CONSTANT GR_INSERT_MODE\n"
"1 CONSTANT GR_XOR_MODE\n"
"\n"
"\\ 2019 Modern GUIs redraw instead of XORing.\n"
"\\ XOR was used in the past because redrawing was too slow.\n"
"0 constant GR_XOR_SUPPORTED\n"
"\n"
"V: GR-HEIGHT\n"
"12 value GR_SMALL_TEXT\n"
"16 value GR_BIG_TEXT\n"
"\n"
"\\ Start code necessary for HMSL ---------------------------\n"
"\\ Define Mouse Event Codes in a host independant fashion.\n"
"0 dup  constant EV_NULL\n"
"1+ dup constant EV_MOUSE_DOWN\n"
"1+ dup constant EV_MOUSE_UP\n"
"1+ dup constant EV_MOUSE_MOVE\n"
"1+ dup constant EV_MENU_PICK\n"
"1+ dup constant EV_CLOSE_WINDOW\n"
"1+ dup constant EV_REFRESH\n"
"1+ dup constant EV_KEY   \\ 00001\n"
"drop\n"
"\n"
":STRUCT  RECT\n"
"    short   rect_top\n"
"    short   rect_left\n"
"    short   rect_bottom\n"
"    short   rect_right\n"
";STRUCT\n"
"\n"
":STRUCT WindowTemplate  \\ Structure used to describe a new window\n"
"\\   long    wt_wStorage\n"
"    struct  rect    wt_rect\n"
"    long    wt_title\n"
"\\   short   wt_visible\n"
"\\   short   wt_procID\n"
"\\   long    wt_behind\n"
"\\   short   wt_goAwayFlag\n"
"\\   long    wt_refcon\n"
";STRUCT\n"
"\n"
"decimal\n"
": GR.OPENWINDOW ( new_window -- window , open a new window )\n"
"    hostOpenWindow()\n"
";\n"
"\n"
": GR.CLOSEWINDOW ( window -- , close the window )\n"
"    hostCloseWindow()\n"
";\n"
"\n"
"U: GR-CURWINDOW  ( holds pointer to current window or 0 )\n"
": GR.SETPORT ( -- , Set window port. )\n"
"    gr-curwindow @ hostSetCurrentWindow()\n"
";\n"
"    \n"
"\\ GRAPHICS OUTPUT PRIMITIVES -------------------------\n"
"\n"
": GR.DRAW ( X Y -- , DRAW IN CURRENT COLOR )\n"
"     gr.setport\n"
"     hostDrawLineTo()\n"
";\n"
": GR.MOVE ( X Y -- , Move to new position. )\n"
"     gr.setport\n"
"     hostMoveTo()\n"
";\n"
"\n"
": GR.TYPE ( addr count -- , Draw string at current position. )\n"
"     gr.setport\n"
"     hostDrawText()\n"
";\n"
"\n"
": GR.TEXT ( string -- , Draw string at current position. )\n"
"     count gr.type\n"
";\n"
"\n"
": GR.TEXTLEN  ( addr count -- xpixels , x size of string )\n"
"     gr.setport\n"
"     hostGetTextLength()\n"
";\n"
"\n"
": GR.XYTEXT  ( X Y S1 -- , Draw string at x,y )\n"
"   -rot GR.MOVE   ( Move to start, use graphics characters )\n"
"   GR.TEXT\n"
";\n"
"\n"
": GR.NUMBER  ( value -- , Display number as text at CP )\n"
"     n>text text>string gr.text\n"
";\n"
"\n"
"\\ Allocate space for RECT records.\n"
"VARIABLE GR-RECT 4 vallot\n"
"\n"
": GR.RECT ( X1 Y1 X2 Y2 -- , Fill region with current FACI )\n"
"    gr.setport\n"
"    hostFillRectangle()\n"
";\n"
"\n"
"\\ GRAPHICS ATTRIBUTES -----------------------------------\n"
"V: GR-COLOR ( Foreground Color for primitives. )\n"
"\n"
": GR.COLOR!   ( Color -- , set color )\n"
"    dup gr-color !\n"
"    gr.setport\n"
"    hostSetColor()\n"
";\n"
": GR.COLOR@ ( -- COLOR , Query COLOR )\n"
"    gr-color @\n"
";\n"
"\n"
"V: GR-BCOLOR ( Background Color for primitives. )\n"
": GR.BCOLOR!   ( BColor=0|1 -- )\n"
"    dup gr-bcolor !\n"
"    gr.setport\n"
"    hostSetBackgroundColor()\n"
";\n"
": GR.BCOLOR@ ( -- BCOLOR , Query BCOLOR )\n"
"    gr-bcolor @\n"
";\n"
"\n"
"variable GR-MODE\n"
": GR.MODE!  ( mode -- , Set drawing mode mode )\n"
"    dup gr-mode !\n"
"    gr.setport\n"
"    hostSetDrawingMode()\n"
";\n"
": GR.MODE@ ( -- MODE , Query MODE )\n"
"    gr-mode @\n"
";\n"
"\n"
"variable GR-FONT\n"
": GR.FONT!  ( font -- )\n"
"    dup gr-font !\n"
"    gr.setport\n"
"    hostSetFont()\n"
";\n"
"\n"
": GR.FONT@  ( -- font )\n"
"    gr-font @\n"
";\n"
"\n"
": GR.HEIGHT! ( height -- , Set character height in pixels. )\n"
"    dup gr-height !\n"
"    gr.setport\n"
"    hostSetTextSize()\n"
";\n"
": GR.HEIGHT@ ( -- height , Query height )\n"
"    gr-height @\n"
";\n"
"\n"
": GR.SET.CURWINDOW ( window -- , Set current window, rastport, and attributes. )\n"
"    gr-curwindow !  gr.setport\n"
"    1 gr-color ! ( Default color. )\n"
"    gr_small_text gr-height !  ( Set default text character height )\n"
"    gr_insert_mode gr-mode !\n"
";\n"
"\n"
": GR.CLOSECURW ( -- , Close current window )\n"
"    gr-curwindow @ ?dup\n"
"    IF gr.closewindow\n"
"    THEN\n"
"    0 gr-curwindow !\n"
";\n"
"\n"
": GR.HIGHLIGHT ( X1 Y1 X2 Y2 -- , HIGHLIGHT region )\n"
"    gr.mode@ >r\n"
"    gr.color@ >r\n"
"    GR_XOR_MODE gr.mode!\n"
"    GR_YELLOW gr.color!\n"
"    gr.rect\n"
"    r> gr.color!\n"
"    r> gr.mode!\n"
";\n"
": GR.DEHIGHLIGHT ( X1 Y1 X2 Y2 -- , HIGHLIGHT region )\n"
"    gr.highlight\n"
";\n"
"\n"
"\\ GRAPHICS CONTROL -------------------------------------\n"
": GR.CLEAR ( -- , Clear screen )\n"
"      gr.color@ 0 gr.color!\n"
"      0 0 gr_xmax gr_ymax gr.rect\n"
"      gr.color!\n"
";\n"
"\n"
"\\ Create in dictionary for 0 at startup.\n"
"CREATE GR%-IF-INIT 0 ,   \n"
"\n"
": GR.INIT  ( -- , Initialize graphics system. )\n"
"    gr%-if-init @ NOT \n"
"    IF \n"
"        0 gr-curwindow !\n"
"        true gr%-if-init !\n"
"    THEN\n"
";\n"
"\n"
": GR.TERM ( -- , Terminate Graphics )\n"
"    gr%-if-init @\n"
"    IF gr.closecurw\n"
"\\       FALSE gr%-if-init !  ( never init twice )\n"
"    THEN\n"
";\n"
"\n"
": GR.CHECK ( -- , aborts if graphics system not initialized )\n"
"   gr-curwindow @ 0= abort\" GR.CHECK - No open window!!\"\n"
";\n"
"    \n"
"\\ GRAPHICS INPUT -------------------------------------------\n"
"V: GR%-PENSTATE\n"
"V: GR%-MOUSE_XPOS\n"
"V: GR%-MOUSE_YPOS\n"
"\n"
"VARIABLE EV-IF-TRACK-MOUSE ( true if tracking on )\n"
"VARIABLE EV-LAST-MOUSEX\n"
"VARIABLE EV-LAST-MOUSEY\n"
"\n"
": EV.GETXY  ( -- x y , get X,Y from previous mouse event)\n"
"    EV-LAST-MOUSEX EV-LAST-MOUSEY hostGetMouse()\n"
"    ev-last-mousex @\n"
"    ev-last-mousey @\n"
";\n"
"\n"
": EV.GET.EVENT ( -- event_code , usage is host independant )\n"
"    1000 60 / ( timeout = about 1 tick )\n"
"    hostGetEvent()\n"
"    \\ do not return move events if tracking turned off\n"
"    dup EV_MOUSE_MOVE =\n"
"    IF\n"
"        ev-if-track-mouse @ 0=\n"
"        IF\n"
"            drop EV_NULL\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
": GR.GETXY ( -- x y )\n"
"      ev.getxy\n"
";\n"
"\n"
": ?CLOSEBOX ( -- flag , was the closebox hit )\n"
"    ev.get.event EV_CLOSE_WINDOW =\n"
";\n"
"\n"
"\\ These next two routines are obsolete, but may be used for testing.\n"
": GR.XYLOC? ( -- x y flag , return mouse button state )\n"
"      ?terminal IF ABORT THEN  ( %? )\n"
"      ev.get.event\n"
"      CASE\n"
"        EV_NULL OF ENDOF\n"
"        EV_MOUSE_DOWN OF true gr%-penstate !\n"
"                  gr.getxy gr%-mouse_ypos ! gr%-mouse_xpos !\n"
"            ENDOF\n"
"        EV_MOUSE_UP OF false  gr%-penstate !\n"
"                  gr.getxy gr%-mouse_ypos ! gr%-mouse_xpos !\n"
"            ENDOF\n"
"\\        MOUSEMOVE OF gr.getxy gr%-mouse_ypos ! gr%-mouse_xpos ! \n"
"\\            ENDOF\n"
"      endcase\n"
"      gr%-mouse_xpos @\n"
"      gr%-mouse_ypos @\n"
"      gr%-penstate  @\n"
";\n"
"\n"
": GWAIT.SWUP  ( -- , Wait until SW1 is up. )\n"
"     BEGIN\n"
"        gr.xyloc? nip nip not\n"
"     UNTIL\n"
";\n"
"\n"
"\\ HMSL specific support ------------------------------\n"
"\n"
"windowTemplate HMSL-NewWindow\n"
"\\ Set this to a string.\n"
"defer  HMSL.TITLE  ( -- $string )\n"
"'c null is hmsl.title\n"
"\n"
": Window.Defaults  ( WIndowTemplate -- , set reasonable defaults )\n"
"    >r\n"
"    80 r@ .. wt_rect ..! rect_top\n"
"    10 r@ .. wt_rect ..! rect_left\n"
"    320 r@ .. wt_rect ..! rect_bottom\n"
"    400 r@ .. wt_rect ..! rect_right\n"
"    \" HMSL\" r@ ..! wt_title\n"
"    rdrop\n"
";\n"
"\n"
"\\ Just open message window.\n"
": GR.OPENHMSL ( -- , Open HMSL window for tests. )\n"
"    HMSL-NewWindow window.defaults\n"
"    hmsl.title ?dup\n"
"    IF HMSL-NewWindow ..! wt_title\n"
"    THEN\n"
"\\\n"
"\\ use adjustable values 00001\n"
"    gr_window_top hmsl-newwindow .. wt_rect ..! rect_top\n"
"    gr_window_left hmsl-newwindow .. wt_rect ..! rect_left\n"
"    gr_window_top gr_window_height + hmsl-newwindow .. wt_rect ..! rect_bottom\n"
"    gr_window_left gr_window_width + hmsl-newwindow .. wt_rect ..! rect_right\n"
"\\\n"
"    HMSL-NewWindow gr.openwindow dup hmsl-window ! ?dup\n"
"    IF  gr.set.curwindow\n"
"    ELSE .\" Could not open HMSL window!\" cr abort\n"
"    THEN\n"
";\n"
"\n"
": GR.CLOSEHMSL  ( -- , close HMSL window )\n"
"    gr.closecurw\n"
"    hmsl-window off\n"
";\n"
"\n"
": HMSL.SET.WINDOW  ( -- )\n"
"    hmsl-window @ ?dup\n"
"    IF gr.set.curwindow\n"
"    ELSE .\" HMSL.SET.WINDOW - not open!\" abort\n"
"    THEN\n"
";\n"
"\n"
"\n"
": EV.GET.KEY  ( -- char , get key data saved by EV.GET.CLASS )\n"
"    [char] X\n"
";\n"
"\n"
": EV.POLL.XY ( -- x y , get current x y from window )\n"
"    hmsl-window @ gr-curwindow ! gr.setport\n"
"    ev.getxy\n"
";\n"
"\n"
": EV.UPDATE.TRACK ( -- , update mouse tracking position )\n"
"    ev.poll.xy ev-last-mousey !\n"
"    ev-last-mousex !\n"
";\n"
"\n"
": EV.TRACK.ON ( -- , turn on mouse tracking )\n"
"    true ev-if-track-mouse !\n"
"    ev.update.track\n"
";\n"
": EV.TRACK.OFF\n"
"    false ev-if-track-mouse !\n"
";\n"
"\n"
": EV.FLUSH  ( -- , flush events from queue )\n"
"    BEGIN\n"
"        ev.get.event\n"
"    EV_NULL = UNTIL\n"
";\n"
"\n"
"\n"
"VARIABLE EV-LAST-TICKS    \\ Saved for detecting double clicks.\n"
"VARIABLE EV-PREV-TICKS    \\ Time before for detecting double clicks.\n"
"\n"
": EV.2CLICK? ( -- flag , true if last was double click )\n"
"    ev-last-ticks @\n"
"    ev-prev-ticks @ -\n"
"    5 <\n"
";\n"
"\n"
"\\ -----------------------------------------------------\n"
"\n"
": SYS.INIT sys.init \" gr.init\" debug.type gr.init ;\n"
": SYS.TERM gr.term sys.term ;\n";

const char* graphics_fth = (const char*) temp_binary_data_27;

//================== hmsl_top.fth ==================
static const unsigned char temp_binary_data_28[] =
"\\ This is the top level file for HMSL the\n"
"\\ Hierarchical Music Specification Language\n"
"\\\n"
"\\ The required initialization and termination can be performed\n"
"\\ from this file.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 - Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ MOD: 8/16/86 Added main menu and menu picking.\n"
"\\ MOD: 10/14/86 Changed 'COLDEXEC to COLDEXEC\n"
"\\ MOD: 10/21/86 Removed MM.INIT and OPEN.LIBRARIES, add TRAPS\n"
"\\ MOD: PLB 11/8/86 Added Copyright display.\n"
"\\ MOD: PLB 12/4/86 Mods for MAC\n"
"\\ MOD: PLB 12/9/86 Set more Mac variables.\n"
"\\ MOD: PLB 12/15/86 Add screen refresh code.\n"
"\\ MOD: PLB 1/14/87 Change HMSL.PLAY to use execute.\n"
"\\ MOD: PLB 2/25/87 Removed init for streams and compose.\n"
"\\ MOD: PLB 3/2/87 Add ABORT: processing.\n"
"\\ MOD: PLB 3/6/87 Draw shape_editor after opening HMSL window.\n"
"\\ MOD: PLB 3/10/87 Added CLEAR: ACTOBJ to HMSL.PLAY\n"
"\\                  Added HMSL.PLAY.MANY which doesn't.\n"
"\\ MOD: PLB 4/15/87 Switch screens by keystroke.\n"
"\\ MOD: PLB 4/21/87 Print Message for Mach2\n"
"\\ MOD: PLB 5/24/87 Removed double draw in HMSL.STARTUP\n"
"\\      Use SYS.INIT and SYS.TERM\n"
"\\ MOD: PLB 6/15/87 Force SE.STARTUP to avoid empty shape error.\n"
"\\ MOD: PLB 7/6/87 Remove Definitions of HMSL.OPEN and CLOSE\n"
"\\      Add LOAD.SEGMENTS and GR.INIT call.\n"
"\\ MOD: PLB 7/8/87 MOved code out to MMAC_TOP\n"
"\\ MOD: PLB 8/13/87 Add HMSL_VERSION#\n"
"\\ MOD: PLB 10/28/87 Remove SYS.RESET from HMSL.CLEANUP\n"
"\\          Moved code to ACTOBJ and called it AO.RESET\n"
"\\ MOD: PLB 11/16/87 Version 3.14\n"
"\\ MOD: PLB 1/29/88 version 3.15\n"
"\\ MOD: PLB 4/26/88 version 3.16\n"
"\\ MOD: PLB 11/15/88 version 3.18 - Fixed Instruments\n"
"\\ MOD: PLB 1/13/89 version 3.19 - for JForth 2.0, double MIDI\n"
"\\          variable RTC, HGO\n"
"\\ MOD: PLB 5/27/89 V3.20 Beta\n"
"\\ MOD: PLB 5/27/89 V3.21 Beta\n"
"\\ MOD: PLB 10/29/89 Allowed for no SE-SCREEN, use DEFAULT-SCREEN,\n"
"\\          FIND and execute SYS.INIT\n"
"\\ MOD: PLB 11/27/89 Version 3.40\n"
"\\ MOD: PLB 2/9/90 Version 3.42, disable SAVE_FORTH after HMSL.INIT\n"
"\\ MOD: PLB 2/23/90 Version 3.43, don't sc.init, set version title\n"
"\\ MOD: PLB 3/15/90 V3.44, reorganize open/close\n"
"\\ MOD: PLB 4/13/90 Add Multiple Event Wait for Amiga\n"
"\\ MOD: PLB 4/23/90 Add flashing cursor to <HMSL.KEY>\n"
"\\ MOD: PLB 6/11/90 Sped up <HMSL.KEY> on Amiga, RESET.KEY in HMSL.TERM\n"
"\\ MOD: PLB 8/8/91 Remove redef of BYE, use AUTO.TERM\n"
"\\ 00001 PLB 9/27/91 Add EV_KEY events\n"
"\\ 00002 PLB 10/7/91 Moved Version setting to seperate file.\n"
"\\ 00003 PLB 10/22/91 Fixed handling of MIDI Parser for Amiga\n"
"\\ 00004 PLB 2/18/92 Use SYS.START, SYS.STOP and SYS.TASK\n"
"\n"
"ANEW TASK-HMSL_TOP\n"
"\n"
"\\ : EV.FLUSH ;\n"
"\n"
"CREATE HMSL-IF-INIT 0 ,\n"
"CREATE HMSL-GRAPHICS if-load-graphics @ ,  ( allow graphics )\n"
"\n"
": HMSL_COPYRIGHT\n"
"\" Copyright 1986,87,88,89,90 - Phil Burk, Larry Polansky, David Rosenboom\"\n"
";\n"
"\n"
": VERSION. ( N -- , print int as d.dd )\n"
"    s->d <# # # ascii . hold #S #>  type\n"
";\n"
"\n"
": HMSL_TITLE\n"
"    \" HMSL - Hierarchical Music Specification Language\"\n"
";\n"
"\n"
": HMSL.COPYRIGHT  ( -- , Show copyright and message.)\n"
" cr\n"
" hmsl_title $. .\"  V\" hmsl_version# version. cr\n"
" cr\n"
" .\" HMSL is intended for a community of experimental composers who\" cr\n"
" .\" are contributing to the development of this language. We would\" cr\n"
" .\" appreciate any suggestions or comments that you have. If you make\" cr\n"
" .\" modifications to HMSL that you would like to see incorporated into\" cr\n"
" .\" the language, please send them to us.  You are allowed to make\" cr\n"
" .\" copies of HMSL for personal backups, but not for any other reason.\" cr\n"
" .\" We would like to be the sole distributor of this, and future\" cr\n"
" .\" versions of HMSL.    Thank you.\" cr\n"
" cr\n"
" hmsl_copyright $. cr\n"
" .\" All Rights Reserved.\" cr\n"
";\n"
"\n"
"\\ Host INDependant Initialization ------------------------\n"
"\\\n"
"\\ In a turnkeyed system FIND won't work.\n"
"\\ You must call USER.INIT and USER.TERM yourself.\n"
": USER.INIT .\" End USER.INIT\" cr ;  ( stubs to end chains )\n"
": USER.TERM .\" End USER.TERM\" cr ;\n"
": USER.RESET .\" End USER.RESET\" cr ;\n"
"\n"
": EXEC.USER.INIT ( -- )\n"
"\\ Use FIND to find USER.INIT chain.\n"
"    \" USER.INIT\" find\n"
"    IF >newline .\" Begin USER.INIT\" cr execute\n"
"    ELSE drop\n"
"    THEN   \\ global system initialization.\n"
";\n"
"\n"
": EXEC.USER.TERM ( -- )\n"
"\\ Use FIND to find USER.TERM chain.\n"
"    \" USER.TERM\" find\n"
"    IF .\" Begin USER.TERM\" cr execute\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": EXEC.USER.RESET ( -- )\n"
"\\ Use FIND to find USER.RESET chain.\n"
"    \" USER.RESET\" find\n"
"    IF .\" Begin USER.RESET\" cr execute\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": (HMSL.RESET)  ( -- , deferred for menu )\n"
"    sys.reset\n"
"    exec.user.reset\n"
"    hmsl-window @\n"
"    IF default-screen @ ?dup\n"
"       IF draw: []\n"
"       THEN\n"
"    THEN\n"
";\n"
"'c (hmsl.reset) is hmsl.reset\n"
"\n"
"variable NO-SAVE-FORTH\n"
"\n"
": SAVE-FORTH  ( <name> -- , disable after HMSL.INIT )\n"
"    ( -- , on Macintosh )\n"
"    no-save-forth @\n"
"    IF  .\" SAVE-FORTH not allowed after HMSL.INIT\" cr\n"
"    ELSE save-forth\n"
"    THEN\n"
";\n"
"\n"
": HMSL.INIT  ( -- , Initialize the system. )\n"
"    hmsl-if-init @ NOT\n"
"    IF  cr\n"
"        no-save-forth on\n"
"\\\n"
"        ob.init    \\ set object stack, critical before any object use!!!\n"
"        'c (hmsl.title) is hmsl.title\n"
"        sys.init   \\ global system initialization\n"
"\\\n"
"\\ Initialize user loaded code above HMSL.INIT, screens, etc.\n"
"        exec.user.init\n"
"        true hmsl-if-init !\n"
"        if-debug off\n"
"        cr .\" HMSL Initialized and Ready!\" cr\n"
"    THEN\n"
";\n"
"\n"
": HMSL.TERM ( -- , Terminate the system. )\n"
"    hmsl-if-init @\n"
"    IF\n"
"\\       reset.emit\n"
"\\       reset.key\n"
"       exec.user.term\n"
"       hmsl.close \\ close window\n"
"       sys.term   \\ global system termination.\n"
"       cr .\" HMSL Terminated\" cr\n"
"       false hmsl-if-init !\n"
"    THEN\n"
";\n"
"\n"
"\\ -------------------\n"
": QUIT.HMSL ( -- )\n"
"    quit-hmsl on\n"
";\n"
"\n"
"defer CLOSEBOX.HIT\n"
"'c quit.hmsl is closebox.hit\n"
"\n"
": HMSL.HANDLE.EVENT ( event -- , Process one event from event queue. )\n"
"    CASE\n"
"         EV_NULL OF ENDOF\n"
"\n"
"         EV_MOUSE_DOWN OF cg-current-screen @ ?dup\n"
"                 IF gr.getxy rot mouse.down: [] drop THEN\n"
"             ENDOF\n"
"\n"
"         EV_MOUSE_UP OF cg-current-screen @ ?dup\n"
"                 IF gr.getxy rot mouse.up: [] THEN\n"
"             ENDOF\n"
"\n"
"         EV_MOUSE_MOVE OF  cg-current-screen @ ?dup\n"
"                 IF gr.getxy rot mouse.move: [] THEN\n"
"             ENDOF\n"
"\n"
"         EV_REFRESH OF\n"
"                hmsl.refresh\n"
"         ENDOF\n"
"\n"
"         EV_KEY OF ev.get.key ?dup \\ 00001\n"
"                 IF cg-current-screen @ ?dup\n"
"                    IF key: []\n"
"                    ELSE drop\n"
"                    THEN\n"
"                 THEN\n"
"             ENDOF\n"
"\n"
"         EV_MENU_PICK OF\n"
"                process.menus\n"
"         ENDOF\n"
"\n"
"         EV_CLOSE_WINDOW OF closebox.hit\n"
"             ENDOF\n"
"    ENDCASE\n"
";\n"
"\n"
": HMSL.CHECK.EVENTS  ( -- )\n"
"    BEGIN ev.get.event ( get one event ) dup\n"
"    WHILE hmsl.handle.event\n"
"    REPEAT drop\n"
";\n"
"\n"
": HMSL.ABORT ( -- , word to call if ABORT called )\n"
"\\    reset.abort  ( reset vector to prevent recursion )\n"
"\\    reset.emit\n"
"\\    reset.key\n"
"    hmsl.close\n"
"    sys.cleanup\n"
"    abort    ( perform appropriate system ABORT )\n"
";\n"
"\n"
": HMSL.STOP  ( -- , put back KEY and EMIT vector )\n"
"\\    reset.emit\n"
"\\    reset.key\n"
"    sys.stop\n"
"    hmsl.close\n"
";\n"
"\n"
": HMSL.STARTUP ( -- )\n"
"    sys.start\n"
"    hmsl-graphics @\n"
"    IF  hmsl.open\n"
"        hmsl.1st.draw\n"
"        ev.flush     ( flush old events )\n"
"        ev.track.off\n"
"    THEN\n"
"    servicing-tasks off\n"
";\n"
"\n"
"CREATE KEY-PARSER 0 ,\n"
"\n"
": HMSL.KEYS  ( -- , Handle keystrokes )\n"
"    ?terminal/8\n"
"    IF  key TOUPPER\n"
"        CASE\n"
"        ascii Q OF true quit-hmsl ! ENDOF\n"
"            key-parser @ ?dup\n"
"            IF over swap execute\n"
"            ELSE .\" Hit Q to quit.\" cr\n"
"            THEN\n"
"        ENDCASE\n"
"    THEN\n"
";\n"
"\n"
"\\ ----------------- MAIN LOOP --------------------\n"
"\n"
"create HMSL-IN-SCAN 0 ,\n"
"\n"
": (HMSL.SCAN)  ( -- , low level scan )\n"
"    sys.task\n"
"    midi-parser @ IF\n"
"        midi.parse.many\n"
"    THEN\n"
"    sys.task\n"
"    hmsl-graphics @\n"
"    IF  hmsl.check.events  ( -- flag , process user input )\n"
"    THEN\n"
";\n"
"\n"
": HMSL.SCAN  ( -- done? , perform one scan of the HMSL cycle )\n"
"\\    'c hmsl.abort set.abort\n"
"    stack.mark\n"
"    (hmsl.scan)\n"
"    stack.check  ( make sure just flag is returned )\n"
"\\    reset.abort\n"
"    quit-hmsl @\n"
";\n"
"\n"
": HMSL.SAFE.SCAN  ( -- done? , scan that will not allow recursion )\n"
"    hmsl-in-scan @ 0=\n"
"    IF hmsl-in-scan on\n"
"       hmsl.scan\n"
"       hmsl-in-scan off\n"
"    ELSE false\n"
"    THEN\n"
";\n"
"\n"
"\\ ----------------------------------------------\n"
": HMSL    ( -- , DO HMSL )\n"
"    false quit-hmsl !    ( set flag for QUIT on main menu )\n"
"    hmsl.startup\n"
"    BEGIN\n"
"        hmsl.keys\n"
"   \t\thmsl.scan\n"
"      \t5 msec \\ prevent HMSL from eating 100% of a CPU\n"
"    UNTIL\n"
"    hmsl.stop\n"
";\n"
"\n"
"exists? ob.morph [IF]\n"
": HMSL.DELAY.EXEC  ( morph -- )\n"
"    time@ rtc.rate@ +  ( postdate 1 second for clean startup )\n"
"    0 rot execute: []\n"
";\n"
"\n"
": HMSL.PLAY.MANY   ( morph -- , execute/play a morph )\n"
"    depth 0= abort\" HMSL.PLAY requires a morph!\"\n"
"    hmsl.delay.exec\n"
"    hmsl\n"
";\n"
"\n"
": HMSL.PLAY ( morph -- , execute/play one morph )\n"
"    clear: actobj    ( prevent crashes from full list. )\n"
"    hmsl.play.many\n"
";\n"
"\n"
": HMSL.EXEC ( morph -- , quit when morph is done )\n"
"    hmsl.delay.exec\n"
"    false quit-hmsl !    ( set flag for QUIT on main menu )\n"
"    hmsl.startup\n"
"    BEGIN\n"
"      hmsl.keys\n"
"      hmsl.scan\n"
"      many: actobj 0= or\n"
"    UNTIL\n"
"    hmsl.stop\n"
";\n"
"\n"
"[THEN]\n"
"\n"
"if.forgotten hmsl.term\n"
"\n"
": AUTO.TERM  hmsl.term auto.term\n"
";\n";

const char* hmsl_top_fth = (const char*) temp_binary_data_28;

//================== hmsl_version.fth ==================
static const unsigned char temp_binary_data_29[] =
"\\ Set Version Number\n"
"ANEW TASK-HMSL_VERSION\n"
"\n"
"\\ Set both Version Number and Title string.\n"
"500 value HMSL_VERSION#\n"
"\n"
": (HMSL.TITLE)  ( -- $string )\n"
"    HOST\" HMSL V5.00\"\n"
";\n";

const char* hmsl_version_fth = (const char*) temp_binary_data_29;

//================== instrument.fth ==================
static const unsigned char temp_binary_data_30[] =
"\\ Generic Instrument which serves as the base Instrument class.\n"
"\\\n"
"\\ Default Interpreter also defined.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"\\ MOD: PLB 4/14/87 Fix velocity bug in INTERP.EXTRACT.PV\n"
"\\ MOD: PLB 4/27/87 Put offset before gamut translation.\n"
"\\ MOD: PLB 6/15/87 Add DEFAULT:\n"
"\\ MOD: PLB 10/7/87 Add TRANSLATE:\n"
"\\                  Make subclass of OB.INT\n"
"\\ MOD: PLB 10/22/87 Make subclass of Circular Buffer.\n"
"\\                  Add GET. and PUT.CHANNEL:\n"
"\\ MOD: PLB 12/15/87 Change from OB.CIRCULAR to OB.LIST\n"
"\\ MOD: PLB 11/8/88 Move FREE: in CLOSE: to OB.MIDI.INSTRUMENT\n"
"\\ MOD: PLB 11/15/88 Fixed GET.CHANNEL:\n"
"\\ MOD: PLB 2/20/89 Add FIRST.NOTE.OFF:\n"
"\\ MOD: PLB 10/4/89 Add DEFAULT.INSTRUMENT\n"
"\\ MOD: PLB 11/16/89 Add MUTE\n"
"\\ MOD: PLB 3/26/90 All Interpreters moved to H:INTERPRETERS\n"
"\\ MOD: PLB 4/9/91 Fix -CFAs for Clone.\n"
"\\ MOD: PLB 9/25/91 Moved PUT.PRESET: from H:MIDI_INSTRUMENT\n"
"\n"
"ANEW TASK-INSTRUMENT\n"
"\n"
"\\ Declare methods.\n"
"METHOD PUT.TUNING:\n"
"METHOD GET.TUNING:\n"
"METHOD PUT.GAMUT:\n"
"METHOD GET.GAMUT:\n"
"METHOD OPEN:\n"
"METHOD ELEMENT.ON:\n"
"METHOD ELEMENT.OFF:\n"
"METHOD CLOSE:\n"
"METHOD PUT.OPEN.FUNCTION:\n"
"METHOD PUT.ON.FUNCTION:\n"
"METHOD PUT.OFF.FUNCTION:\n"
"METHOD PUT.CLOSE.FUNCTION:\n"
"METHOD NOTE.ON:\n"
"METHOD NOTE.ON.FOR:\n"
"METHOD NOTE.OFF:\n"
"METHOD RAW.NOTE.ON:\n"
"METHOD RAW.NOTE.OFF:\n"
"METHOD FIRST.NOTE.OFF:\n"
"METHOD LAST.NOTE.OFF:\n"
"METHOD PRESET:\n"
"METHOD PUT.CHANNEL.RANGE:\n"
"METHOD GET.CHANNEL.RANGE:\n"
"METHOD PUT.CHANNEL:\n"
"METHOD GET.CHANNEL:\n"
"METHOD PUT.MUTE:\n"
"METHOD GET.MUTE:\n"
"METHOD PUT.#VOICES:\n"
"METHOD GET.#VOICES:\n"
"METHOD ALL.OFF:\n"
"METHOD PUT.PRESET:\n"
"METHOD GET.PRESET:\n"
"\n"
"defer DEFAULT.ON.INTERP\n"
"'c 3drop is default.on.interp\n"
"defer DEFAULT.OFF.INTERP\n"
"'c 3drop is default.off.interp\n"
"\n"
":CLASS OB.INSTRUMENT <SUPER OB.LIST\n"
"    IV.LONG IV-INS-OFFSET\n"
"    IV.LONG IV-INS-TUNING\n"
"    IV.LONG IV-INS-GAMUT\n"
"    IV.LONG IV-INS-OPEN-CFA\n"
"    IV.LONG IV-INS-ON-CFA\n"
"    IV.LONG IV-INS-OFF-CFA\n"
"    IV.LONG IV-INS-CLOSE-CFA\n"
"    IV.LONG IV-INS-CHAN-LO\n"
"    IV.LONG IV-INS-CHAN-HI\n"
"    IV.LONG IV-INS-CHANNEL\n"
"    IV.LONG IV-INS-#OPEN     ( How many times opened.)\n"
"    IV.SHORT IV-INS-MUTE      ( if true, no Note On )\n"
"    IV.SHORT IV-INS-#VOICES   ( number voices allowed )\n"
"    IV.LONG IV-INS-PRESET\n"
"\n"
":M DEFAULT: ( -- )\n"
"    0 iv=> iv-ins-offset\n"
"    0 iv=> iv-ins-tuning\n"
"    0 iv=> iv-ins-gamut\n"
"    0 iv=> iv-ins-open-cfa\n"
"    0 iv=> iv-ins-on-cfa\n"
"    0 iv=> iv-ins-off-cfa\n"
"    0 iv=> iv-ins-close-cfa\n"
"    1 iv=> iv-ins-chan-lo\n"
"    1 iv=> iv-ins-chan-hi\n"
"    -1 iv=> iv-ins-channel\n"
"    0 iv=> iv-many\n"
"    0 iv=> iv-ins-#open\n"
"    false iv=> iv-ins-mute\n"
"    8 iv=> iv-ins-#voices\n"
"    -1 iv=> iv-ins-preset  ( default says don't change preset )\n"
";M\n"
"\n"
":M INIT: ( -- )\n"
"    init: super\n"
"    self default: []\n"
";M\n"
"\n"
":M PUT.TUNING: ( tuning -- )\n"
"    iv=> iv-ins-tuning\n"
";M\n"
"\n"
":M GET.TUNING: ( -- tuning )\n"
"    iv-ins-tuning\n"
";M\n"
"\n"
":M PUT.PRESET: ( preset -- , set preset for use when opened. )\n"
"    dup iv=> iv-ins-preset\n"
"    self preset: []\n"
";M\n"
"\n"
":M GET.PRESET: ( -- preset , fetch preset for use when opened. )\n"
"    iv-ins-preset\n"
";M\n"
"\n"
":M PUT.MUTE: ( flag -- , set mute flag )\n"
"    iv=> iv-ins-mute\n"
";M\n"
"\n"
":M GET.MUTE: ( -- flag , set mute flag )\n"
"    iv-ins-mute\n"
";M\n"
"\n"
":M PUT.GAMUT: ( gamut -- , for note index translation)\n"
"    iv=> iv-ins-gamut\n"
";M\n"
"\n"
":M GET.GAMUT: ( -- gamut )\n"
"    iv-ins-gamut\n"
";M\n"
"\n"
":M PUT.OFFSET: ( offset -- )\n"
"    iv=> iv-ins-offset\n"
";M\n"
"\n"
":M GET.OFFSET: ( -- offset)\n"
"    iv-ins-offset\n"
";M\n"
"\n"
":M PUT.CHANNEL.RANGE: ( lo hi -- )\n"
"    2sort iv=> iv-ins-chan-hi\n"
"    iv=> iv-ins-chan-lo\n"
";M\n"
"\n"
":M GET.CHANNEL.RANGE: ( -- lo hi )\n"
"    iv-ins-chan-lo\n"
"    iv-ins-chan-hi\n"
";M\n"
"\n"
":M PUT.CHANNEL: ( channel -- )\n"
"    iv=> iv-ins-channel\n"
";M\n"
"\n"
":M GET.CHANNEL: ( -- channel )\n"
"    iv-ins-channel\n"
";M\n"
"\n"
":M ELEMENT.ON: ( elmnt# shape -- )\n"
"    self iv-ins-on-cfa ?dup\n"
"    IF  -3 exec.stack?\n"
"    ELSE default.on.interp\n"
"    THEN\n"
";M\n"
"\n"
":M ELEMENT.OFF: ( elmnt# shape -- )\n"
"    self iv-ins-off-cfa ?dup\n"
"    IF  -3 exec.stack?\n"
"    ELSE default.off.interp\n"
"    THEN\n"
";M\n"
"\n"
":M PUT.OPEN.FUNCTION: ( cfa -- )\n"
"    iv=> iv-ins-open-cfa\n"
";M\n"
"\n"
":M PUT.ON.FUNCTION: ( cfa -- )\n"
"    iv=> iv-ins-on-cfa\n"
";M\n"
"\n"
":M PUT.OFF.FUNCTION: ( cfa -- )\n"
"    iv=> iv-ins-off-cfa\n"
";M\n"
"\n"
":M PUT.CLOSE.FUNCTION: ( cfa -- )\n"
"    iv=> iv-ins-close-cfa\n"
";M\n"
"\n"
":M TRANSLATE: ( note_index -- note )\n"
"    iv-ins-offset +\n"
"    iv-ins-gamut ?dup\n"
"    IF translate: []\n"
"    THEN\n"
";M\n"
"\n"
":M DETRANSLATE: ( note -- note_index true | false )\n"
"    iv-ins-gamut ?dup\n"
"    IF  detranslate: []\n"
"        IF  iv-ins-offset - true\n"
"        ELSE false\n"
"        THEN\n"
"    ELSE iv-ins-offset - true\n"
"    THEN\n"
";M\n"
"\n"
":M PUT.#VOICES: ( #voices -- , maximum voices for this instrument )\n"
"    1 max iv=> iv-ins-#voices\n"
";M\n"
":M GET.#VOICES: ( -- #voices )\n"
"    iv-ins-#voices\n"
";M\n"
"\n"
":M LAST.NOTE.OFF: ( -- , turn off last note played)\n"
"    many: self\n"
"    IF  last: self 64\n"
"        self raw.note.off: []\n"
"        many: self 1- remove: self\n"
"    THEN\n"
";M\n"
"\n"
":M FIRST.NOTE.OFF: ( -- , turn off first note played)\n"
"\\ This used to be called LAST.NOTE.OFF:  by mistake.\n"
"    many: self\n"
"    IF  0 at.self 64\n"
"        self raw.note.off: []\n"
"        0 remove: self\n"
"    THEN\n"
";M\n"
"\n"
":M ALL.OFF: ( -- , turn off all notes )\n"
"    limit: self\n"
"    IF  many: self 0\n"
"        ?DO i at.self 64\n"
"           self raw.note.off: []\n"
"        LOOP\n"
"        empty: self\n"
"    THEN\n"
";M\n"
"\n"
":M RAW.NOTE.ON: ( note velocity -- )\n"
"    swap . . .\"  ON\" cr\n"
";M\n"
"\n"
":M RAW.NOTE.OFF: ( note velocity -- )\n"
"    swap . . .\"  OFF\" cr\n"
";M\n"
"\n"
":M NOTE.ON: ( note_index velocity -- )\n"
"    iv-ins-mute\n"
"    IF 2drop\n"
"    ELSE >r translate: self  dup r>  ( convert to note )\n"
"        dup\n"
"        IF many: self iv-ins-#voices =  ( Turn one off if full. )\n"
"           IF  first.note.off: self\n"
"           THEN\n"
"           self raw.note.on: []\n"
"           add: self\n"
"        ELSE self raw.note.off: []\n"
"             delete: self\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M NOTE.OFF: ( note_index velocity -- )\n"
"    >r translate: self dup r>\n"
"    self raw.note.off: []\n"
"    delete: self\n"
";M\n"
"\n"
":M NOTE.ON.FOR: ( note vel ontime -- )\n"
"    >r\n"
"    2dup self note.on: []\n"
"    r> vtime@ >r vtime+!  ( advance virtual timer )\n"
"    self note.off: []\n"
"    r> vtime!  ( restore virtual timer )\n"
";M\n"
"\n"
":M OPEN: ( -- )\n"
"    1 iv+> iv-ins-#open\n"
"    limit: self iv-ins-#voices 1+ <\n"
"    IF iv-ins-#voices 1+ new: self ( allocate space for note tracking )\n"
"    THEN\n"
"    self iv-ins-open-cfa if.exec|drop\n"
"    iv-ins-mute\n"
"    IF  if-debug @\n"
"        IF  name: self .\"  muted!\" cr\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M CLOSE: ( -- )\n"
"    iv-ins-#open 1- dup 0=  ( final close? )\n"
"    IF  all.off: self\n"
"        free: self\n"
"    THEN\n"
"    0 max iv=> iv-ins-#open\n"
"    self iv-ins-close-cfa if.exec|drop\n"
";M\n"
"\n"
":M PRINT: ( -- )\n"
"    cr name: self cr\n"
"    print: super\n"
"    .\" Open Function  = \" iv-ins-open-cfa cfa. cr\n"
"    .\" On Function    = \" iv-ins-on-cfa cfa. cr\n"
"    .\" Off Function   = \" iv-ins-off-cfa cfa. cr\n"
"    .\" Close Function = \" iv-ins-close-cfa cfa. cr\n"
"    .\" Channel Range  = \" iv-ins-chan-lo . iv-ins-chan-hi . cr\n"
"    .\" Channel        = \" iv-ins-channel . cr\n"
"    .\" Tuning         = \" iv-ins-tuning ob.name cr\n"
"    .\" Gamut          = \" iv-ins-gamut ob.name cr\n"
"    .\" Offset         = \" iv-ins-offset . cr\n"
"    .\" # Times Opened = \" iv-ins-#open . cr\n"
"    .\" Mute           = \"\n"
"    iv-ins-mute IF .\" ON!!!\" ELSE .\" off\" THEN cr\n"
"    .\" Preset        = \" iv-ins-preset . cr\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"defer DEFAULT.INSTRUMENT   ( use for device independant pieces )\n"
"\n";

const char* instrument_fth = (const char*) temp_binary_data_30;

//================== interpreters.fth ==================
static const unsigned char temp_binary_data_31[] =
"\\ Some generic interpreters for processing shapes.\n"
"\\\n"
"\\ All interpreters must have the following stack diagram:\n"
"\\     ( elment_number shape instrument -- )\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"\\ MOD: PLB 3/26/90 Moved in INTERP.EL.ON\n"
"\\ MOD: PLB 10/24/91 Take advantage of new binding to locals.\n"
"\n"
"ANEW TASK-INTERPRETERS\n"
"\n"
": STANDARD.DIM.NAMES ( shape -- , name dimensions )\n"
"    >r ( save on return stack )\n"
"    \" Duration\" 0 r@ put.dim.name: []\n"
"    \" Note\" 1 r@ put.dim.name: []\n"
"    \" Loudness\" 2 r@ put.dim.name: []\n"
"    rdrop\n"
";\n"
"\n"
": INTERP.EXTRACT.PV { elmnt# shape -- pitch velocity }\n"
"    elmnt# 1 ed.at: shape ( get pitch )\n"
"    dimension: shape  2 >  ( is there a dimension 2 )\n"
"    IF ( -- pitch )\n"
"        elmnt# 2 ed.at: shape  ( get velocity )\n"
"    ELSE 64  ( default MIDI velocity )\n"
"    THEN\n"
";\n"
"\n"
"\\ Simple interpreter --------------------------------\n"
": INTERP.EL.ON ( elmnt# shape instr -- , play as note )\n"
"    >r interp.extract.pv\n"
"    over 0=   ( is this a rest? )\n"
"    IF rdrop 2drop\n"
"    ELSE r> note.on: []\n"
"    THEN\n"
";\n"
"\n"
"\\ This OFF interpreter can leave notes hanging if the\n"
"\\ shape changes between NOTE.ON: and NOTE.OFF:\n"
": INTERP.EL.OFF ( elmnt# shape instr -- )\n"
"    >r interp.extract.pv\n"
"    over 0=   ( is this a rest? )\n"
"    IF rdrop 2drop\n"
"    ELSE r> note.off: []\n"
"    THEN\n"
";\n"
"\n"
"\\ This OFF interpreter works best for random notes on\n"
"\\ or when a shape is changing frequently.\n"
": INTERP.LAST.OFF ( elmnt# shape instr -- , off last note played)\n"
"    >r interp.extract.pv\n"
"    drop 0=   ( Was it a rest? )\n"
"    IF rdrop\n"
"    ELSE r> LAST.NOTE.OFF: []\n"
"    THEN\n"
";\n"
"\n"
": INTERP.FIRST.OFF ( elmnt# shape instr -- )\n"
"    >r interp.extract.pv\n"
"    drop 0=   ( Was it a rest? )\n"
"    IF rdrop\n"
"    ELSE r> FIRST.NOTE.OFF: []\n"
"    THEN\n"
";\n"
"\n"
": USE.STANDARD.INTERP ( instrument -- )\n"
"    'c interp.el.on over put.on.function: []\n"
"    'c interp.first.off swap put.off.function: []\n"
";\n"
"\n"
"\\ This interpreter uses NOTE.ON.FOR: which\n"
"\\ allows the playing of polyphonic shapes.\n"
"\\ It uses ON.TIME which is set by player.\n"
"\\ Dim 0 = ?\n"
"\\ Dim 1 = note-index\n"
"\\ Dim 2 = velocity\n"
"\n"
": INTERP.EL.ON.FOR { elmnt# shape instr -- , on for time }\n"
"    elmnt# shape interp.extract.pv\n"
"    over 0=   ( is this a rest? )\n"
"    IF 2drop\n"
"    ELSE ( -- note vel )\n"
"        on.time  ( from player )\n"
"        note.on.for: instr\n"
"    THEN\n"
";\n"
"\n"
"'c interp.el.on.for is default.on.interp\n"
"'c 3drop is default.off.interp\n"
"\n"
": USE.POLY.INTERP  ( instrument -- )\n"
"    'c interp.el.on.for over put.on.function: []\n"
"    'c 3drop swap put.off.function: []\n"
";\n"
"\n"
"\\ Support word for next interpreter.\n"
": 2P.STOP.MORPH  ( morph data -- )\n"
"    drop stop: []\n"
";\n"
"\n"
"\\ Turn on and off Morphs listed in a shape.\n"
"\\ Dim 0 = time\n"
"\\ Dim 1 = morph\n"
"\\ Dim 2 = #repeats if positive  , ignored if <= 0\n"
"\\ also #ticks if on.time positive    , ignored if <= 0\n"
"\n"
": INTERP.PLAY.MORPH  { elmnt# shape instr | morph -- , play morph }\n"
"\\ Get morph from dimension 1\n"
"    elmnt# 1 ed.at: shape -> morph\n"
"\\\n"
"\\ Set repeat count if > 0\n"
"    elmnt# 2 ed.at: shape dup 0>  ( is #repeats pos. )\n"
"    IF put.repeat: morph\n"
"    ELSE drop\n"
"    THEN\n"
"    start: morph\n"
"\\\n"
"\\ Check to see if time is limited.\n"
"    on.time dup 0>\n"
"    IF  vtime@ +  ( calc time to stop )\n"
"\\ schedule STOP: event\n"
"        morph 0   'c 2p.stop.morph   post.event\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": PRINT.MORPH.SHAPE  { shape -- }\n"
"    >newline\n"
"    .\"   Time  Morph   Repeats  On.Time\" cr\n"
"    shape many: [] 0\n"
"    ?DO i 0 shape ed.at: [] 6 .r 2 spaces\n"
"       i 1 shape ed.at: [] name: [] 2 spaces\n"
"       i 2 shape ed.at: [] 6 .r 2 spaces\n"
"       shape dimension: [] 3 >\n"
"       IF i 3 shape ed.at: [] 6 .r\n"
"       THEN cr\n"
"    LOOP\n"
";\n"
"       \n"
"\\ Execute functions and data in shape.\n"
"\\ The shape must have as many data dimensions\n"
"\\ as the functions will eat.\n"
"\\ Dim 0 = time\n"
"\\ Dim 1 = data_1\n"
"\\ Dim 2 = data_2\n"
"\\ Dim n = data_n\n"
"\\ Dim n+1 = CFA\n"
"\\\n"
"\\ The function must have the following stack diagram.\n"
"\\      ( data_1 ... data_n -- )\n"
"\\\n"
": INTERP.EXECUTE  ( elmnt# shape instr -- , exec func )\n"
"    drop get: [] execute drop\n"
";\n"
"\n"
": PRINT.EXEC.SHAPE  { shape -- , print one of these shapes }\n"
"    >newline\n"
"    shape many: [] 0\n"
"    ?DO shape dimension: [] 1- 0\n"
"       ?DO j i shape ed.at: [] 6 .r 2 spaces\n"
"       LOOP\n"
"       i shape dimension: [] 1- shape ed.at: [] cfa. cr\n"
"    LOOP\n"
";\n"
"\n";

const char* interpreters_fth = (const char*) temp_binary_data_31;

//================== job.fth ==================
static const unsigned char temp_binary_data_32[] =
"\\ This Morph provides a simple container for\n"
"\\ functions that need to be tasked in a pseudo-multitasking\n"
"\\ environment.\n"
"\\\n"
"\\ Each function is passed the job's address\n"
"\\ which provides access to the duration, the done\n"
"\\ flag, the instrument, etc.\n"
"\\\n"
"\\ ( job_addr -- , stack diagram for a job function.)\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 5/23/87 Added STOP:\n"
"\\ MOD: PLB 6/1/87 Changed STACK for JOBs. Add SET.DONE:\n"
"\\ MOD: PLB 6/15/87 Add DEFAULT:\n"
"\\ MOD: PLB 7/22/87 Add SEND.DONE: to TASK:\n"
"\\ MOD: PLB 10/7/87 Fix repeat count handling in TASK:\n"
"\\ MOD: PLB 10/22/87 FREE instrument in hierarchy.\n"
"\\ MOD: PLB 2/18/89 Don't use RTC.RATE@ to set TOO-LATE.\n"
"\\ MOD: PLB 5/24/89 Change to new design.\n"
"\\ MOD: PLB 2/27/90 Moved BUILD: from Player\n"
"\\ MOD: PLB 4/5/90 Rewrote STOP code\n"
"\\ 00001 PLB 12/4/91 Moved DONE check before execution of function\n"
"\\   of functions.  Check stack for depth changes.\n"
"\n"
"ANEW TASK-JOB\n"
"\n"
"METHOD PUT.DURATION:        METHOD GET.DURATION:\n"
"METHOD PUT.INSTRUMENT:      METHOD GET.INSTRUMENT:\n"
"METHOD USE.DURATIONAL:      METHOD USE.EPOCHAL:\n"
"METHOD PUT.TOO.LATE:        METHOD GET.TOO.LATE:\n"
"\n"
":CLASS OB.JOB <SUPER OB.PRODUCTION\n"
"    IV.LONG  IV-JB-DURATION\n"
"    IV.LONG  IV-JB-INSTRUMENT\n"
"    IV.SHORT IV-JB-EPOCHAL?   ( Use epochal scheduling? )\n"
"    IV.LONG  IV-JB-TOO-LATE   ( When too late to play an element )\n"
"\n"
":M DEFAULT: ( -- )\n"
"    default: super\n"
"    0 iv=> iv-jb-instrument\n"
"    1 iv=> iv-jb-duration\n"
"    true iv=> iv-jb-epochal?\n"
"\\ If more than five minutes late, forget it. Based on 60 hz clock.\n"
"    rtc.rate@ 300 * iv=> iv-jb-too-late\n"
";M\n"
"\n"
":M DEFAULT.HIERARCHY: ( -- , reset instrument too )\n"
"    iv-jb-instrument ?dup\n"
"    IF default: []\n"
"    THEN\n"
"    default.hierarchy: super\n"
";M\n"
"\n"
":M FREE.HIERARCHY: ( -- , free instrument too )\n"
"    iv-jb-instrument ?dup\n"
"    IF free: []\n"
"    THEN\n"
"    free.hierarchy: super\n"
";M\n"
"\n"
":M PUT.INSTRUMENT: ( instrument -- )\n"
"    iv=> iv-jb-instrument\n"
";M\n"
"\n"
":M GET.INSTRUMENT: ( -- instrument)\n"
"    iv-jb-instrument\n"
";M\n"
"\n"
":M PUT.DURATION: ( duration -- )\n"
"    iv=> iv-jb-duration\n"
";M\n"
"\n"
":M GET.DURATION: ( -- duration)\n"
"    iv-jb-duration\n"
";M\n"
"\n"
":M USE.EPOCHAL:  ( -- , Use epoch for scheduling )\n"
"    true iv=> iv-jb-epochal?\n"
";M\n"
":M USE.DURATIONAL:  ( -- , Use duration for scheduling )\n"
"    false iv=> iv-jb-epochal?\n"
";M\n"
"\n"
":M PUT.TOO.LATE: ( #ticks -- , set max allowed lateness )\n"
"    iv=> iv-jb-too-late\n"
";M\n"
":M GET.TOO.LATE: ( -- #ticks, fetch max allowed lateness )\n"
"    iv-jb-too-late\n"
";M\n"
"\n"
": JB.SET.DELAY ( delay -- , set timenext to delay )\n"
"    iv-jb-epochal?\n"
"    IF ?dup  ( non-zero delay? )\n"
"       IF iv+> iv-time-next\n"
"       ELSE time@ iv=> iv-time-next  ( advance timenext anyway !!!)\n"
"       THEN\n"
"    ELSE time@ + iv=> iv-time-next\n"
"    THEN\n"
";\n"
"\n"
": JB.IN.TIME?  ( -- if_not_too_late , are we outside window? )\n"
"   iv-jb-epochal?\n"
"   IF iv-time-next iv-jb-too-late + time@ time>\n"
"   ELSE true\n"
"   THEN\n"
";\n"
"\n"
":M CUSTOM.EXEC: ( -- false )\n"
"    many: self 0>\n"
"    IF\n"
"        false iv=> iv-col-done?\n"
"        iv-jb-instrument ?dup\n"
"        IF open: []\n"
"        THEN\n"
"        self ao.post false\n"
"    ELSE\n"
"        vtime@ true\n"
"    THEN\n"
";M\n"
"\n"
": JOB.STOP  ( -- , stop job , don't send DONE )\n"
"    iv-time-next vtime!  ( set vtime so note OFFS are not before ON )\n"
"    iv-jb-instrument ?dup\n"
"    IF close: []\n"
"    THEN\n"
"    self ao.unpost\n"
";\n"
"\n"
":M TERMINATE: ( time -- , stop tasking )\n"
"    iv-if-active\n"
"    IF  job.stop\n"
"        morph.stop\n"
"    ELSE drop\n"
"    THEN\n"
";M\n"
"\n"
": JOB.EXEC.STUFF ( -- , execute job's functions )\n"
"    jb.in.time?  ( is it too late? )\n"
"    IF  ( -- done? default_dur self )\n"
"        depth >r\n"
"        reset: self\n"
"        BEGIN manyleft: self\n"
"        WHILE self next: self execute\n"
"        REPEAT\n"
"        depth r> = not\n"
"        IF\n"
"            \" TASK:\" \" Stack error in job function\"\n"
"                er_fatal ob.report.error\n"
"        THEN\n"
"    THEN\n"
"    iv-jb-duration jb.set.delay\n"
";\n"
"\n"
":M TASK: ( -- , perform jobs if time )\n"
"\\ This used to be after the next block but was moved here so that\n"
"\\ jobs will always wait their duration before terminating or repeating.\n"
"\\ Check for done? , repeat if counts left. 00001\n"
"\\\n"
"    iv-time-next doitnow?\n"
"    IF\n"
"        iv-col-done?\n"
"        IF\n"
"            col.do.repeat iv-repcount 0=\n"
"            IF\n"
"                iv-time-next self terminate: []\n"
"            ELSE\n"
"                false iv=> iv-col-done?\n"
"                iv-time-next doitnow?   \\ in case of repeat delay\n"
"                IF\n"
"                    job.exec.stuff\n"
"                THEN\n"
"            THEN\n"
"        ELSE\n"
"            job.exec.stuff\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M PRINT: ( -- )\n"
"    print: super ?pause\n"
"    .\" Instrument    = \" iv-jb-instrument ob.name cr\n"
"    iv-jb-epochal?\n"
"    IF .\" Epochal scheduling.\" cr\n"
"       .\" Too late window = \" iv-jb-too-late . cr\n"
"    ELSE .\" Durational scheduling.\" cr\n"
"    THEN ?pause\n"
"    .\" Duration = \" iv-jb-duration . cr\n"
";M\n"
"\n"
":M BUILD:  ( shape instrument -- )\n"
"    put.instrument: self\n"
"    1 new: self\n"
"    add: self\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"if-testing @ [IF]\n"
"\n"
": TEST.JOB ( job -- )\n"
"    100 choose 50 + swap put.duration: [] ( set new duration )\n"
"   .\" Yowzah\" cr\n"
";\n"
"\n"
"OB.JOB JOB-T\n"
"2 new: job-t\n"
"\n"
"'c test.job add: job-t\n"
"\n"
"[THEN]\n";

const char* job_fth = (const char*) temp_binary_data_32;

//================== load_hmsl.fth ==================
static const unsigned char temp_binary_data_33[] =
"\\ $Id$\n"
"\\ LOAD HMSL\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"ANEW TASK-LOAD_HMSL\n"
"\n"
"false constant HOST=AMIGA\n"
"true constant HOST=MAC\n"
"\n"
": '  ( <name> -- cfa , warn me if used the wrong way )\n"
"    state @\n"
"    IF\n"
"        .\" ' used! ====================\" cr\n"
"        source type cr\n"
"        .\" ============================\" cr\n"
"        postpone '\n"
"    ELSE\n"
"        '\n"
"    THEN\n"
"; immediate\n"
"\n"
"include? task-stubs fth/stubs.fth\n"
"\n"
": [NEED] ( <name> -- start compiling if not found )\n"
"    postpone exists? not postpone [IF]\n"
";\n"
"\n"
"\\ Decide whether to compile different parts of HMSL.\n"
"[need] IF-LOAD-MIDI\n"
"variable IF-LOAD-MIDI\n"
"variable IF-LOAD-ACTIONS\n"
"variable IF-LOAD-MORPHS\n"
"variable IF-LOAD-GRAPHICS\n"
"variable IF-LOAD-SHAPE-ED\n"
"variable IF-LOAD-DEMO\n"
"if-load-demo off\n"
"[THEN]\n"
"\n"
"\\ SET THESE VARIABLES TO CONTROL WHAT GETS LOADED!!!!\n"
"TRUE if-load-midi !\n"
"TRUE if-load-morphs !\n"
"TRUE if-load-actions !    ( perform screen )\n"
"TRUE if-load-graphics !\n"
"if-load-morphs @ if-load-shape-ed !\n"
"\n"
"if-load-midi @ 0= [IF] .\" Not loading MIDI support!\" cr [THEN]\n"
"if-load-actions @ 0= [IF] .\" Not loading Actions or Perform Screen!\" cr [THEN]\n"
"if-load-graphics @ 0= [IF] .\" Not loading Graphics Support\" cr [THEN]\n"
"if-load-shape-ed @ 0= [IF] .\" Not loading Shape Editor\" cr [THEN]\n"
"\n"
"\\ Start of cascaded initialization and termination.\n"
"exists? SYS.INIT not [if]\n"
"    : SYS.INIT ;\n"
"    : SYS.TERM ;\n"
"    : SYS.RESET ;\n"
"[THEN]\n"
"\n"
"exists?  SYS.CLEANUP not [if]\n"
"    : SYS.CLEANUP ; \\ less severe then SYS.RESET\n"
"    : SYS.START ;\n"
"    : SYS.STOP ;\n"
"    : SYS.TASK ;\n"
"[THEN]\n"
"\n"
"exists? SYS.STATUS not [if]\n"
"    : SYS.STATUS >newline ;\n"
"[THEN]\n"
"\n"
"include? within?                fth/p4thbase.fth\n"
"include? toupper                fth/charmacr.fth\n"
"\n"
"include? task-misc_tools        fth/misc_tools.fth\n"
"include? task-utils             fth/utils.fth\n"
"include? stack.header           fth/stacks.fth\n"
"\n"
"include? task-errormsg          fth/errormsg.fth\n"
"include? task-memalloc          fth/memalloc.fth\n"
"include? task-cond_comp         fth/cond_comp.fth\n"
"\n"
"include? task-global_data       fth/global_data.fth\n"
"include? task-service_tasks     fth/service_tasks.fth\n"
"include? task-float_port        fth/float_port.fth\n"
"\n"
"\\ MIDI and Time support-------------------------------\n"
"if-load-midi @ [IF]\n"
"  include? task-midi_globals fth/midi_globals.fth\n"
"  include? task-time fth/time.fth\n"
"  include? task-midi fth/midi.fth\n"
"  include? task-midi_parser fth/midi_parser.fth\n"
"  include? task-midi_text fth/midi_text.fth\n"
"[ELSE]\n"
"  include? task-midi_stubs fth/midi_stubs.fth\n"
"[THEN]\n"
"\n"
"\\\n"
"\\ Object Oriented Code -------------------------\n"
"include? task-ob_stack fth/ob_stack.fth\n"
"include? task-ob_main fth/ob_main.fth\n"
"include? task-ob_bind fth/ob_bind.fth\n"
"include? task-obmethod fth/obmethod.fth\n"
"mreset-warn off\n"
"include? task-ob_ivars fth/ob_ivars.fth\n"
"include? task-dbl_list fth/dbl_list.fth\n"
"include? task-obobject fth/obobject.fth\n"
"include? task-ob_array fth/ob_array.fth\n"
"include? task-elmnts fth/elmnts.fth\n"
"include? task-ob_dlist fth/ob_dlist.fth\n"
"\n"
"\\ Support for interactive screens\n"
"if-load-graphics @ [IF]\n"
"  include? task-graphics fth/graphics.fth\n"
"  include? task-graph_util fth/graph_util.fth\n"
"  include? task-scg fth/scg.fth\n"
"  include? task-bevel fth/bevel.fth\n"
"  include? task-control fth/control.fth\n"
"  include? task-ctrl_count fth/ctrl_count.fth\n"
"  include? task-ctrl_numeric fth/ctrl_numeric.fth\n"
"  include? task-ctrl_fader fth/ctrl_fader.fth\n"
"  include? task-screen fth/screen.fth\n"
"  include? task-ctrl_text fth/ctrl_text.fth\n"
"  include? task-popup_text fth/popup_text.fth\n"
"[THEN]\n"
"\n"
"\\ HMSL Music Morphs\n"
"if-load-morphs @ [IF]\n"
"include? task-morph_lists fth/morph_lists.fth\n"
"include? task-morph fth/morph.fth\n"
"include? task-actobj fth/actobj.fth\n"
"include? task-collection fth/collection.fth\n"
"include? task-shape fth/shape.fth\n"
"include? task-structure fth/structure.fth\n"
"include? task-production fth/production.fth\n"
"include? task-event_list fth/event_list.fth\n"
"include? task-allocator fth/allocator.fth\n"
"include? task-translators fth/translators.fth\n"
"include? task-instrument fth/instrument.fth\n"
"if-load-midi @ [IF]\n"
"include? task-midi_instrument fth/midi_instrument.fth\n"
"[THEN]\n"
"include? task-job fth/job.fth\n"
"include? task-player fth/player.fth\n"
"include? task-interpreters fth/interpreters.fth\n"
"[THEN]\n"
"\n"
"\\ Some predefined morphs.\n"
"if-load-morphs @ [IF]\n"
"include? task-stock_morphs fth/stock_morphs.fth\n"
"[THEN]\n"
"\n"
"if-load-graphics @ [IF]\n"
"include? task-build_menus fth/build_menus.fth\n"
"[THEN]\n"
"\n"
"if-load-demo @ 0= if-load-morphs @ and [IF]\n"
"include? task-record fth/record.fth\n"
"include? task-packed_midi fth/packed_midi.fth\n"
"[THEN]\n"
"\n"
"include? task-top fth/top.fth\n"
"\n"
"\\ include? task-set_vectors fth/set_vectors.fth\n"
"include? task-hmsl_version fth/hmsl_version.fth\n"
"include? task-hmsl_top fth/hmsl_top.fth\n"
"include? task-startup fth/startup.fth\n"
"\n"
"\n"
"\\ Editors in screen are loaded on top of the regular HMSL\n"
"if-load-graphics @   if-load-shape-ed @ AND [IF]\n"
"    include? task-shape_editor fth/shape_editor.fth\n"
"[THEN]\n"
"\n"
"\\ Load actions by Larry Polansky ,  \"PERFORM\" module\n"
"if-load-graphics @ if-load-actions @ AND [IF]\n"
"    include? task-action_utils fth/action_utils.fth\n"
"    include? task-ob_actions fth/ob_actions.fth\n"
"    include? task-test_actions fth/test_actions.fth\n"
"    include? task-action_table fth/action_table.fth\n"
"    include? task-action_screen fth/action_screen.fth\n"
"    include? task-action_top fth/action_top.fth\n"
"[THEN]\n"
"\n"
"\\ load some tools\n"
"include? file_port tools/file_port.fth\n"
"include? task-midifile tools/midifile.fth\n"
"include? task-markov_chain tools/markov_chain.fth\n"
"include? task-score_entry tools/score_entry.fth\n"
"\n"
"mreset-warn on\n"
"cr .\" HMSL compilation finished.\" cr\n"
"map\n"
"\n"
"ANEW SESSION\n"
"\n";

const char* load_hmsl_fth = (const char*) temp_binary_data_33;

//================== load_ode.fth ==================
static const unsigned char temp_binary_data_34[] =
"\\ @(#) load_ode.fth 96/06/11 1.1\n"
"\\ LOAD ODE - Object Development Environment\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"\\ Start of cascaded initialization and termination.\n"
"exists? SYS.INIT not [if] \n"
"    : SYS.INIT ;\n"
"    : SYS.TERM ;\n"
"    : SYS.RESET ;\n"
"[THEN]\n"
"\n"
"exists?  SYS.CLEANUP not [if]\n"
"    : SYS.CLEANUP ; \\ less severe then SYS.RESET\n"
"    : SYS.START ;\n"
"    : SYS.STOP ;\n"
"    : SYS.TASK ;\n"
"[THEN]\n"
"\n"
"exists? SYS.STATUS not [if]\n"
"    : SYS.STATUS >newline ;\n"
"[THEN]\n"
"\n"
"include? within?            p4thbase.fth\n"
"include? toupper            charmacr.fth\n"
"include? task-utils utils.fth\n"
"\n"
"include? task-errormsg errormsg.fth\n"
"include? task-memalloc memalloc.fth\n"
"\n"
"\n"
"include? task-global_data h:global_data.fth\n"
"\n"
"\\ MIDI and Time support-------------------------------\n"
"if-load-midi @ .IF\n"
"    include? task-midi_globals h:midi_globals\n"
".THEN\n"
"\n"
"\\\n"
"\\ Object Oriented Code -------------------------\n"
"include? task-ob_stack ob_stack.fth\n"
"include? task-ob_main ob_main.fth\n"
"include? task-ob_bind ob_bind.fth\n"
"include? task-obmethod obmethod.fth\n"
"mreset-warn off\n"
"include? task-ob_ivars ob_ivars.fth\n"
"include? task-dbl_list dbl_list.fth\n"
"include? task-obobject obobject.fth\n"
"include? task-ob_array ob_array.fth\n"
"include? task-elmnts elmnts.fth\n"
"include? task-ob_dlist ob_dlist.fth\n"
"\n";

const char* load_ode_fth = (const char*) temp_binary_data_34;

//================== make_hmsl.fth ==================
static const unsigned char temp_binary_data_35[] =
"\\ %Z% %M% %E% %I%\n"
"\\ make_hmsl.fth\n"
"\\ Create HMSL dictionary\n"
"\n"
"echo off\n"
"\n"
"include fth/load_hmsl.fth\n"
"\n"
"\\ Do not execute auto.init chain if stack is large.\n"
"\\ This is a hack so that SAVE-FORTH won't trigger HMSL.INIT,\n"
"\\ which asks the user Y/N, which messes up the XCode build script.\n"
"\\ We have to block this using the stack because if\n"
"\\ we used a variable, the variable value would get saved in the dictionary\n"
"\\ preventing HMSL.INIT when HMSL was run.\n"
": AUTO.INIT ( -- )\n"
"    depth 4 > IF\n"
"        .\" AUTO.INIT disabled because DEPTH > 4.\" cr\n"
"        .S\n"
"\tELSE\n"
"        auto.init\n"
"    THEN\n"
";\n"
"\n"
".\" Block AUTO.INIT that is called by SAVE-FORTH\" cr\n"
"1 2 3 4 5 6\n"
"c\" pforth.dic\" save-forth\n"
"6 0 DO drop LOOP\n";

const char* make_hmsl_fth = (const char*) temp_binary_data_35;

//================== memalloc.fth ==================
static const unsigned char temp_binary_data_36[] =
"\\ @(#) memalloc.fth 96/06/11 1.1\n"
"\\ ------------------------------------------------------\n"
"\\\n"
"\\ ANSI based memory allocator\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 Phil Burk, Larry Polansky, David Rosenboom\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ Created 8/20/86\n"
"\\ MOD: PLB 10/20/86 Separated from AJF_RTC\n"
"\\ MOD: PLB 2/3/96 Convert to ANSI\n"
"\\\n"
"\\ -------------------------------------------------------\n"
"\n"
"ANEW TASK-MEMALLOC\n"
"\n"
"\\ -------------------------------------------------------\n"
"\\ Host Independant Memory Manager\n"
"\\\n"
"\n"
"\\ -------------------------------------------------------\n"
"\\ Memory Manager\n"
"\n"
": MM.ALLOC?  ( numbytes -- address | 0, allocate bytes) \n"
"    allocate drop\n"
";\n"
": MM.ALLOC  ( numbytes -- address , allocate bytes) \n"
"    allocate abort\" MM.ALLOC - Not enough memory!!!\"\n"
";\n"
"\n"
": MM.ZALLOC? ( numbytes -- address | 0, allocate and zero out memory )\n"
"    dup mm.alloc? dup\n"
"    IF dup rot 0 fill\n"
"    ELSE nip\n"
"    THEN\n"
";\n"
"\n"
": MM.ZALLOC ( numbytes -- address , allocate and zero out memory )\n"
"    dup mm.alloc\n"
"    dup rot 0 fill\n"
";\n"
"\n"
": MM.FREE ( address -- , free allocated memory )\n"
"    free abort\" MM.FREE - already freed!\"\n"
";\n";

const char* memalloc_fth = (const char*) temp_binary_data_36;

//================== midi.fth ==================
static const unsigned char temp_binary_data_37[] =
"\\ Host Independant MIDI Support\n"
"\\ This module requires host dependant words\n"
"\\ for MIDI.XMIT , MIDI.RECV , MIDI.SER.INIT , MIDI.SER.TERM\n"
"\\ MIDI.FLUSH , MIDI.RECV? , MIDI.#RECV?\n"
"\\\n"
"\\ This code was originally developed as part of HMSL,\n"
"\\ an experimental music language for Mills College.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: Test channel voice message to avoid sending unnecessary data.\n"
"\\ MOD: PLB 10/9/86 Fixed CVM for different channels.\n"
"\\                  Added range check for MIDI.CHANNEL!\n"
"\\ MOD: PLB 12/4/86 Moved MIDI.INIT from host file.\n"
"\\ MOD: PLB 12/9/86 Fixed MIDI.SCOPE names.\n"
"\\ MOD: PLB 12/21/86 Added tracking of last notes, OPT option\n"
"\\ MOD: PLB 3/3/87 Use WARNING\" in MIDI.CHANNEL! , V: to VARIABLE\n"
"\\ MOD: PLB 5/24/87 Add MIDI.CLEAR\n"
"\\ MOD: PLB 8/14/87 Set HI & LOW in MIDI.WALK for Mac.\n"
"\\ MOD: PLB 10/22/87 Add MIDI.RECALL.PRESET and MIDI.RECALL.BEND\n"
"\\                  Add PROGRAM synonyms for PRESET\n"
"\\ MOD: PLB 2/19/89 Add 7 bit packing words, improve MIDI.SCOPE\n"
"\\ MOD: PLB 3/30/89 Change 7LO7HI words to hex numbers, fix.\n"
"\\ MOD: PLB 4/24/89 Fix stack error in MIDI.PRESSURE\n"
"\\ MOD: PLB 8/28/89 MIDI.TEST - set back to channel 1.\n"
"\\ MOD: PLB 11/16/89 Add MIDI.PANIC\n"
"\\ MOD: PLB 12/6/89 Speed up MIDI.SCOPE\n"
"\\ MOD: PLB 3/12/90 Add MIDI.KEY & MIDI.GET.BYTE\n"
"\\ MOD: PLB 4/14/90 Add MIDI.PITCH.BEND\n"
"\\ MOD: PLB 7/18/90 Put TAB in MIDI.SCOPE\n"
"\\ MOD: PLB 10/29/90 Change MIDI.TEST\n"
"\\ MOD: PLB 5/21/91 Add MIDI.NORMALIZE\n"
"\\ MOD: PLB 8/8/91 Moved Running Status Optimization to lowest level\n"
"\\               so that it will work with event buffering.\n"
"\\               Make MIDI.LASTOFF use 0 OFF to allow optimization.\n"
"\n"
"include? msec ju:msec\n"
"include? choose ju:random\n"
"\n"
"ANEW TASK-MIDI\n"
"decimal\n"
"VARIABLE MIDI-CHANNEL  ( current channel )\n"
"VARIABLE MIDI-LASTCVM  ( last channel voice message )\n"
"\n"
": MIDI.CHANNEL!  ( channel -- , sets channel for midi output )\n"
"\\ One word for vectored voice setting.\n"
"    dup 1 16 within?\n"
"    IF  midi-channel !\n"
"    ELSE true\n"
"        warning\" MIDI.CHANNEL! - Channel number out of range! = \" . cr\n"
"    THEN\n"
";\n"
"\n"
": MIDI.ORCH  ( status -- status+channel )\n"
"     midi-channel @ 1- or\n"
";\n"
"HEX\n"
": MIDI.DATA.XMIT ( data -- , send valid data )\n"
"     7F AND midi.xmit\n"
";\n"
"\n"
": MIDI.CVM  (  status-byte -- , send channel voice message  )\n"
"    midi.orch midi.xmit\n"
";\n"
"\n"
": MIDI.CVM+1D ( data st -- , send cvm + 1 data byte  )\n"
"     midi.cvm\n"
"     midi.data.xmit   midi.flush\n"
";\n"
"\n"
": MIDI.CVM+2D  (  data1 data2 st -- , send cvm + 2 data bytes )\n"
"     midi.cvm swap\n"
"     midi.data.xmit  midi.data.xmit\n"
"     midi.flush\n"
";\n"
"\n"
": MIDI.CVM+3D  (  data1 data2 data3 st -- , send cvm + 3 data bytes )\n"
"     midi.cvm\n"
"     >r >r midi.data.xmit\n"
"     r> midi.data.xmit\n"
"     r> midi.data.xmit\n"
"     midi.flush\n"
";\n"
"\n"
"\\ MIDI requires you to turn off any note that you turn on.\n"
"\\ To make this easier we will keep track of the last note for\n"
"\\ each channel.  This works best with multiple monophonic channels.\n"
"CREATE MIDI-LAST-NOTES 12 ALLOT  ( HEX , allow room for 1-16 offset )\n"
"CREATE MIDI-LAST-VELS  12 ALLOT\n"
"CREATE MIDI-LAST-PROGRAMS 12 ALLOT\n"
"CREATE MIDI-LAST-BENDS 24 ALLOT  ( word wide )\n"
"\n"
": MIDI.TRACK.NOTE  ( note -- , Store note for channel )\n"
"    midi-channel @ midi-last-notes + c!\n"
";\n"
": MIDI.TRACK.VEL  ( vel -- , Store velocity for channel for crescendos )\n"
"    midi-channel @ midi-last-vels + c!\n"
";\n"
": MIDI.TRACK.PROGRAM  ( program -- , Store program for channel.)\n"
"    midi-channel @ midi-last-programs + c!\n"
";\n"
": MIDI.TRACK.BEND  ( bend -- , Store bend for channel.)\n"
"    midi-channel @ 2* midi-last-bends + w!\n"
";\n"
"\n"
": MIDI.RECALL.NOTE  ( -- note , Recall note for channel )\n"
"    midi-channel @ midi-last-notes + c@\n"
";\n"
": MIDI.RECALL.VEL  ( -- vel , Recall velocity for channel for crescendos )\n"
"    midi-channel @ midi-last-vels + c@\n"
";\n"
": MIDI.RECALL.PROGRAM  ( -- preset , Recall program for channel.)\n"
"    midi-channel @ midi-last-programs + c@\n"
";\n"
": MIDI.RECALL.PRESET  ( -- preset , Recall preset for channel.)\n"
"    midi.recall.program\n"
";\n"
": MIDI.RECALL.BEND  ( -- bend , Recall bend for channel.)\n"
"    midi-channel @ 2* midi-last-bends + w@\n"
";\n"
"\n"
": MIDI.NOTEOFF  ( note vel -- , turn note off )\n"
"    80 midi.cvm+2d\n"
";\n"
"\n"
": MIDI.NOTEON  ( note vel -- turn on note  )\n"
"    2dup midi.track.vel midi.track.note\n"
"    90 midi.cvm+2D\n"
";\n"
"\n"
": MIDI.LASTOFF ( -- , turn off last note )\n"
"    midi.recall.note 0 midi.noteon \\ use zero velocity\n"
";\n"
"\n"
": MIDI.NOTE.PRESSURE  ( note pressure -- , set aftertouch for note )\n"
"\\ This command is rarely supported by synthesizers.\n"
"    A0 midi.cvm+2D\n"
";\n"
"\n"
"\\ MIDI CONTROL and related words. -----------------\n"
": MIDI.CONTROL  ( c# val -- , send control value )\n"
"    B0 midi.cvm+2D\n"
";\n"
"\n"
": MIDI.ALLOFF  (  -- , turn all notes off  )\n"
"    7B 00 midi.control\n"
";\n"
"\n"
": MIDI.LOCAL.ON ( -- , allow keyboard input )\n"
"    7A 7F midi.control\n"
";\n"
": MIDI.LOCAL.OFF ( -- , disallow keyboard input )\n"
"    7A 0  midi.control\n"
";\n"
"\n"
"\\ More MIDI Channel Voice Messages ----------------------\n"
": MIDI.PROGRAM  ( program -- , change program, range = 1...128 )\n"
"    dup midi.track.program\n"
"    1- C0 midi.cvm+1D\n"
";\n"
": MIDI.PRESET  ( preset -- , same as MIDI.PROGRAM )\n"
"    midi.program\n"
";\n"
"\n"
": MIDI.PRESSURE  ( pressure -- , set aftertouch for channel )\n"
"    D0 midi.cvm+1D\n"
";\n"
"\n"
": MIDI.BEND  ( raw-bend  -- , send pitch wheel change command )\n"
"    dup midi.track.bend\n"
"    dup 7 arshift E0 midi.cvm+2d\n"
";\n"
"\n"
": MIDI.PITCH.BEND ( +/-bend -- , 0 means no bend )\n"
"    $ 2000 + midi.bend\n"
";\n"
"\n"
"\\ These are for reorganizing binary data into forms\n"
"\\ suitable for MIDI transmission.\n"
": 14->7LO7HI  ( 14_bits -- lo7 hi7 )\n"
"    dup 7F and\n"
"    swap 7 arshift\n"
";\n"
"\n"
": 7LO7HI->14  ( lo7 hi7 -- 14_bits )\n"
"    7F and 7 lshift\n"
"    swap 7F and OR\n"
";\n"
"\n"
": BYTE->HILO ( byte -- hi lo )\n"
"    dup 4 rshift 0F and\n"
"    swap 0F and\n"
";\n"
"\n"
": HILO->BYTE ( hi lo -- byte )\n"
"    swap 4 lshift or\n"
";\n"
"\n"
": MIDI.XMIT.HILO ( byte -- , send as hi and lo nibbles )\n"
"    byte->hilo\n"
"    swap midi.xmit midi.xmit\n"
";\n"
"\n"
": MIDI.XMIT.LOHI ( byte -- , send as hi and lo nibbles )\n"
"    byte->hilo\n"
"    midi.xmit midi.xmit\n"
";\n"
"\\ Extract high bits from string.\n"
"\\ These are used for packing and unpacking 8 bit data into\n"
"\\ 7 bit data.\n"
": GET.HIGH.BITS ( addr count -- highbits )\n"
"    dup 7 > abort\" GET.HIGH.BITS > 7 !!\"\n"
"    0 swap 0\n"
"    ?DO ( addr accum ) 2*\n"
"        over i + c@ $ 80 and  ( -- addr accum 80/00 )\n"
"        IF 1 or\n"
"        THEN\n"
"    LOOP nip\n"
";\n"
"\n"
": PUT.HIGH.BITS ( addr count highbits -- )\n"
"    over 7 > abort\" PUT.HIGH.BITS > 7 !!\"\n"
"    over >r >r + 1-\n"
"    r> r> 0\n"
"    ?DO ( addr+i-1 highbits )\n"
"        dup 1 and\n"
"        IF ( addr highbits )\n"
"            over dup c@ $ 80 OR  ( -- addr high addr char )\n"
"            swap c!\n"
"        THEN 2/ swap 1- swap\n"
"    LOOP 2drop\n"
";\n"
"\n"
"\n"
": MIDI.START.SYSEX ( -- , send start SYSEX byte )\n"
"    midi.flush\n"
"    F0 midi.xmit\n"
";\n"
"\n"
": MIDI.END.SYSEX ( -- , stop SYSEX )\n"
"    F7 midi.xmit\n"
"    midi.flush\n"
";\n"
"\n"
"\\ System Common Messages - Sent to All Channels.\n"
": MIDI.COMMON ( status -- , Send status byte for Common Message)\n"
"    dup midi-lastcvm !  ( change default status )\n"
"    midi.xmit\n"
";\n"
"\n"
": MIDI.SONG.POINTER  ( position  -- , send Song Position Pointer)\n"
"     F2 midi.common\n"
"     dup 7 arshift E0\n"
"     swap midi.data.xmit\n"
"     midi.data.xmit midi.flush\n"
";\n"
"\n"
": MIDI.SONG.SELECT ( song# -- , send Song Select )\n"
"    F3 midi.common\n"
"    midi.data.xmit midi.flush\n"
";\n"
"\n"
"\\ MIDI Real Time Mesages - Sent to all channels.\n"
"\\ These do not interfere with running status.\n"
": MIDI.REAL.TIME ( byte -- , Send Real time messgae )\n"
"    midi.xmit midi.flush\n"
";\n"
"\n"
": MIDI.CLOCK ( -- , Send MIDI clock tick, BOGS THINGS DOWN! )\n"
"    F8 midi.real.time\n"
";\n"
"\n"
": MIDI.START ( -- , Start slave sequencers )\n"
"    FA midi.real.time\n"
";\n"
"\n"
": MIDI.CONTINUE ( -- , Continue after Stop )\n"
"    FB midi.real.time\n"
";\n"
"\n"
": MIDI.STOP ( -- , Stop slave sequencers )\n"
"    FC midi.real.time\n"
";\n"
"\n"
"\\ Virtual Time dependant tools --------------------------\n"
": MIDI.TIME@  ( -- time , advance time byte received )\n"
"    midi.rtc.time@ time-advance @ +\n"
";\n"
"\n"
"\\ Unclog Event Buffer by setting time to a high value.\n"
": MIDI.UNCLOG  ( -- , send all pending messages )\n"
"    rtc.time@\n"
"    -1 -1 shift 5000 - rtc.time!\n"
"    1000 msec\n"
"    rtc.time!\n"
";\n"
"\n"
": MIDI.NOTEON.AT  ( note vel time -- )\n"
"    midi.flush\n"
"    vtime!\n"
"    midi.noteon\n"
";\n"
"\n"
": MIDI.NOTEON.FOR  ( note vel ontime -- )\n"
"    midi.flush\n"
"    vtime@ >r >r\n"
"    midi.noteon r> vtime+! midi.lastoff\n"
"    r> vtime!\n"
";\n"
"\n"
": MIDI.NOTEON.LATER  ( note vel delta -- )\n"
"\\ turn on note relative to current real time\n"
"    rtc.time@ +\n"
"    midi.noteon.at\n"
";\n"
"\n"
"\\ MIDI control -----------------------------------\n"
"DECIMAL\n"
": MIDI.INIT  ( -- , Initialize MIDI system. )\n"
"    \" MIDI.INIT\" debug.type\n"
"    midi.ser.init\n"
"    -1 midi-lastcvm !\n"
"    16 0\n"
"    DO  i 1+ midi.channel!\n"
"        255 midi.track.note ( set to off )\n"
"        255 midi.track.vel\n"
"    LOOP\n"
"    1  midi.channel!\n"
";\n"
"\n"
": MIDI.TERM ( -- , Terminate MIDI system. )\n"
"    \" MIDI.TERM\" debug.type\n"
"    midi.ser.term\n"
";\n"
"\n"
"\\ For cascading initialization.\n"
": SYS.INIT sys.init midi.init ;\n"
": SYS.TERM midi.term sys.term ;\n"
"\n"
"\\ MIDI Utilities ---------------------------------\n"
"DECIMAL\n"
": MIDI.CZ.KILL  ( -- , Turn OFF notes on CZ-101 )\n"
"    midi.local.off   midi.local.on\n"
";\n"
"\n"
": MIDI.CZ.KILLALL  ( -- , Kill all channels on CZ-101 )\n"
"      midi-channel @  ( save )\n"
"      17 1 DO ( 16 channels )\n"
"         i midi.channel!\n"
"         midi.cz.kill\n"
"      LOOP\n"
"      midi.channel! ( restore )\n"
";\n"
"\n"
": MIDI.PANIC  ( -- , send allof to all 16 channels )\n"
"    midi-channel @\n"
"    17 1\n"
"    DO i midi.channel! midi.alloff\n"
"    LOOP\n"
"    midi.channel!\n"
";\n"
"\n"
": MIDI.NORMALIZE  ( -- , reset controllers on all channels )\n"
"    midi-channel @\n"
"    17 1\n"
"    DO\n"
"        i midi.channel!\n"
"        0 midi.pitch.bend  \\ zero out pitch bend\n"
"        7 127 midi.control  \\ full volume\n"
"        1 0 midi.control  \\ modulation wheel off\n"
"        5 0 midi.control  \\ portamento time\n"
"        64 0 midi.control \\ sustain pedal off\n"
"        65 0 midi.control \\ portamento off\n"
"        0 midi.pressure\n"
"    LOOP\n"
"    midi.channel!\n"
";\n"
": MIDI.KILL ( -- , Kill all notes on current channel )\n"
"\\ This is for use with devices that don't support MIDI.ALLOFF\n"
"      128 0 DO\n"
"        i 0 midi.noteoff\n"
"      LOOP\n"
";\n"
"\n"
": MIDI.KILLALL  ( -- , Kill all channels )\n"
"      midi-channel @  ( save )\n"
"      17 1 DO \n"
"         i midi-channel !\n"
"         midi.kill\n"
"      LOOP\n"
"      midi-channel ! ( restore )\n"
";\n"
"\n"
": MIDI.THRU ( -- , echo to output )\n"
"    BEGIN  8 0\n"
"        DO  midi.recv\n"
"            IF midi.xmit midi.flush\n"
"            THEN\n"
"        LOOP\n"
"        ?terminal\n"
"    UNTIL\n"
";\n"
"\n"
"HEX\n"
": MIDI.SYSDIS ( system_byte -- , display system message )\n"
"    dup 0F and\n"
"    CASE\n"
"      0 OF .\" SysEx\" ENDOF\n"
"      1 OF .\" MTC\" ENDOF\n"
"      2 OF .\" SongPos\" ENDOF\n"
"      3 OF .\" SongSel\" ENDOF\n"
"      6 OF .\" TuneReq\" ENDOF\n"
"      7 OF .\" EndSysEx\" ENDOF\n"
"      8 OF .\" Clock\" ENDOF\n"
"      A OF .\" Start\" ENDOF\n"
"      B OF .\" Continue\" ENDOF\n"
"      C OF .\" Stop\" ENDOF\n"
"      E OF .\" ActSens\" ENDOF\n"
"      F OF .\" Reset\" ENDOF\n"
"         .\" Undefined \" dup 3 .r\n"
"    ENDCASE\n"
"    drop\n"
";\n"
"\n"
": MIDI.CVMDIS ( cvm_byte -- , display name of command)\n"
"    tab\n"
"    dup F0 and F0 -  ( not a System Message? )\n"
"    IF  .\" /\"dup 0F and 1+ 1 .r  ( show channel )\n"
"    THEN\n"
"    .\" /\"\n"
"    dup F0 AND\n"
"    CASE\n"
"        80 OF .\" Off\" ENDOF\n"
"        90 OF .\" On\" ENDOF\n"
"        A0 OF .\" AfterNote\" ENDOF\n"
"        B0 OF .\" Control\" ENDOF\n"
"        C0 OF .\" Program\" ENDOF\n"
"        D0 OF .\" AfterChan\" Endof\n"
"        E0 OF .\" Bend\" ENDOF\n"
"        F0 OF dup midi.sysdis ENDOF\n"
"        dup 3 .r  ( others not yet named )\n"
"    ENDCASE\n"
"    .\" / \"\n"
"    drop\n"
";\n"
"\n"
": MIDI.SCOPE ( -- , Dump midi data to screen. )\n"
"    base @ cr\n"
"    .\" MIDI Scope - Hit any key to stop.\" cr\n"
"    .\" Channel/Command/Data\" cr\n"
"    BEGIN\n"
"        midi.recv\n"
"        IF dup 80 and\n"
"            IF midi.cvmdis\n"
"            ELSE 4 .r cr?\n"
"            THEN  flushemit\n"
"        THEN\n"
"        ?terminal\n"
"    UNTIL\n"
"    base !\n"
";    \n"
"\n"
": MIDI.MONITOR ( -- , Dump raw midi data to screen. )\n"
"    base @ hex cr\n"
"    .\" MIDI HEX Monitor - Hit any key to stop.\" cr\n"
"    BEGIN\n"
"        midi.recv\n"
"        IF 3 .r cr? flushemit\n"
"        THEN\n"
"        ?terminal\n"
"    UNTIL\n"
"    base !\n"
";    \n"
"\n"
": MIDI.CLEAR   ( -- , clear all bytes from MIDI input stream)\n"
"    midi-warnings @ midi-warnings off\n"
"    0 BEGIN midi.recv\n"
"    WHILE drop 1+\n"
"    REPEAT cr . .\" MIDI input bytes cleared.\" cr\n"
"    midi-warnings ! midi.check.errors\n"
";\n"
"\n"
": MIDI.KEY ( -- byte )\n"
"    BEGIN\n"
"        ?terminal IF .\" MIDI.KEY \" ?quit abort\" Aborted!\" THEN\n"
"        midi.recv\n"
"    UNTIL\n"
";\n"
"\n"
": MIDI.GET.BYTE ( byte -- )\n"
"    midi.key 2dup =\n"
"    IF 2drop\n"
"    ELSE .\" Expected \" swap . .\" , got \" . cr abort\n"
"    THEN\n"
";\n"
"\n"
"\\ TEST TEST TEST (play) -------------------------------------\n"
"DECIMAL\n"
": MIDI.ORGAN  ( play on keyboard  )\n"
"     .\" PRESS NUMBER KEYS, 'q' to quit!\" CR\n"
"     BEGIN\n"
"        key dup 20 - dup cr .\" note = \" .\n"
"        127 midi.noteon\n"
"        300 msec midi.lastoff\n"
"        ascii q =\n"
"     UNTIL\n"
";\n"
"\n"
"HEX\n"
": MIDI.CONT  ( -- , Continuous stream for hardware testing. )\n"
"    BEGIN\n"
"       45 7F midi.noteon\n"
"       45 7F midi.noteoff\n"
"       ?terminal\n"
"   UNTIL\n"
";\n"
"DECIMAL\n"
"\n"
": MIDI.NOTE ( note -- , play note )\n"
"       100 midi.noteon\n"
"       300 msec\n"
"       midi.lastoff\n"
"       200 msec\n"
";\n"
"\n"
": MIDI.BLAST ( note -- , keep hitting )\n"
"    BEGIN dup midi.note ?terminal\n"
"    UNTIL drop\n"
";\n"
"\n"
": MIDI.TEST  ( -- , simple test to see if MIDI is alive )\n"
"    >newline .\" Sending Middle C on channel 1\" cr\n"
"    .\" Hit <RETURN> to stop.\" cr\n"
"    rnow\n"
"    1 midi.channel!\n"
"    60 midi.blast\n"
";\n"
"\n"
"( Simple MIDI piece )\n"
"VARIABLE MD-LOW  VARIABLE MD-HI\n"
"\n"
": MD-CLIP   ( v -- v' )\n"
"       md-low @ max md-hi @ min\n"
";\n"
"\n"
": MIDI.WALK  ( N -- ,  Random walk )\n"
"    40 md-low !  90 md-hi !\n"
"    50 midi.track.note  ( set start for random walk )\n"
"    0 ?DO  midi.recall.note\n"
"        3 choose 1- +  md-clip\n"
"        127 choose midi.noteon\n"
"        4 choose 1+ 100 * msec\n"
"        midi.lastoff\n"
"        60 choose midi.preset\n"
"        ?terminal IF leave THEN\n"
"    LOOP\n"
";\n"
"\n"
"decimal\n"
": MIDI.SEQOUT   ( -- , Simple sequence )\n"
"    6 0\n"
"    DO  i 4 * 40 + 120 midi.noteon\n"
"        200 msec  midi.lastoff\n"
"    LOOP\n"
";\n"
"\n"
": MIDI.TESTPR ( N -- , test presets )\n"
"     0 ?DO\n"
"        i midi.preset cr .\" PR = \" i .\n"
"        midi.seqout\n"
"     LOOP\n"
";\n"
"\n"
": SYS.STATUS sys.status\n"
"    midi-channel @ 3 .r .\"  = MIDI Channel\" cr\n"
";\n";

const char* midi_fth = (const char*) temp_binary_data_37;

//================== midi_globals.fth ==================
static const unsigned char temp_binary_data_38[] =
"\\ MIDI Global deferred words used by both MIDI systems.\n"
"\n"
"ANEW TASK-MIDI_GLOBALS\n"
"\n"
"\\ -------------------------------MIDI Globals--------------------------------\n"
"0   CONSTANT Modem_Port\n"
"1   CONSTANT Printer_Port\n"
"VARIABLE MIDI-PORT      \\  Current port being used; 0=modem, 1=printer\n"
"2 constant MIDI_NUM_PORTS\n"
"\n"
"variable MIDI-ERROR\n"
"variable MIDI-WARNINGS   ( true to enable warnings )\n"
"variable MIDI-RECV-SIZE\n"
"4096 MIDI-RECV-SIZE !\n"
"variable MIDI-XMIT-SIZE  ( this is used only by the Echo Ports )\n"
"4096 2* MIDI-XMIT-SIZE !\n"
"\n"
"defer MIDI.WRITE ( addr count -- )\n"
"\n"
"defer MIDI.RECV  ( -- byte true | false )\n"
"\n"
"defer MIDI.RTC.TIME@  ( -- rtime , of last byte received )\n"
"\n"
"defer MIDI.SER.INIT ( -- ) ' noop is MIDI.SER.INIT\n"
"defer MIDI.SER.TERM ( -- ) ' noop is MIDI.SER.TERM\n"
"\n"
"\\ Deferred Time Support\n"
"\n"
"( time that current event is supposed to happen )\n"
"variable TIME-VIRTUAL\n"
"\n"
"variable TIME-ADVANCE  ( time in advance that event buffered HMSL runs )\n"
"600 time-advance !\n"
"\n"
"defer RTC.START ( -- )\n"
"defer RTC.STOP ( -- )\n"
"defer RTC.RATE! ( ticks/second -- )\n"
"defer RTC.RATE@ ( -- ticks/second )\n"
"defer RTC.TIME@  ( -- time )\n"
"defer RTC.TIME! ( time -- )\n"
"defer RTC.TIME+! ( n -- )\n"
"defer RTC.INIT  ( -- )\n"
"defer RTC.TERM ( -- )\n"
"' noop is rtc.init\n"
"' noop is rtc.term\n"
"\n"
"variable RTC-USE-MIDI  ( if true use MIDI for time )\n"
"\n"
": MIDI.RESET.VECTORS  ( -- )\n"
"    'c false is midi.recv\n"
"    'c false is midi.rtc.time@\n"
"    'c 2drop is midi.write\n"
";\n"
"\n"
": MIDI.CHECK.ERRORS  ( -- , report errors )\n"
"    midi-warnings @\n"
"    IF midi-error @\n"
"        CASE\n"
"            0 OF ( no error ) ENDOF\n"
"            >newline\n"
"            1 OF .\" MIDI Buffer Overflow!\" ENDOF\n"
"            2 OF .\" MIDI Serial Transmission Error!\" ENDOF\n"
"            3 OF .\" MIDI Msg had Incorrect Length!\" cr \n"
"                .\" Perhaps a MIDI Cable was plugged in or unplugged!\" ENDOF\n"
"            .\" MIDI Error# = \" dup .\n"
"        ENDCASE cr\n"
"        midi-error off\n"
"    THEN\n"
";\n"
"\n"
"\\ MIDI Transmit is Buffered and passed to MIDI.WRITE for time stamping\n"
"\\ and event buffering.\n"
"\n"
"64 constant MIDI_XPAD_MAX\n"
"create MIDI-XMIT-PAD midi_xpad_max allot\n"
"variable MIDI-XMIT-COUNT\n"
"\n"
": MIDI.FLUSH  ( -- )\n"
"    midi-xmit-count @ ?dup\n"
"    IF\n"
"        midi-xmit-pad swap midi.write\n"
"        0 midi-xmit-count !\n"
"    THEN\n"
";\n"
"\n"
": MIDI.XMIT ( byte -- )\n"
"\\ is the holding buffer full?\n"
"    midi-xmit-count @ dup>r\n"
"    [ midi_xpad_max 1- ] literal >\n"
"    IF\n"
"        rdrop 0 >r midi.flush\n"
"    THEN\n"
"    midi-xmit-pad r@ + c!   \\ save in buffer\n"
"    r> 1+ midi-xmit-count ! \\ advance counter\n"
";\n"
"\n"
": HOST.MIDI.WRITE ( addr count -- )\n"
"    time-virtual @ hostMIDI_Write()\n"
";\n"
"\n"
": HOST.MIDI.WRITE.DEBUG ( addr count -- , print MIDI as it goes by )\n"
"    2dup host.midi.write\n"
"    cr? .\" MIDI: \" time-virtual @  . .\" - \"\n"
"    0 ?DO dup i + c@ .hex LOOP drop cr\n"
";\n"
"\n"
": HOST.MIDI.RECV  ( -- byte true | false )\n"
"    hostMIDI_Recv() dup 0<\n"
"    IF\n"
"        drop false\n"
"    ELSE\n"
"        true\n"
"    THEN\n"
";\n"
"\n"
": USE.HOST.MIDI ( -- )\n"
"    .\" Use HOST MIDI.\" cr\n"
"    ['] host.midi.write is midi.write\n"
"    ['] host.midi.recv  is midi.recv\n"
"    ['] hostMIDI_Init() is midi.ser.init\n"
"    ['] hostMIDI_Term() is midi.ser.term\n"
";\n"
"use.host.midi\n"
"\n"
": USE.HOST.CLOCK ( -- )\n"
"    .\" Use HOST Clock.\" cr\n"
"    ['] hostStartClock() is rtc.start\n"
"    ['] hostStopClock() is rtc.stop\n"
"    ['] hostSetClockRate() is rtc.rate!\n"
"    ['] hostQueryClockRate() is rtc.rate@\n"
"    ['] hostQueryTime() is rtc.time@\n"
"    ['] hostSetTime() is rtc.time!\n"
"    ['] hostAdvanceTime() is rtc.time+!\n"
"    ['] hostClockInit() is rtc.init\n"
"    ['] hostClockTerm() is rtc.term\n"
"    ['] hostSleep() is msec\n"
";\n"
"use.host.clock\n";

const char* midi_globals_fth = (const char*) temp_binary_data_38;

//================== midi_instrument.fth ==================
static const unsigned char temp_binary_data_39[] =
"\\ Provide MIDI based instrument.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"\\ MOD: PLB 3/10/87 Provide two note buffer LAST.NOTE.OFF:\n"
"\\      will work with LEGATO.\n"
"\\ MOD: PLB 5/24/87 Add SYS.INIT and SYS.RESET\n"
"\\ MOD: PLB 6/15/87 Add DEFAULT:\n"
"\\ MOD: PLB 10/7/87 Move OPEN: SUPER to after channel allocation.\n"
"\\                  Use TRANSLATE: instead of INSTR.TRANSLATE\n"
"\\ MOD: PLB 10/22/87 Use Circular Buffer for tracking notes.\n"
"\\                  Override channel allocation if channel already set.\n"
"\\ MOD: PLB 11/17/87 Added PUT.#VOICES and GET.#VOICES.\n"
"\\ MOD: PLB 12/15/87 Use LIST methods to allow proper NOTE.OFF:\n"
"\\                   handling. Add ALL.OFF:\n"
"\\ MOD: PLB 11/8/88 Check IV-INS-#OPEN in CLOSE:\n"
"\\ MOD: PLB 2/20/89 Add FIRST.NOTE.OFF: and change LAST.NOTE.OFF:\n"
"\\      to work like a LIFO anstead of a FIFO.\n"
"\\ MOD: PLB 3/30/89 Add channel setting to ALL.OFF: to fix note hang.\n"
"\\ MOD: PLB 5/12/89 Add NOTE.ON.FOR:  for event buffering polyphony.\n"
"\\ MOD: PLB 1/23/90 Moved NOTE.ON.FOR: to OB.INSTRUMENT\n"
"\\ MOD: PLB 4/11/90 Moved ALL.OFF: to OB.INSTRUMENT, added\n"
"\\        RAW.NOTE.ON:\n"
"\\ MOD: PLB 1/3/91 Set DEFAULT.INSTRUMENT at compile time\n"
"\\ MOD: PLB 9/25/91 Moved PUT.PRESET: to H:Instrument\n"
"\n"
"ANEW TASK-MIDI_INSTRUMENT\n"
"\n"
"\\ MIDI Channel Allocator\n"
"OB.ALLOCATOR MIDI-ALLOCATOR\n"
"\n"
":CLASS OB.MIDI.INSTRUMENT <SUPER OB.INSTRUMENT\n"
"    IV.LONG IV-INS-CHANSET   ( true if channel forced, not alloc)\n"
"\n"
":M DEFAULT: ( -- )\n"
"    default: super\n"
"    36 put.offset: self    ( low C on many synths )\n"
"    1 16 put.channel.range: self  ( MIDI range )\n"
";M\n"
"\n"
":M INIT: ( -- )\n"
"    init: super\n"
"    1 set.width: self\n"
";M\n"
"\n"
":M PRESET: ( preset -- , change MIDI preset )\n"
"    dup 0<\n"
"    IF drop\n"
"    ELSE\n"
"        iv-ins-channel dup 0<\n"
"        IF 2drop\n"
"        ELSE midi.channel!\n"
"             midi.preset\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M OPEN: ( -- , open instrument )\n"
"    iv-ins-channel 0<\n"
"    IF   ( allocate channel since none set )\n"
"        get.channel.range: self allocate.range: midi-allocator\n"
"        IF iv=> iv-ins-channel\n"
"        ELSE\n"
"            iv-ins-chan-lo dup iv=> iv-ins-channel\n"
"            mark: midi-allocator\n"
"        THEN\n"
"        false iv=> iv-ins-chanset\n"
"    ELSE iv-ins-#open 0=  ( only the first time opened )\n"
"        IF  iv-ins-channel mark: midi-allocator\n"
"            true iv=> iv-ins-chanset\n"
"        THEN\n"
"    THEN\n"
"    iv-ins-preset preset: self\n"
"    open: super\n"
";M\n"
"\n"
":M RAW.NOTE.OFF: ( note velocity -- , turn off raw note )\n"
"    iv-ins-channel midi.channel!\n"
"    midi.noteoff\n"
";M\n"
"\n"
":M RAW.NOTE.ON: ( note velocity -- , play raw note )\n"
"    iv-ins-channel midi.channel!\n"
"    midi.noteon\n"
";M\n"
"\n"
":M CLOSE: ( -- , close channel if final close )\n"
"    iv-ins-#open 1 =  ( final close? )\n"
"    IF  all.off: self\n"
"        iv-ins-channel deallocate: midi-allocator\n"
"        iv-ins-chanset 0=\n"
"        IF  -1 iv=> iv-ins-channel\n"
"        THEN\n"
"        false iv=> iv-ins-chanset\n"
"    THEN\n"
"    close: super\n"
";M\n"
"\n"
":M PRINT: ( -- )\n"
"    print: super\n"
"    .\" #Voices       = \" iv-ins-#voices . cr\n"
";M\n"
"\n"
"\n"
";CLASS\n"
"\n"
": MI.INIT ( -- , initialize MIDI instrument module )\n"
"    16 new: midi-allocator\n"
"    clear: midi-allocator\n"
"    1 put.offset: midi-allocator\n"
"    'c ob.midi.instrument is default.instrument\n"
";\n"
"\n"
"\\ set default\n"
"'c ob.midi.instrument is default.instrument\n"
"\n"
": SYS.INIT sys.init mi.init ;\n"
": SYS.RESET sys.reset clear: midi-allocator ;\n"
": SYS.TERM free: midi-allocator sys.term ;\n";

const char* midi_instrument_fth = (const char*) temp_binary_data_39;

//================== midi_parser.fth ==================
static const unsigned char temp_binary_data_40[] =
"\\ Parse MIDI input.\n"
"\\\n"
"\\ Vector response to channel voice messages.\n"
"\\ Does not parse sys ex data.\n"
"\\ This allows you to have special operations occur\n"
"\\ when a specific MIDI event is recieved.\n"
"\\ You must set the vectors, then call MIDI.PARSE from a loop.\n"
"\\ HMSL will call the MIDI Parser for you if you turn it on.\n"
"\\ The word that you set the vector for must eat the\n"
"\\ appropriate number of bytes off the stack for that command.\n"
"\\\n"
"\\ MIDI Parser State Machine:\n"
"\\   To avoid having HMSL hanging while waiting for a\n"
"\\   complete message to arrive we can accumulate messages\n"
"\\   using a state machine.\n"
"\\   For each Port we will have a Parser State Structure\n"
"\\   that has a pad for up to 4 bytes, a counter, and a limit.\n"
"\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1987 Delta Research\n"
"\\\n"
"\\ MOD: PLB 3/31/87 Handle single byte SYSEX codes.\n"
"\\ MOD: PLB 4/2/87 Changed ' to 'C for Mac.\n"
"\\ MOD: PLB 4/15/87 Changed vector scheme to relocatable.\n"
"\\ MOD: PLB 5/13/87 Add MP.CHANNEL@\n"
"\\ MOD: PLB 6/1/87 Added SYSTEM messages, fixed lost data.\n"
"\\ MOD: PLB 11/16/87 Changed C@ to @ in MP.CHANNEL@\n"
"\\ MOD: PLB & SC 3/15/88 Changed to two port MIDI\n"
"\\ MOD: PLB 7/17/88 Added scan in MIDI.PARSE.\n"
"\\ MOD: PLB 5/26/89 Add state machine, Eats sysex.\n"
"\\ MOD: PLB 9/22/89 Call MP-OFF-VECTOR for 0 velocity notes.\n"
"\\ MOD: PLB 11/9/89 Add 01 to MP-#BYTES for F1 Time Code\n"
"\\ MOD: PLB 10/6/90 Add timeout to MP.EAT.SYSEX\n"
"\\ MOD: PLB 10/22/91 Add MIDI.PARSE.CURRENT, check for stack errors\n"
"\\ 00001 PLB 2/16/92 Remove annoying message from MP.EAT.SYSEX\n"
"\\ 00002 PLB 10/5/2015 Fix endian issue in MP-#BYTES\n"
"\n"
"decimal\n"
"\n"
"ANEW TASK-MIDI_PARSER\n"
"\n"
": MP!, ( addr value -- addr+cell , store into vectors and advance pointer )\n"
"    midi_num_ports 0\n"
"    DO  swap 2dup !\n"
"        cell+ swap\n"
"    LOOP drop\n"
";\n"
"\\ Compile time code.\n"
"\\ Execution array for parsing.\n"
"\\ 8 regular, 16 for system, 1 for special ON-VECTOR\n"
"CREATE MP-VECTORS 8 16 + 1+ MIDI_NUM_PORTS * cells allot\n"
"\n"
"( set # data bytes per message type )\n"
"CREATE MP-#BYTES\n"
"    2 c, 2 c, 2 c, 2 c,  ( for channel mesages )\n"
"    1 c, 1 c, 2 c, 0 c,\n"
"    1 c, 1 c, 2 c, 1 c,\n"
"    0 c, 0 c, 0 c, 0 c,  ( System Common F0 -> F7 )\n"
"    0 c, 0 c, 0 c, 0 c,\n"
"    0 c, 0 c, 0 c, 0 c,  ( System Real Time F8 -> FF )\n"
"    \n"
"\\ Names for vectors\n"
"midi_num_ports 1 > [IF]  \\ fancy version for multiple ports.\n"
": MP:VECTOR  ( offset -- offset' , generate address off mp-vectors )\n"
"    CREATE dup , cell midi_num_ports *  +\n"
"    DOES> @ mp-vectors +\n"
"        midi-port @ cell* +\n"
"\n"
";\n"
"[ELSE]  \\ Faster version for single channel\n"
": MP:VECTOR  ( offset -- , generate address off mp-vectors )\n"
"    CREATE dup , cell+\n"
"    DOES> @ mp-vectors +\n"
";\n"
"[THEN]\n"
"\n"
"\\ CHANNEL MESSAGES\n"
"0  mp:vector MP-OFF-VECTOR   ( 80 )\n"
"mp:vector MP-SMART-ON-VECTOR ( 90 )    \\ INTERNAL - Calls ON or OFF\n"
"mp:vector MP-NOTEPR-VECTOR   ( A0 )\n"
"mp:vector MP-CONTROL-VECTOR  ( B0 )\n"
"mp:vector MP-PROGRAM-VECTOR  ( C0 )\n"
"mp:vector MP-PRESSURE-VECTOR ( D0 )\n"
"mp:vector MP-BEND-VECTOR     ( E0 )\n"
"\\ SYSTEM MESSAGES\n"
"mp:vector MP-OBSOLETE-VECTOR ( Fx )  ( automatically uses following )\n"
"mp:vector MP-SYSEX-VECTOR    ( F0 )\n"
"mp:vector MP-F1-VECTOR       ( F1 )\n"
"mp:vector MP-POINTER-VECTOR  ( F2 )\n"
"mp:vector MP-SELECT-VECTOR   ( F3 )\n"
"mp:vector MP-F4-VECTOR       ( F4 )\n"
"mp:vector MP-F5-VECTOR       ( F5 )\n"
"mp:vector MP-TUNE-VECTOR     ( F6 )\n"
"mp:vector MP-EOX-VECTOR      ( F7 )\n"
"mp:vector MP-CLOCK-VECTOR    ( F8 )\n"
"mp:vector MP-F9-VECTOR       ( F9 )\n"
"mp:vector MP-START-VECTOR    ( FA )\n"
"mp:vector MP-CONTINUE-VECTOR ( FB )\n"
"mp:vector MP-STOP-VECTOR     ( FC )\n"
"mp:vector MP-FD-VECTOR       ( FD )\n"
"mp:vector MP-SENSING-VECTOR  ( FE )\n"
"mp:vector MP-RESET-VECTOR    ( FF )\n"
"mp:vector MP-ON-VECTOR       ( called by MP-SMART-ON-VECTOR )\n"
"drop\n"
"\n"
"\\ Parsing Run Time Words ------------------------------\n"
":STRUCT MP.STATE  \\ MIDI Parser State Control Block\n"
"    byte  mp_count      ( bytes collected )\n"
"    byte  mp_needed     ( bytes needed to complete message )\n"
"    byte  mp_cvm_index  ( index bits 4,5,6 )\n"
"    byte  mp_channel    ( channel, 0based )\n"
"    long  mp_msg_count  ( number of messages sent this time )\n"
"    byte  mp_byte0      ( first raw byte, CVM )\n"
"    byte  mp_byte1      ( first data byte )\n"
"    byte  mp_byte2\n"
"    byte  mp_byte3\n"
";STRUCT\n"
"\n"
": MP.DUMP ( state -- )\n"
"    dup ..@ mp_needed .\" #data = \" . cr\n"
"    .\" Message = \"\n"
"    4 0\n"
"    DO\n"
"        dup .. mp_byte0 i + c@ .hex\n"
"    LOOP cr\n"
"    drop\n"
";\n"
"    \n"
"\\ Declare structures for each port.\n"
"\n"
"midi_num_ports 1 =\n"
"[IF]\n"
"MP.STATE MP-STATE\n"
": MP.&CFA  ( index -- addr )\n"
"    cells mp-vectors +\n"
";\n"
"[THEN]\n"
"\n"
"midi_num_ports 2 =\n"
"[IF]\n"
"CREATE MP-STATE-BASE sizeof() mp.state midi_num_ports * allot\n"
": MP-STATE  ( -- address , control block for current port )\n"
"    mp-state-base\n"
"    midi-port @\n"
"    IF sizeof() mp.state +  ( go for second one )\n"
"    THEN\n"
";\n"
": MP.&CFA  ( index -- addr )\n"
"    3 lshift mp-vectors +\n"
"    midi-port @ cells +\n"
";\n"
"[THEN]\n"
"\n"
"midi_num_ports 2 >\n"
"[IF]\n"
"CREATE MP-STATE-BASE sizeof() mp.state midi_num_ports * allot\n"
": MP-STATE  ( -- address , control block for current port )\n"
"    midi-port @ sizeof() mp.state w* mp-state-base +\n"
";\n"
": MP.&CFA  ( index -- addr )\n"
"    midi_num_ports cells w* mp-vectors +\n"
"    midi-port @ cells +\n"
";\n"
"[THEN]\n"
"\n"
": MP.CHANNEL@  ( -- channel , get channel# of last message )\n"
"    mp-state ..@ mp_channel 1+  ( convert to human form )\n"
";\n"
"\n"
": MP.EXECUTE ( ?\??\?? -- , execute user parser )\n"
"    rnow\n"
"    mp-state ..@ mp_cvm_index mp.&cfa @ execute\n"
";\n"
"\n"
": MP.PUSH.DATA  ( n -- , push n data bytes)\n"
"    mp-state .. mp_byte1 ( n addr )\n"
"    dup>r + r> ( -- addr+n addr )\n"
"    ?DO i c@\n"
"    LOOP\n"
";\n"
"\n"
": MP.GET.ADDR#  ( -- addr count , message as received )\n"
"    mp-state .. mp_byte0\n"
"    mp-state ..@ mp_count 1+\n"
";\n"
"\n"
": MP.CHECK.STACK ( depth1 depth2 -- )\n"
"    -\n"
"    IF\n"
"        mp-state mp.dump .s cr\n"
"        .\" MIDI PARSER - User function stack error in: \"\n"
"        mp-state ..@ mp_cvm_index mp.&cfa @ >name id.\n"
"        abort\n"
"    THEN\n"
";\n"
"\n"
": MP.FLUSH  ( -- , execute currently accumulated command )\n"
"    depth >r\n"
"    mp-state ..@ mp_needed ?dup\n"
"    IF\n"
"        mp.push.data\n"
"    THEN\n"
"    mp.execute\n"
"    depth r> mp.check.stack\n"
"    0 mp-state ..! mp_count\n"
"    1 mp-state .. mp_msg_count +!\n"
";\n"
"\n"
": MP.COMMAND>INDEX  ( cvm-byte -- index )\n"
"    dup 4 rshift dup $ 0F =\n"
"    IF  ( -- cvm 0F , system message )\n"
"        drop $ 0F and 8 +\n"
"    ELSE  nip 7 and\n"
"    THEN\n"
";\n"
"\n"
": MP.#BYTES  ( cvm-byte -- #databytes )\n"
"    mp.command>index mp-#bytes + c@\n"
";\n"
"\n"
": MP.HANDLE.COMMAND  ( cvm-byte -- )\n"
"    dup mp-state ..! mp_byte0\n"
"    0 mp-state ..! mp_count\n"
"    dup $ 0F and mp-state ..! mp_channel\n"
"    mp.command>index\n"
"    dup mp-state ..! mp_cvm_index\n"
"    mp-#bytes + c@ dup\n"
"    mp-state ..! mp_needed 0= ( date bytes needed for msg )\n"
"    IF ( complete, do it now )\n"
"        depth >r\n"
"        mp.execute\n"
"        depth r> mp.check.stack\n"
"        0 mp-state ..! mp_count\n"
"        1 mp-state .. mp_msg_count +!\n"
"    THEN\n"
";\n"
"\n"
": MP.HANDLE.DATA ( data-byte -- )\n"
"    mp-state ..@ mp_needed dup 0>\n"
"    IF  >r  ( save #needed )\n"
"        mp-state ..@ mp_count\n"
"        dup>r mp-state .. mp_byte1 + c!  ( save data byte )\n"
"        r> 1+ dup mp-state ..! mp_count\n"
"        r> =\n"
"        IF mp.flush\n"
"        THEN\n"
"    ELSE .hex .hex\n"
"        true warning\" MP.HANDLE.DATA -  Stray data byte!\" cr\n"
"    THEN\n"
";\n"
"\n"
": MIDI.PARSE.BYTE  ( byte -- , parse MIDI byte )\n"
"    dup $ 80 and  ( -- byte hi-bit , is it a control byte? )\n"
"    IF mp.handle.command\n"
"    ELSE ( Data with running status )\n"
"        mp.handle.data\n"
"    THEN\n"
";\n"
"\n"
"variable MP-LAST-TIME\n"
"\n"
": MP.EAT.SYSEX  ( vendor -- , eat bytes until F7 )\n"
"    drop \\ .\" Eating MIDI SYSEX till F7 !\" cr \\ 00001\n"
"    midi.rtc.time@ mp-last-time !\n"
"    BEGIN\n"
"        midi.recv\n"
"        IF midi.rtc.time@ mp-last-time !\n"
"            $ F7 =\n"
"        ELSE rtc.time@ mp-last-time @ - rtc.rate@ / 10 >\n"
"            abort\" MP.EAT.SYSEX - timed out!\"\n"
"            false\n"
"        THEN\n"
"    UNTIL\n"
";\n"
"\n"
": MP.SMART.ON  ( note velocity -- , handle 0 velocity )\n"
"    dup\n"
"    IF mp-on-vector @ execute\n"
"    ELSE mp-off-vector @ execute  ( 0 velocity means off )\n"
"    THEN\n"
";\n"
"\n"
": MP.RESET ( -- , resets vectors to appropriate drops )\n"
"    mp-vectors\n"
"\\ Set 8 command vectors\n"
"    'c 2drop MP!,    'c mp.smart.on MP!,  ( off, on )\n"
"    'c 2drop MP!,    'c 2drop MP!,  ( notepr, control )\n"
"    'c drop  MP!,    'c drop  MP!,  ( program, pressure )\n"
"    'c 2drop MP!,    'c abort MP!,  ( bend, system )\n"
"\\\n"
"\\ Set 16 system vectors\n"
"    'c mp.eat.sysex  MP!,\n"
"    'c noop  MP!,\n"
"    'c 2drop MP!,    'c drop  MP!,\n"
"    8 4 + 0\n"
"    DO 'c noop MP!,\n"
"    LOOP\n"
"\\ Set special MIDI ON Vector\n"
"    'c 2drop MP!,\n"
"    DROP\n"
";\n"
"\\ mp.reset\n"
"\n"
": MIDI.PARSE  ( -- , call appropriate function based on MIDI input)\n"
"    midi-port @\n"
"    midi_num_ports 0\n"
"    DO  i midi-port !\n"
"        0 mp-state ..! mp_msg_count\n"
"        BEGIN\n"
"            midi.recv\n"
"            IF  midi.parse.byte false\n"
"            ELSE true\n"
"            THEN\n"
"            mp-state ..@ mp_msg_count 0> OR\n"
"        UNTIL\n"
"    LOOP\n"
"    midi-port !\n"
";\n"
"\n"
"VARIABLE MIDI-PARSE-MAX\n"
"\n"
"\\ these versions are different for speed reasons\n"
"midi_num_ports 1 = [IF]\n"
": MIDI.PARSE.MANY ( -- , parse currently set port )\n"
"    0 mp-state ..! mp_msg_count\n"
"    BEGIN\n"
"        midi.recv\n"
"        IF  midi.parse.byte false\n"
"        ELSE true\n"
"        THEN\n"
"        mp-state ..@ mp_msg_count midi-parse-max @ > OR\n"
"    UNTIL\n"
";\n"
": MIDI.PARSE.CURRENT ( -- , parse bytes recvd until now )\n"
"    rtc.time@ 1+\n"
"    BEGIN\n"
"        midi.recv\n"
"        IF\n"
"            midi.parse.byte\n"
"  \\ quit if we are getting leter bytes\n"
"            dup midi.rtc.time@ time<\n"
"        ELSE true\n"
"        THEN\n"
"    UNTIL\n"
"    drop\n"
";\n"
"[ELSE]\n"
": (MIDI.PARSE.MANY) ( -- , parse currently set port )\n"
"    0 mp-state ..! mp_msg_count\n"
"    BEGIN\n"
"        midi.recv\n"
"        IF  midi.parse.byte false\n"
"        ELSE true\n"
"        THEN\n"
"        mp-state ..@ mp_msg_count midi-parse-max @ > OR\n"
"    UNTIL\n"
";\n"
": (MIDI.PARSE.CURRENT) ( -- , parse bytes recvd until now )\n"
"    rtc.time@ 1+\n"
"    BEGIN\n"
"        midi.recv\n"
"        IF\n"
"            midi.parse.byte\n"
"  \\ quit if we are getting leter bytes\n"
"            dup midi.rtc.time@ time<\n"
"        ELSE true\n"
"        THEN\n"
"    UNTIL\n"
"    drop\n"
";\n"
"[THEN]\n"
"\n"
"midi_num_ports 2 = [IF] \\ for 2 port systems\n"
": MIDI.PARSE.MANY  ( -- , call appropriate function based on MIDI input)\n"
"    midi-port @\n"
"    0 midi-port !\n"
"    (midi.parse.many)\n"
"    1 midi-port !\n"
"    (midi.parse.many)\n"
"    midi-port !\n"
";\n"
": MIDI.PARSE.CURRENT  ( -- , call appropriate function based on MIDI input)\n"
"    midi-port @\n"
"    0 midi-port !\n"
"    (midi.parse.current)\n"
"    1 midi-port !\n"
"    (midi.parse.current)\n"
"    midi-port !\n"
";\n"
"[THEN]\n"
"\n"
"midi_num_ports 1 > [IF] \\ for multi port systems\n"
": MIDI.PARSE.MANY  ( -- , call appropriate function based on MIDI input)\n"
"    midi-port @\n"
"    midi_num_ports 0\n"
"    DO  i midi-port !\n"
"        (midi.parse.many)\n"
"    LOOP\n"
"    midi-port !\n"
";\n"
": MIDI.PARSE.CURRENT  ( -- , call appropriate function based on MIDI input)\n"
"    midi-port @\n"
"    midi_num_ports 0\n"
"    DO  i midi-port !\n"
"        (midi.parse.current)\n"
"    LOOP\n"
"    midi-port !\n"
";\n"
"[THEN]\n"
"\n"
": MIDI.PARSE.LOOP\n"
"    stack.mark\n"
"    BEGIN\n"
"        midi.parse.current\n"
"        stack.check\n"
"        ?terminal\n"
"    UNTIL\n"
";\n"
"\n"
"\n"
"variable MIDI-PARSER ( used as a control for higher level code )\n"
"\n"
": MIDI.PARSER.ON ( -- , turn on midi parsing )\n"
"    true midi-parser !\n"
";\n"
": MIDI.PARSER.OFF ( -- , turn off midi parsing )\n"
"    false midi-parser !\n"
";\n"
"\n"
": MP.INIT ( -- , also reset vectors )\n"
"    mp.reset\n"
"    4 midi-parse-max !\n"
"    midi-port @\n"
"    midi_num_ports 0\n"
"    DO  i midi-port !\n"
"        0 mp-state ..! mp_needed\n"
"        0 mp-state ..! mp_count\n"
"    LOOP\n"
"    midi-port !\n"
"    midi.parser.off\n"
";\n"
"\n"
": SYS.INIT sys.init mp.init ;\n"
"\n"
"\n"
"\\ Test -----------------------------------------\n"
"1 [IF]\n"
": MP.ON.RESP ( note velocity -- ) DUP\n"
"    .\" Port = \" midi-port ? .\" , ON \" swap . . cr\n"
";\n"
"\n"
": MP.PROGRAM.RESP ( program# -- )\n"
"   .\" Port = \" midi-port ? .\" , PRESET \" . cr\n"
";\n"
"\n"
": MP.SET.TEST  ( -- ,set vectors for test )\n"
"    mp.init\n"
"    midi-port @\n"
"    midi_num_ports 0\n"
"    DO  i midi-port !\n"
"        'c mp.on.resp mp-on-vector !\n"
"        'c mp.program.resp mp-program-vector !\n"
"    LOOP\n"
"    midi-port !\n"
";\n"
"\n"
": MP.TEST mp.set.test midi.parse.loop mp.reset ;\n"
"\n"
"[THEN]\n"
"decimal\n";

const char* midi_parser_fth = (const char*) temp_binary_data_40;

//================== midi_stubs.fth ==================
static const unsigned char temp_binary_data_41[] =
"\\ MIDI Stubs\n"
"\\ These are used when MIDI is not loaded and we want to\n"
"\\ load the rest of the system without too much trouble.\n"
"\n"
"ANEW TASK-MIDI_STUBS\n"
"\n"
": NO.MIDI  ( -- , report no MIDI )\n"
"    >newline .\" MIDI Support is not loaded!\" cr\n"
";\n"
"\n"
": MIDI.NOTEON 2drop no.midi ;\n"
": MIDI.NOTEOFF 2drop no.midi ;\n"
": MIDI.PRESET drop no.midi ;\n"
"\n"
": MIDI.PARSER.ON no.midi ;\n"
": MIDI.PARSER.OFF no.midi ;\n"
": MP.RESET no.midi ;\n"
"\n"
"variable MIDI-PARSER\n"
": MIDI.PARSE.MANY ;\n"
"\n"
": EB.ON ;\n";

const char* midi_stubs_fth = (const char*) temp_binary_data_41;

//================== midi_text.fth ==================
static const unsigned char temp_binary_data_42[] =
"\\ Utility for converting MIDI note numbers <> text\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1991 Phil Burk\n"
"\\ 00001 PLB 2/16/92 Add more room to M>T-PAD for $APPEND, remove $ROM\n"
"\n"
"include? { ju:locals\n"
"\n"
"ANEW TASK-MIDI_TEXT\n"
"\n"
"$ROM $NOTES-TEXT\n"
"    ,\" C\"  ,\" C#\" ,\" D\"  ,\" D#\"\n"
"    ,\" E\"  ,\" F\"  ,\" F#\" ,\" G\"\n"
"    ,\" G#\" ,\" A\"  ,\" A#\" ,\" B\"\n"
"\n"
"variable M>T-PAD 4 allot \\ room for 8 characters \\ 00001\n"
"\n"
": MIDI>$ ( note -- $text )\n"
"    12 /mod ( note octave )\n"
"    1- 0 max ( start at note 12 for octave = 0 )\n"
"    swap $notes-text ( -- octave $note )\n"
"    m>t-pad $move\n"
"    n>text m>t-pad $append  \\ append octave number\n"
"    m>t-pad\n"
";\n"
"\n"
"create NOTE-OFFSETS\n"
"  9 c, ( A )\n"
" 11 c, ( B )\n"
"  0 c, ( C )\n"
"  2 c, ( D )\n"
"  4 c, ( E )\n"
"  5 c, ( F )\n"
"  7 c, ( G )\n"
"align\n"
"\n"
": $>MIDI { $text | addr indx num note ok? -- note true | false }\n"
"    0 -> ok?\n"
"\\ false if bad\n"
"    $text count -> num -> addr\n"
"    -1 -> note\n"
"    0 -> indx\n"
"\\\n"
"\\ check for note A-G\n"
"    addr indx + c@ tolower ascii a -\n"
"    dup 0 7 within?\n"
"    IF\n"
"        note-offsets + c@ -> note\n"
"        indx 1+ -> indx\n"
"    ELSE\n"
"        drop  \\ bad note\n"
"    THEN\n"
"\\\n"
"\\ check for sharps and flats\n"
"    indx 0>\n"
"    IF\n"
"        addr indx + c@ ascii # =\n"
"        IF\n"
"            note 1+ -> note\n"
"            indx 1+ -> indx\n"
"        THEN\n"
"        addr indx + c@ ascii b =\n"
"        IF\n"
"            note 1- -> note\n"
"            indx 1+ -> indx\n"
"        THEN\n"
"    THEN\n"
"\\\n"
"    indx 0>\n"
"    IF\n"
"        addr indx + c@ dup isdigit\n"
"        IF\n"
"            ascii 0 - 1+ 12 *  \\ calculate octave offset\n"
"            note + -> note\n"
"            indx 1+ -> indx\n"
"        ELSE drop\n"
"        THEN\n"
"        indx num = -> ok?\n"
"    THEN\n"
"\\\n"
"\\ return parameters\n"
"    note 127 <\n"
"    ok? AND\n"
"    IF\n"
"        note true\n"
"    ELSE\n"
"        false\n"
"    THEN\n"
";\n"
"\n";

const char* midi_text_fth = (const char*) temp_binary_data_42;

//================== misc_tools.fth ==================
static const unsigned char temp_binary_data_43[] =
"\\ Some miscellaneous tools that might be useful and \n"
"\\ are used in HMSL.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 10/22/87 Moved 3DROP from INSTRUMENTS file.\n"
"\\ MOD: PLB 11/16/87 Added ?QUIT\n"
"\\ MOD: PLB 6/17/89 Add CHOOSE+/-\n"
"\\ MOD: PLB 11/16/89 Add LOGBASE2\n"
"\\ MOD: PLB 9/25/91 Added REDUCE.FRACTION , RATIO+\n"
"\\ 00001 PLB 2/6/92 Add ?EXECUTE and EXEC.STACK?\n"
"\n"
"ANEW TASK-MISC_TOOLS\n"
"\n"
"\\ Larry's Utilities ========================================\n"
"\n"
"\\ set and reset a variable\n"
": ENABLE ( a -- ) on ; ( e.g. V.FOO ENABLE )\n"
": DISABLE ( a -- ) off ; ( e.g V.FOO DISABLE )\n"
"\n"
"\\ alternate for ?terminal ...\n"
": ESC ?terminal ;\n"
"\n"
"\\ alternate shorter words for  and constant \n"
": K: constant ;\n"
"\n"
"\\ ******************************************\n"
"\n"
"\\ some simple utilities from dr.dobbs 83 \"almost standard\" extensions\n"
": INCR ( a - ) 1 swap +! ; ( increments a variable -- like c 1++ )\n"
": DECR ( a - ) -1 swap +! ; ( decrements a variable )\n"
"\\ ==========================================================\n"
"\n"
": ESCAPE?  ( -- , ABORTS if key hit )\n"
"    ?TERMINAL IF cr .\" Abort with ESCAPE?\" cr ABORT THEN\n"
";\n"
"\n"
"\\ Aliases for existing words.\n"
": BEEP bell ;\n"
": MS msec ;\n"
"\n"
"\\ Bit manipulation.\n"
": SET.BITS  ( flag mask value -- -- value' , set or reset bits )\n"
"    over -1 xor and\n"
"    swap rot\n"
"    IF or\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
"\\ Interpolate a value along a line defined by two points\n"
"\\ (x1,y1) and (x2,y2).\n"
"\\ by Phil Burk\n"
"v: INTERP-X1  v: INTERP-Y1\n"
"v: INTERP-DX  v: INTERP-DY\n"
"\n"
"\\ pass in endpoints\n"
": SET.INTERP  ( x1 y1 x2 y2 -- , define line for interpolation )\n"
"    rot dup interp-y1 !  - interp-dy !\n"
"    swap dup interp-x1 ! - interp-dx !\n"
";\n"
"\n"
": INTERP ( x -- y , interpolate value along line )\n"
"\\  y = ((x-x1) *  dy / dx)  + y1\n"
"    interp-x1 @ -\n"
"    interp-dy @ interp-dx @ */\n"
"    interp-y1 @ +\n"
";\n"
"\n"
"\\ Return value which randomly deviates from 'last1' by a \n"
"\\ 1/f distribution\n"
"\\\n"
"\\ output range: 0<=1/f-next<=2*1/f-bitmask\n"
"\\ scale like: 1/f  200 * 128 / to get 0 200 range,\n"
"\\ given 0, 128 output\n"
"\n"
"\\ author: Ken Worthy, from an algorithm from Bell Labs\n"
"\\ by Charles Dodge\n"
"V: 1/F-LAST1 V: 1/F-NEXT\n"
"V: 1/F-BITMASK V: 1/F-PROBIT\n"
"V: 1/F-FLIPFLOP\n"
"\n"
"\\ This distribution uses 1/f-last1 as the \"seed\" for successive\n"
"\\ calls. \n"
"decimal\n"
": 1/F ( 1/f-last1 -- 1/f-next , generate next 1/f value)\n"
"        1/f-last1 !\n"
"        0 1/f-next !\n"
"        64 1/f-bitmask !\n"
"        78125 1/f-probit !\n"
"        BEGIN\n"
"                1/f-last1 @ 1/f-bitmask @ / 1/f-flipflop !\n"
"                1/f-flipflop @ 1 =\n"
"                IF\n"
"                        1/f-last1 @ 1/f-bitmask @ - 1/f-last1 !\n"
"                THEN\n"
"                10000 choose 1000 * 1/f-probit @ < ( yields 0-10000000)\n"
"                IF\n"
"                        1 1/f-flipflop @ - 1/f-flipflop !\n"
"                THEN\n"
"                1/f-next @ 1/f-flipflop @ 1/f-bitmask @ * + 1/f-next !\n"
"                1/f-bitmask @ 2/ 1/f-bitmask !\n"
"                1/f-probit @ 2* 1/f-probit !\n"
"                1/f-bitmask @ 1 < \n"
"        UNTIL\n"
"        1/f-next @\n"
";\n"
"\n"
"\n"
"\\ ----------- more goodies ------------\n"
": 3DROP ( a b c -- )\n"
"    2drop drop\n"
";\n"
"\n"
": CHOOSE+/-  ( N -- r , calc number from +/- N inclusive )\n"
"    dup 2* 1+ choose swap -\n"
";\n"
"\n"
"\\ ---------------------------\n"
": CFA.  ( cfa | 0 -- , print CFA safely )\n"
"    ?dup\n"
"    IF >name id.\n"
"    ELSE 0 .\n"
"    THEN\n"
";\n"
"\n"
"\n"
": LOGBASE2  ( n -- log2[n] , position of highest bit )\n"
"    -1 swap\n"
"    BEGIN dup 0>\n"
"    WHILE >r 1+ r> -1 shift\n"
"    REPEAT drop\n"
";\n"
"\n"
"\\ --------------------------------------\n"
": IN.DICT?  ( addr -- flag , true if in dictionary )\n"
"    0 rel->use\n"
"    here\n"
"    within?\n"
";\n"
"\n"
"\n"
"\\ handy tool\n"
"create PRIMES\n"
"here 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 ,\n"
"here swap - cell/ constant NUM_PRIMES\n"
"\n"
": REDUCE.FRACTION  { top bot | prime -- top' bot' }\n"
"    num_primes 0\n"
"    DO\n"
"        i cell* primes + @ -> prime\n"
"        prime top >\n"
"        prime bot > OR\n"
"        IF leave\n"
"        THEN\n"
"\\\n"
"        BEGIN\n"
"            top prime /mod  ( rem quo )\n"
"            swap 0=\n"
"            IF ( tquo )\n"
"                bot prime /mod\n"
"                swap 0=\n"
"                IF ( -- tquo bquo )\n"
"                    -> bot\n"
"                    -> top false\n"
"                ELSE 2drop true \\ try next prime\n"
"                THEN\n"
"            ELSE\n"
"                drop true\n"
"            THEN\n"
"        UNTIL\n"
"    LOOP\n"
"    top bot\n"
";\n"
"\n"
": CLIP.FRACTION { numer denom maxden -- numer denom }\n"
"\\ force to below max denominator\n"
"    denom maxden >\n"
"    IF\n"
"        numer maxden denom */\n"
"        maxden\n"
"        reduce.fraction -> denom -> numer\n"
"    THEN\n"
"    numer denom\n"
";\n"
"\n"
": RATIO+  { n1 d1 n2 d2 -- n3 d3 }\n"
"    d1 d2 =\n"
"    IF\n"
"        n1 n2 + d1\n"
"    ELSE\n"
"        n1 d2 *  n2 d1 * +\n"
"        d1 d2 *\n"
"    THEN\n"
";\n"
"\n"
"defer DEFERRED.EXECUTE\n"
"' EXECUTE is DEFERRED.EXECUTE\n"
"\n"
": ?EXECUTE ( cfa -- , execute if non zero )\n"
"    ?dup\n"
"    IF deferred.execute\n"
"    THEN\n"
";\n"
"\n"
": EXEC.STACK? { usercfa depthchange | saved -- , execute if non zero }\n"
"    depth depthchange + -> saved\n"
"\\\n"
"    usercfa deferred.execute\n"
"\\\n"
"    depth saved -\n"
"    IF\n"
"        >newline\n"
"        .\" Stack error in user function: \" usercfa >name id.\n"
"        abort\n"
"    THEN\n"
";\n";

const char* misc_tools_fth = (const char*) temp_binary_data_43;

//================== morph.fth ==================
static const unsigned char temp_binary_data_44[] =
"\\ MORPH Class\n"
"\\ MORPHS are a class of music objects based on abstract morphology\n"
"\\ and hierarchy.\n"
"\\\n"
"\\ A hierarchy of morphs communicate with each other by\n"
"\\ sending messages up and down the tree.  Some parameters\n"
"\\ contain a time and a return address.\n"
"\\ The time is used to maintain synchronization.\n"
"\\ The METHODS that support this messaging system are:\n"
"\\    EXECUTE:    ( time raddr -- , perform specific operation)\n"
"\\    ?EXECUTE:   ( time raddr -- time true | false , true if already done )\n"
"\\    TERMINATE:  ( time -- , stop execution using time )\n"
"\\    DONE:       ( time raddr -- , inform parent of completion )\n"
"\\    ABORT:      ( -- , cleanup self, abort parents. )\n"
"\\    START:      ( -- , starts a morph executing NOW )\n"
"\\    STOP:       ( -- , stop a morph and its children )\n"
"\\    PREFAB:     ( set up a morph to something useable )\n"
"\\    \n"
"\\ Aborts are issued to objects in the multi-tasker.  They\n"
"\\ send abort messages up the hierarchy so all morphs get aborted.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 10/13/86 Changed from OB.IVAR to IV.LONG\n"
"\\ MOD: PLB 1/?\?/86 Rewrote EXECUTE: technique.\n"
"\\ MOD: PLB 3/2/87 Add ABORT: processing.\n"
"\\ MOD: PLB 3/6/87 Add PRINT.HIERARCHY:\n"
"\\ MOD: PLB 5/23/87 Add STOP: , changed TASK: to not return done?\n"
"\\      Changed SET.INVOKER to GET and PUT.INVOKER:\n"
"\\ MOD: PLB 5/24/87 Added flag=true if executing.\n"
"\\ MOD: PLB 6/4/87 Add PUT.DATA: DEFAULT:\n"
"\\ MOD: PLB 7/8/87 Add GET.NAME|NFA:\n"
"\\ MOD: PLB 10/28/87 Add START:\n"
"\\ MOD: PLB 5/17/89 Add ?EXECUTE:  to return if_done_flag\n"
"\\ MOD: PLB 9/26/89 Add PREFAB: and BUILD:\n"
"\\ MOD: PLB 2/23/90 Put STOP: in ABORT:\n"
"\\ MOD: PLB 4/5/90 Rewrote STOP code\n"
"\\ MOD: PLB 7/12/90 Put DEFAULT before FREE in CLEANUP:\n"
"\\ 00001 11/12/91 Change START: to use RTC.TIME@, Added START.AT:\n"
"\\ 00002 7/21/92 Added PUT.REPETITION:\n"
"\n"
"ANEW TASK-MORPH\n"
"\n"
"( Methods for morph)\n"
"METHOD TASK:\n"
"METHOD DONE:\n"
"METHOD START:\n"
"METHOD START.AT:\n"
"METHOD ABORT:\n"
"METHOD STOP:\n"
"METHOD PUT.INVOKER:\n"
"METHOD GET.INVOKER:\n"
"METHOD DEFAULT:\n"
"METHOD PRINT.HIERARCHY:\n"
"METHOD FREE.HIERARCHY:\n"
"METHOD DEFAULT.HIERARCHY:\n"
"METHOD ?HIERARCHICAL:\n"
"METHOD PUT.DATA:\n"
"METHOD GET.DATA:\n"
"METHOD GET.NAME|NFA:\n"
"METHOD ?EXECUTING:\n"
"METHOD ?EXECUTE:\n"
"METHOD PREFAB:\n"
"METHOD BUILD:\n"
"METHOD CLEANUP:\n"
"METHOD TERMINATE:\n"
"\n"
"\\ The following methods moved from OB.Collection 3/30/92\n"
"\n"
"METHOD GET.WEIGHT:       METHOD PUT.WEIGHT:\n"
"METHOD GET.REPEAT:       METHOD PUT.REPEAT:\n"
"METHOD GET.REPETITION:   METHOD PUT.REPETITION: \\ 00002\n"
"METHOD CUSTOM.EXEC:\n"
"METHOD GET.NEXT.TIME:    METHOD SET.DONE:\n"
"METHOD FINISH:\n"
"\n"
"\\ Allow delays for each part of play.\n"
"METHOD GET.START.DELAY:  METHOD PUT.START.DELAY:\n"
"METHOD GET.REPEAT.DELAY: METHOD PUT.REPEAT.DELAY:\n"
"METHOD GET.STOP.DELAY:   METHOD PUT.STOP.DELAY:\n"
"\n"
"\\ These functions will be passed the address of the object.\n"
"METHOD GET.START.FUNCTION:  METHOD PUT.START.FUNCTION:\n"
"METHOD GET.REPEAT.FUNCTION: METHOD PUT.REPEAT.FUNCTION:\n"
"METHOD GET.STOP.FUNCTION:   METHOD PUT.STOP.FUNCTION:\n"
"\n"
"\\ These are to support the Hierarchy Editor\n"
"METHOD HIT:\n"
"METHOD GET.EXPANDED:\n"
"METHOD PUT.EXPANDED:\n"
"METHOD DEINSTANTIATE.HIERARCHY:\n"
"METHOD EDIT:\n"
"METHOD CLASS.NAME:\n"
"METHOD GET.HEIGHT:\n"
"METHOD GET.WIDTH:\n"
"METHOD DUMP.SOURCE:\n"
"METHOD DUMP.SOURCE.BODY:\n"
"METHOD DUMP.SOURCE.NAME:\n"
"\\\n"
"\\ for Units\n"
"METHOD EXEC.STACK:  \n"
"\n"
"( DEFINE MORPH CLASS )\n"
":CLASS OB.MORPH <SUPER OB.ELMNTS\n"
"\\ Internal Active Parameters\n"
"    IV.SHORT IV-IF-ACTIVE\n"
"    IV.SHORT IV-IF-RECURSE\n"
"    IV.LONG  IV-INVOKER    ( execution invoker )\n"
"    IV.LONG  IV-MORPH-DATA ( User data )\n"
"    IV.LONG IV-TIME-NEXT    ( execution time for next group )\n"
"    IV.LONG IV-REPCOUNT   \\ Countdown times played.\n"
"    iv.long IV-HED-EXPANDED?\n"
"\\\n"
"\\ User Settable Parameters\n"
"    IV.LONG IV-WEIGHT     \\ Statistical Weight.\n"
"    IV.LONG IV-REPEAT     \\ How many times to play.\n"
"    IV.LONG IV-START-DELAY  ( initial delay for phasing )\n"
"    IV.LONG IV-REPEAT-DELAY ( delay between reps )\n"
"    IV.LONG IV-STOP-DELAY   ( delay after stop )\n"
"    IV.LONG IV-COL-START-CFA\n"
"    IV.LONG IV-COL-REPEAT-CFA\n"
"    IV.LONG IV-COL-STOP-CFA\n"
"    IV.SHORT IV-COL-DONE?   ( true if this rep is done )\n"
"    \n"
":M DEFAULT: ( -- , Set to default condition. )\n"
"    0 iv=> iv-invoker\n"
"    false iv=> iv-if-active\n"
"    1 iv=> iv-weight\n"
"    1 iv=> iv-repeat\n"
"    0 iv=> iv-col-start-cfa\n"
"    0 iv=> iv-col-repeat-cfa\n"
"    0 iv=> iv-col-stop-cfa\n"
"    0 iv=> iv-start-delay\n"
"    0 iv=> iv-repeat-delay\n"
"    0 iv=> iv-stop-delay\n"
"    true iv=> iv-hed-expanded?\n"
";M\n"
"    \n"
":M INIT:   ( -- )\n"
"     init: super\n"
"     self default: [] ( Pick up later default definitions.)\n"
"( DEFAULT: should thus never call INIT: )\n"
";M\n"
"\n"
":M GET.NEXT.TIME:  ( -- time-next-execution )\n"
"    iv-time-next\n"
";M\n"
"\n"
":M PUT.WEIGHT: ( weight -- , store probability weight )\n"
"    iv=> iv-weight\n"
";M\n"
"\n"
":M GET.WEIGHT:  ( weight, fetch probability weight )\n"
"    iv-weight \n"
";M\n"
"\n"
":M SET.DONE: ( -- , set done flag to terminate job. )\n"
"    true iv=> iv-col-done?\n"
";M\n"
"\n"
":M PUT.START.FUNCTION: ( cfa -- , function to exec at start )\n"
"    iv=> iv-col-start-cfa\n"
";M\n"
":M GET.START.FUNCTION: ( -- cfa , function to exec at start )\n"
"    iv-col-start-cfa\n"
";M\n"
":M PUT.REPEAT.FUNCTION: ( cfa -- , function to exec at repeat )\n"
"    iv=> iv-col-repeat-cfa\n"
";M\n"
":M GET.REPEAT.FUNCTION: ( -- cfa , function to exec at repeat )\n"
"    iv-col-repeat-cfa\n"
";M\n"
":M PUT.STOP.FUNCTION: ( cfa -- , function to exec at stop )\n"
"    iv=> iv-col-stop-cfa\n"
";M\n"
":M GET.STOP.FUNCTION: ( -- cfa , function to exec at stop )\n"
"    iv-col-stop-cfa\n"
";M\n"
"\n"
":M PUT.START.DELAY: ( delay -- , store delay )\n"
"    iv=> iv-start-delay\n"
";M\n"
"\n"
":M GET.START.DELAY:  ( -- delay , fetch delay )\n"
"    iv-start-delay \n"
";M\n"
"\n"
":M PUT.REPEAT.DELAY: ( delay -- , store delay )\n"
"    iv=> iv-repeat-delay\n"
";M\n"
"\n"
":M GET.REPEAT.DELAY:  ( -- delay , fetch delay )\n"
"    iv-repeat-delay \n"
";M\n"
"\n"
":M PUT.STOP.DELAY: ( delay -- , store delay )\n"
"    iv=> iv-stop-delay\n"
";M\n"
"\n"
":M GET.STOP.DELAY:  ( -- delay , fetch delay )\n"
"    iv-stop-delay \n"
";M\n"
"\n"
":M PUT.REPEAT:  ( count -- , set repeat count)\n"
"    dup iv=> iv-repeat\n"
"    iv-repcount min iv=> iv-repcount\n"
";M\n"
"\n"
":M GET.REPEAT:  ( -- count , fetch repeat count)\n"
"    iv-repeat\n"
";M\n"
"\n"
":M GET.REPETITION:  ( -- count , fetch which repetition )\n"
"    iv-repeat iv-repcount -\n"
";M\n"
"\n"
":M PUT.REPETITION:  ( count -- , set which repetition  00004 )\n"
"    iv-repeat swap - iv=> iv-repcount\n"
";M\n"
"\n"
":M FINISH: ( -- , finish this repetition then stop )\n"
"    iv-repcount 1 min iv=> iv-repcount\n"
";M\n"
":M ?EXECUTING:  ( -- flag , true if currently executing )\n"
"    iv-if-active\n"
";M\n"
"\n"
": MO.TRACK.DONE ( time raddr -- time raddr , report completion of child )\n"
"      if-debug @\n"
"      IF 2dup >newline  name: self .\"  <-DONE- \"  name: []\n"
"         .\"    , T = \" . cr\n"
"      THEN\n"
";\n"
": MO.TRACK.EXEC ( time raddr -- time raddr , report execution of child )\n"
"    if-debug @\n"
"    IF 2dup >newline  ?dup\n"
"       IF name: []\n"
"       ELSE .\" 0 \"\n"
"       THEN .\"  -EXEC-> \"  name: self\n"
"       .\"    , T = \" . cr\n"
"    THEN\n"
";\n"
"\n"
":M DONE: ( time raddr -- , handle completion of child )\n"
"      mo.track.done 2drop\n"
";M\n"
"\n"
": SEND.DONE ( time -- , send DONE: message to invoker )\n"
"    iv-invoker ?dup  ( check for parent's existence )\n"
"    IF 0 iv=> iv-invoker\n"
"       self swap done: []   ( notify invoker )\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": IF.EXEC|DROP ( n cfa -- , execute or drop )\n"
"    ?dup\n"
"    IF\n"
"        -1 exec.stack?\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": COL.EXEC.START ( -- , execute start function )\n"
"    self iv-col-start-cfa if.exec|drop   \\ 00001\n"
";\n"
"\n"
": COL.EXEC.REPEAT ( -- , execute repeat function )\n"
"    self iv-col-repeat-cfa if.exec|drop   \\ 00001\n"
";\n"
"\n"
": COL.EXEC.STOP  ( -- , perform stop function )\n"
"    self iv-col-stop-cfa if.exec|drop   \\ 00001\n"
";\n"
"\n"
": MORPH.STOP  ( time -- )\n"
"    false iv=> iv-if-active\n"
"    0 iv=> iv-repcount\n"
"    col.exec.stop\n"
"    iv-stop-delay + dup vtime! ( adjust time )\n"
"    send.done  ( notify parent, if any )\n"
";\n"
"\n"
":M TERMINATE: ( time -- )\n"
"    iv-if-active\n"
"    IF  morph.stop\n"
"    THEN\n"
";M\n"
"\n"
":M STOP:  ( -- )\n"
"    time@ self terminate: []\n"
";M\n"
"\n"
":M ABORT: ( -- , abort self and parent. )\n"
"    iv-invoker ?dup  ( check for parent's existence )\n"
"    IF 0 iv=> iv-invoker   ( clear for later execution. )\n"
"       abort: []   ( abort invoker )\n"
"    THEN\n"
"    self stop: []\n"
";M\n"
"\n"
":M PUT.INVOKER: ( invoker -- , set return address for DONE: )\n"
"    iv=> iv-invoker\n"
"    true iv=> iv-if-active\n"
";M\n"
"\n"
":M GET.INVOKER: ( invoker -- , get morph who executed )\n"
"    iv-invoker\n"
";M\n"
"\n"
": MORPH.CHECK.STOP  ( time -- , send done if parent and stop )\n"
"    iv-if-recurse\n"
"    IF  0 iv=> iv-if-recurse\n"
"        \" MORPH.CHECK.STOP\" \" Recursion prevented!\"\n"
"        er_fatal ob.report.error\n"
"    THEN\n"
"\\\n"
"    iv-if-active\n"
"    IF TRUE iv=> iv-if-recurse\n"
"\\ This next call could trigger recursion!!!!\n"
"       self terminate: []\n"
"       if-debug @\n"
"       IF \" MORPH.CHECK.STOP\" \" Morph already executing!\"\n"
"          er_return ob.report.error\n"
"       THEN\n"
"       FALSE iv=> iv-if-recurse\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": COL.DO.REPEAT  ( -- , perform repeat function and decr counter )\n"
"    iv-repcount 1- dup iv=> iv-repcount 0>\n"
"    IF\n"
"        col.exec.repeat\n"
"        iv-repeat-delay iv+> iv-time-next\n"
"        false iv=> iv-col-done?\n"
"    THEN\n"
";\n"
"\n"
"\\ This method is used within hierarchy for controlling execution.\n"
":M ?EXECUTE: ( time invoker -- time true | false )\n"
"    mo.track.exec\n"
"    over morph.check.stop\n"
"    put.invoker: self ( -- time )\n"
"    false iv=> iv-col-done?\n"
"    iv-repeat 0>\n"
"    IF\n"
"        dup vtime!\n"
"        col.exec.start\n"
"        iv-start-delay + dup iv=> iv-time-next vtime! ( apply delay )\n"
"        iv-repeat iv=> iv-repcount  ( set down-counter )\n"
"        self custom.exec: []   ( late bind to specific method )\n"
"        dup\n"
"        IF\n"
"            col.exec.stop\n"
"            over iv-stop-delay + vtime! ( adjust time )\n"
"            0 iv=> iv-invoker  false iv=> iv-if-active\n"
"        THEN\n"
"    ELSE true  ( all done )\n"
"    THEN\n"
";M\n"
"\n"
":M EXECUTE: ( time invoker --, exec all morphs in collection )\n"
"    self ?execute: []  IF drop THEN\n"
";M\n"
"\n"
":M START.AT: ( time -- , execute starting then )\n"
"    0 ( no parent )\n"
"    self execute: []  ( use latest execution method )\n"
";M\n"
"\n"
":M START: ( -- , execute now )\n"
"    rtc.time@ ( 00001 )\n"
"    start.at: self\n"
";M\n"
"\n"
"( Task is called repeatedly by multitasker )\n"
":M TASK: ( -- , do single time slice )\n"
";M\n"
"\n"
":M ?HIERARCHICAL:  ( -- flag , true if can contain other morphs)\n"
"    false\n"
";M\n"
"\n"
"CREATE MORPH-INDENT 0 ,\n"
"\n"
":M PRINT.HIERARCHY: ( -- , print just name , doesn't nest )\n"
"    >newline morph-indent @ spaces name: self >newline\n"
";M\n"
"\n"
":M FREE.HIERARCHY: ( -- , Just free self )\n"
"    self ?hierarchical: []\n"
"    IF  reset: self\n"
"        BEGIN manyleft: self\n"
"        WHILE next: self free.hierarchy: []\n"
"        REPEAT\n"
"    THEN\n"
"    self free: []\n"
";M\n"
"\n"
":M DEFAULT.HIERARCHY: ( -- , Just default self )\n"
"    self ?hierarchical: []\n"
"    IF  reset: self\n"
"        BEGIN manyleft: self\n"
"        WHILE next: self default.hierarchy: []\n"
"        REPEAT\n"
"    THEN\n"
"    self default: []\n"
";M\n"
"\n"
":M CLEANUP:  ( -- , easy cleanup of entire hierarchy )\n"
"    self default.hierarchy: []\n"
"    self free.hierarchy: []\n"
"    self free: []\n"
";M\n"
"\n"
":M PUT.DATA: ( data -- , Place User data in Morph )\n"
"    iv=> iv-morph-data\n"
";M\n"
":M GET.DATA: ( -- data , Get User data from Morph )\n"
"    iv-morph-data\n"
";M\n"
"\n"
"\\ This is used when the names of several morphs must be stored\n"
"\\ indirectly.\n"
"\\ Similar to GET.NAME: but never uses the PAD, ie. NFA->$ .\n"
":M GET.NAME|NFA: ( -- $name | nfa )\n"
"    iv-name ?dup 0=\n"
"    IF address: self pfa->nfa\n"
"    THEN\n"
";M\n"
"\n"
":M BUILD: ( ? -- )\n"
";M\n"
":M PREFAB: ( -- )\n"
";M\n"
"\n"
"\n"
":M PRINT: ( -- , print it )\n"
"     print: super\n"
"     .\" Weight  = \" iv-weight . cr\n"
"     .\" Repeat  = \" iv-repeat . cr ?pause\n"
"\\\n"
"     .\" Delays:\" cr\n"
"     .\"  Start  = \" iv-start-delay . cr\n"
"     .\"  Repeat = \" iv-repeat-delay . cr\n"
"     .\"  Stop   = \" iv-stop-delay . cr ?pause\n"
"\\\n"
"     .\" Functions:\" cr\n"
"     .\"  Start  = \" iv-col-start-cfa cfa. cr\n"
"     .\"  Repeat = \" iv-col-repeat-cfa cfa. cr\n"
"     .\"  Stop   = \" iv-col-stop-cfa cfa. cr ?pause\n"
";M\n"
"\n"
"\\ Support for Morph Hierarchy Editor(s)\n"
"14 constant HED_LINE_HEIGHT\n"
"10 constant HED_INDENT_BY\n"
"variable HED-INDENT  \\ current level of indentation\n"
"variable HED-YPOS    \\ used when drawing or scanning\n"
"variable HED-XLEFT   \\ left margin\n"
"\n"
":M PUT.EXPANDED: ( flag -- )\n"
"    iv=> iv-hed-expanded?\n"
";M\n"
":M GET.EXPANDED: ( -- flag )\n"
"    iv-hed-expanded?\n"
";M\n"
"\n"
":M DEINSTANTIATE.HIERARCHY:  ( -- , stub for non-hierarchical morphs )\n"
";M\n"
"\n"
":M CLASS.NAME: ( -- $name )\n"
"    \" OB.MORPH\"\n"
";M\n"
"\n"
":M GET.HEIGHT: ( -- height , when drawn )\n"
"    HED_LINE_HEIGHT\n"
";M\n"
"\n"
":M GET.WIDTH: ( -- width , when drawn )\n"
"    300\n"
";M\n"
"\n"
"0 constant MHED_EXP_X\n"
"30 constant MHED_EDIT_X\n"
"60 constant MHED_REPEAT_X\n"
"100 constant MHED_NAME_X\n"
"\n"
":M XY.DRAW: { xpos ypos -- }\n"
"\\ Draw Line\n"
"    xpos ypos gr.move\n"
"    xpos 200 + ypos gr.draw\n"
"    ypos hed_line_height + 2- -> ypos\n"
"\\\n"
"\\ Draw Expand gadget depending on state.\n"
"    xpos mhed_exp_x + ypos gr.move\n"
"    many: self 0>\n"
"    self ?hierarchical: [] AND\n"
"    IF\n"
"        get.expanded: self\n"
"        IF\n"
"            \" [-]\"\n"
"        ELSE\n"
"            \" [X]\"\n"
"        THEN\n"
"    ELSE\n"
"        \" [ ]\"\n"
"    THEN\n"
"    gr.text\n"
"\\\n"
"\\ Draw Edit Gadget\n"
"    xpos mhed_edit_x + ypos gr.move\n"
"    \" [E]\" gr.text\n"
"\\\n"
"\\ Draw Repeat Count\n"
"    xpos mhed_repeat_x + ypos gr.move\n"
"    \" [\" gr.text\n"
"    get.repeat: self n>text gr.type\n"
"    \" ]\" gr.text\n"
"\\\n"
"\\ Draw Name\n"
"    xpos mhed_name_x + ypos gr.move\n"
"    get.name: self gr.text\n"
"\\\n"
"\\ Draw Class\n"
"    \"   - \" gr.text self class.name: [] gr.text\n"
";M\n"
"\n"
":M EDIT: ( -- )\n"
"    .\" Edit \" name: self cr\n"
";M\n"
"\n"
"variable MHED-CUR-MORPH\n"
"\n"
"\\ Callback functions for Popup Text Requesters\n"
": MHED.SET.REPEAT ( $text -- )\n"
"    number?\n"
"    IF\n"
"        drop mhed-cur-morph @ put.repeat: []\n"
"    ELSE\n"
"        .\" Bad number!\" cr \\ %Q\n"
"    THEN\n"
";\n"
"\n"
": MHED.SET.NAME ( $text -- )\n"
"    mhed-cur-morph @ put.name: []\n"
";\n"
"\n"
":M HIT: { xoff yoff -- }\n"
"\\ offsets from top left corner\n"
"    xoff mhed_edit_x <\n"
"    IF\n"
"        get.expanded: self 0= put.expanded: self\n"
"    ELSE\n"
"        xoff mhed_repeat_x <\n"
"        IF\n"
"            self edit: []\n"
"        ELSE\n"
"            xoff mhed_name_x <   \\ edit REPEAT\n"
"            IF\n"
"                ev.getxy\n"
"                yoff -\n"
"                swap xoff - mhed_repeat_x + swap\n"
"                popt.set.xy.dc\n"
"\\\n"
"                get.repeat: self n>text   \\ set default text\n"
"                pad off pad $append\n"
"                pad\n"
"                8  'c mhed.set.repeat\n"
"                self mhed-cur-morph !\n"
"                open.popup.text\n"
"            ELSE\n"
"                ev.2click?\n"
"                IF\n"
"                    ev.getxy yoff -\n"
"                    swap xoff - mhed_name_x + swap\n"
"                    popt.set.xy.dc\n"
"\\\n"
"                    self mhed-cur-morph !\n"
"                    get.name: self\n"
"                    16  'c mhed.set.name\n"
"                    open.popup.text\n"
"                THEN\n"
"            THEN\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
"\\ generate source code to regenerate this object\n"
":M DUMP.SOURCE.NAME: ( -- )\n"
"    >newline\n"
"    self class.name: [] $type space name: self cr\n"
";M\n"
"\n"
": DUMP.MORPH.BODY ( -- , dump things common to all morphs )\n"
"    >newline\n"
"    iv-weight 1 = not\n"
"    IF\n"
"        tab iv-weight . .\"  put.weight: \" name: self cr\n"
"    THEN\n"
"    iv-repeat 1 = not\n"
"    IF\n"
"        tab iv-repeat . .\"  put.repeat: \" name: self cr\n"
"    THEN\n"
"    iv-start-delay 0>\n"
"    IF\n"
"        tab iv-start-delay . .\"  put.start.delay: \" name: self cr\n"
"    THEN\n"
"    iv-repeat-delay 0>\n"
"    IF\n"
"        tab iv-repeat-delay . .\"  put.repeat.delay: \" name: self cr\n"
"    THEN\n"
"    iv-stop-delay 0>\n"
"    IF\n"
"        tab iv-stop-delay . .\"  put.stop.delay: \" name: self cr\n"
"    THEN\n"
"\\\n"
"\\ Functions\n"
"    iv-col-start-cfa 0>\n"
"    IF\n"
"        tab .\" 'c \" iv-col-start-cfa cfa.\n"
"        .\"  put.start.function: \" name: self cr\n"
"    THEN\n"
"    iv-col-repeat-cfa 0>\n"
"    IF\n"
"        tab .\" 'c \" iv-col-repeat-cfa cfa.\n"
"        .\"  put.repeat.function: \" name: self cr\n"
"    THEN\n"
"    iv-col-stop-cfa 0>\n"
"    IF\n"
"        tab .\" 'c \" iv-col-stop-cfa cfa.\n"
"        .\"  put.stop.function: \" name: self cr\n"
"    THEN\n"
";\n"
":M DUMP.SOURCE.BODY: ( -- )\n"
";M\n"
"\n"
":M DUMP.SOURCE:\n"
"    self dump.source.name: []\n"
"    self dump.source.body: []\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\\ Handy for printing names that might be zero.\n"
": OB.NAME ( object -- , print name if non-zero )\n"
"    ?dup IF name: []\n"
"    ELSE .\" 0\"\n"
"    THEN\n"
";\n"
"\n"
"V: HMSL-ABORT   ( Flag set true for top loop to abort. )\n"
"\n"
": EXEC.OBJ|CFA  ( cfa|obj -- , execute as object or cfa )\n"
"    dup ob.valid?\n"
"    IF\n"
"        .\" WARNING: EXEC.OBJ|CFA calling EXEC.STACK: []\" cr\n"
"        EXEC.STACK: []\n"
"    ELSE\n"
"        EXECUTE\n"
"    THEN\n"
";\n"
"\n"
": SYS.INIT\n"
"    sys.init\n"
"    'c exec.obj|cfa is deferred.execute\n"
";\n"
"\n"
": SYS.TERM\n"
"    'c execute is deferred.execute\n"
"    sys.term\n"
";\n"
"\n";

const char* morph_fth = (const char*) temp_binary_data_44;

//================== morph_lists.fth ==================
static const unsigned char temp_binary_data_45[] =
"\\ These lists are used for tracking morphs that are created in the system.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 5/24/87 Add SYS.INIT\n"
"\\ MOD: PLB 10/28/87 Add ML.CLEAR to SYS.RESET\n"
"\\ MOD: PLB 2/18/92 Add ML.CLEAR to SYS.CLEANUP\n"
"\\ 00001 PLB 4/27/92 Added ML.VALIDATE and [FORGET]\n"
"\n"
"ANEW TASK-MORPH_LISTS\n"
"\n"
"9999 constant ML_GRID_FACTOR   ( Internal. Don't modify. )\n"
"\n"
"( Morph tracking lists. )\n"
"OB.OBJLIST SHAPE-HOLDER\n"
"OB.OBJLIST COLL-HOLDER\n"
"OB.OBJLIST STRUCT-HOLDER\n"
"OB.OBJLIST PLAYER-HOLDER\n"
"OB.OBJLIST PRODUCTION-HOLDER\n"
"\n"
"\\ Controls whether future defined morphs have their name placed in list.\n"
"CREATE ML-IF-INIT 0 ,\n"
"CREATE ML-IF-RECORD 0 ,\n"
"\n"
": ML.INIT  ( -- )\n"
"    ml-if-init @ NOT\n"
"    IF  64 new: shape-holder\n"
"        64 new: coll-holder\n"
"        32 new: struct-holder\n"
"        32 new: player-holder\n"
"        32 new: production-holder\n"
"        true ml-if-init !\n"
"        true ml-if-record !\n"
"    THEN\n"
";\n"
"\n"
": ML.ADD ( rel_morph_base rel_list_base -- , Add to list )\n"
"    ml-if-record @\n"
"    IF add: []\n"
"    ELSE 2drop\n"
"    THEN\n"
";\n"
"\n"
": ML.CLEAR   ( -- , clear all holding arrays )\n"
"     clear: shape-holder\n"
"     clear: coll-holder\n"
"     clear: struct-holder\n"
"     clear: player-holder\n"
"     clear: production-holder\n"
";\n"
"\n"
": ML.PRINT ( -- , Print contents of all holders )\n"
"    cr .\" SHAPES --------\" print: shape-holder\n"
"       .\" COLLECTIONS----\" print: coll-holder\n"
"       .\" STRUCTURES ----\" print: struct-holder\n"
"       .\" PLAYERS -------\" print: player-holder\n"
"       .\" PRODUCTIONS----\" print: production-holder\n"
";\n"
"\n"
": ML.FREE\n"
"     freeall: shape-holder\n"
"     freeall: coll-holder\n"
"     freeall: struct-holder\n"
"     freeall: player-holder\n"
"     freeall: production-holder\n"
";\n"
"\n"
": ML.TERM\n"
"    ml.free\n"
"    free: shape-holder\n"
"    free: coll-holder\n"
"    free: struct-holder\n"
"    free: player-holder\n"
"    free: production-holder\n"
"    false ml-if-init !\n"
"    false ml-if-record !\n"
";\n"
"\n"
"\n"
": OBJLIST.VALIDATE  { objlist -- , remove any invalid objects }\n"
"    many: objlist ?dup\n"
"    IF dup 0\n"
"       DO dup i - 1- get: objlist ob.valid? NOT\n"
"           IF dup i - 1- remove: objlist\n"
"              .\" Removing invalid object from\" name: objlist cr\n"
"           THEN\n"
"       LOOP drop\n"
"    THEN\n"
";\n"
"\n"
": ML.VALIDATE  ( -- , make sure all objects in lists are valid )\n"
"    shape-holder objlist.validate\n"
"    coll-holder objlist.validate\n"
"    struct-holder objlist.validate\n"
"    player-holder objlist.validate\n"
"    production-holder objlist.validate\n"
";\n"
"\n"
": [FORGET]  ( -- , clean forgotten objects out of lists )\n"
"    [forget]\n"
"    'c task-morph_lists here <  \\ are lists still loaded?\n"
"    IF\n"
"        ml.validate\n"
"    THEN\n"
";\n"
"\n"
"\n"
": SYS.INIT sys.init ml.init ;\n"
": SYS.RESET sys.reset ml.clear ;\n"
": SYS.CLEANUP sys.cleanup ml.clear ;\n"
": SYS.TERM ml.term sys.term ;\n"
"\n";

const char* morph_lists_fth = (const char*) temp_binary_data_45;

//================== ob_actions.fth ==================
static const unsigned char temp_binary_data_46[] =
"\\ Action  definition\n"
"\\\n"
"\\ ACTIONS are the basic units of the HMSL PERFORM environment, and\n"
"\\ are arbitarily definable stimulus-response events with a great\n"
"\\ deal of on-board intelligence\n"
"\\\n"
"\\ ACTIONS are defined as PARALLEL COLLECTIONS  with one executable\n"
"\\ cell -- consisting of a STIMULUS and a RESPONSE.\n"
"\\ Instance variables are used for the INIT, TERM, STIMULUS\n"
"\\ and the  RESPONSE. The stimulus must leave a\n"
"\\ Boolean on the stack, and the response must \"eat\" that boolean\n"
"\\ in deciding whether to perform or not.\n"
"\\ INIT and TERM are executed whenever an ACTION is turned on or off\n"
"\\\n"
"\\ ACTIONS have instance variables for:  ACTION-ON?,\n"
"\\ ACTION-PRIORITY, STIMULUS, RESPONSE, RESPONSE-ARG, STIMULUS-ARG\n"
"\\ LOCAL-COUNTER\n"
"\\\n"
"\\ The ACTION-TABLE contains 64 possible actions, 16 for each of the\n"
"\\ priorities 0-3.\n"
"\\\n"
"\\ PRIORITIES set at 0 for a default. Note that PRIORITIES\n"
"\\ are simply renamed collection weights.\n"
"\\\n"
"\\ Author: Larry Polansky\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"\\ MOD: PLB 2/28/87 Changed superclass to OB.PRODUCTION\n"
"\\ MOD: PLB 3/5/87  Put repeat in action EXECUTE: method.\n"
"\\ MOD: PLB 5/24/87 Make turn.self.off turn off grid.\n"
"\\      Remove SET.CURRENT-ACTION: method , set CURRENT-ACTION\n"
"\\      for ACT.ON: and ACT.OFF:\n"
"\\ MOD: PLB 6/10/87 Add DEFAULT: , set repeat to 1\n"
"\\ MOD: PLB 10/29/87 Remove ACTION-# references.\n"
"\\ MOD: PLB 4/11/90 Remove definition of CFA.\n"
"\\ MOD: PLB 2/4/91 Add TERMINATE: to call TERM word.\n"
"\\\t\tChange EXECUTE to call CUSTOM.EXEC:\n"
"\\ MOD: PLB 6/15/91 Increment ACTION-GLOBAL-COUNTER in TASK:\n"
"\\\n"
"\\ ===========================================================\n"
"\n"
"ANEW TASK-OB_ACTIONS\n"
"\n"
"( Used for distributing actions and in unweighted behavior)\n"
"V: ACTION-NEXT-PRIORITY\n"
": ACTION.NEXT.PRIORITY  ( -- priority )\n"
"    action-next-priority @\n"
"    1+ 3 and\n"
"    dup action-next-priority !\n"
";\n"
"\n"
"\\ \"system\" variables used for ACTIONs include:\n"
"\\  how many actions, global counter (agc)\n"
"\n"
"\\ action methods\n"
"method put.priority:         method get.priority:\n"
"method get.stimulus:         method get.response:\n"
"method act.on:               method act.off:\n"
"method put.local-counter:    method get.local-counter:\n"
"method reset.local-counter:  method act.toggle:\n"
"method inc.priority:         method dec.priority:\n"
"method get.response-arg:     method put.response-arg:\n"
"method put.stimulus-arg:     method get.stimulus-arg:\n"
"method put.stimulus:         method put.response:\n"
"method get.init:             method get.term:\n"
"method put.init:             method put.term:\n"
"method action.on?:\n"
"method set.current-action:\n"
"\n"
":CLASS OB.ACTION   <SUPER OB.PRODUCTION\n"
"   iv.long  ACTION-ON?\n"
"   iv.long  STIMULUS\n"
"   iv.long  RESPONSE\n"
"   iv.short LOCAL-COUNTER\n"
"   iv.long  RESPONSE-ARG\n"
"   iv.long  STIMULUS-ARG\n"
"   iv.long  ACTION-INIT\n"
"   iv.long  ACTION-TERM\n"
"\n"
"\\ actions use inherited collection weights as priorities\n"
":m PUT.PRIORITY: ( n {0-3} -- puts priority to action )\n"
"    dup 3 >\n"
"   IF cr .\" !!! BAD PRIORITY -- should be from 0-3 \" drop\n"
"   ELSE put.weight: super\n"
"   THEN\n"
";m\n"
"\n"
":m INIT:\n"
"   init: super ( does default )\n"
"   action.next.priority put.priority: self \\ distribute evenly\n"
";M\n"
"\n"
":M DEFAULT: ( -- )\n"
"   default: super\n"
"   0 iv=> local-counter\n"
"   0 iv=> action-on?   \\ off\n"
"   'c never  iv=> stimulus\n"
"   'c do.nothing  iv=> response\n"
"   'c noop iv=> action-init\n"
"   'c noop iv=> action-term\n"
"   1 iv=> iv-repeat ( This was sometimes zero!?)\n"
";M\n"
"\n"
":m GET.PRIORITY: ( --- ,returns priority {0-3} )\n"
"   get.weight: super\n"
";m\n"
"\n"
"\n"
":m GET.RESPONSE-ARG: ( --- n )\n"
"   response-arg\n"
";m\n"
"\n"
":m PUT.RESPONSE-ARG: ( n --- )\n"
"   iv=> response-arg\n"
";m\n"
"\n"
":m GET.STIMULUS-ARG: ( --- n)\n"
"   stimulus-arg\n"
";m\n"
"\n"
":m PUT.STIMULUS-ARG: ( n --- )\n"
"  iv=>  stimulus-arg\n"
";m\n"
"\n"
"\\ Syntax for following words, all of which use CFA's\n"
"\\ in ACTION instance variables :\n"
"\\ 'c FOO put.(init,term,stimulus,response): name-of-action\n"
"\\ FOO must be an executable FORTH routine. If Stimulus, it must\n"
"\\ leave a value (flag) on the stack. If a Response, it must\n"
"\\ eat that value. INIT and TERM are routines that turn things\n"
"\\ on or off, or set and reset, etc.\n"
"\\ The \"get:\" methods, return executable routines (CFA's), and\n"
"\\  are used in EXECUTE:\n"
"\n"
":m PUT.STIMULUS: ( CFA --- ,stick forth word into stimulus field )\n"
"   iv=> stimulus\n"
";m\n"
"\n"
":m PUT.RESPONSE: ( CFA --- ,stick forth word into response field )\n"
"   iv=>  response\n"
";m\n"
"\n"
":m GET.RESPONSE:  ( --- CFA )\n"
"   response  ( returns executable routine )\n"
";m\n"
"\n"
":m GET.STIMULUS: ( --- CFA )\n"
"   stimulus  ( returns executable routine )\n"
";m\n"
"\n"
":m GET.INIT: ( --- CFA )\n"
"    action-init\n"
";m\n"
"\n"
":m GET.TERM: ( --- CFA )\n"
"   action-term\n"
";m\n"
"\n"
":m PUT.INIT: ( CFA --- )\n"
"     iv=> action-init\n"
";m\n"
"\n"
":m PUT.TERM: ( CFA --- )\n"
"    iv=> action-term\n"
";m\n"
"\n"
":m ACT.ON: ( --- , turns action on and executes INIT  )\n"
"    1 iv=> action-on?\n"
"    self current-action !\n"
"    get.init: self execute\n"
";m\n"
"\n"
":m ACT.OFF: ( --- , turns action off and executes TERM )\n"
"    0 iv=> action-on?\n"
"    self current-action !\n"
"    get.term: self execute\n"
";m\n"
"\n"
":M TERMINATE: ( time -- )\n"
"\t.\" Terminate: ACTION = \" name: self cr\n"
"\tterminate: super\n"
"\tact.off: self\n"
";M\n"
"\n"
":m ACTION.ON?:  ( --- 1 or 0, indicating whether action is on or off )\n"
"   action-on?\n"
";m\n"
"\n"
":m ACT.TOGGLE:\n"
"( --- , toggles action on or off, used by ACTION-SCREEN )\n"
"   action-on?\n"
"   IF act.off: self\n"
"   ELSE act.on: self\n"
"   THEN\n"
";m\n"
"\n"
"\\ n.b.: highest priority is 0 !!!\n"
":m DEC.PRIORITY:  ( --- , decrements priority, clips at 3  )\n"
"   get.priority: self 1+ 3 min  put.priority: self\n"
";m\n"
"\n"
":m INC.PRIORITY: (  --- ,increments priority, clips to 0 )\n"
"   get.priority: self 1- 0 max  put.priority: self\n"
";m\n"
"\n"
":m PRINT:\n"
"    print: super-dooper\n"
"    .\" Priority = \" get.priority: self . cr\n"
"    .\" Stimulus = \" get.stimulus: self cfa. cr\n"
"    .\" Response = \" get.response: self cfa. cr\n"
"    .\" init  = \" get.init: self cfa. cr\n"
"    .\" term  = \" get.term: self cfa. cr\n"
"    action.on?: self\n"
"    IF  .\" Action on ! \" cr\n"
"    THEN\n"
";m\n"
"\n"
":m RESET.LOCAL-COUNTER: ( --- , sets alc to 0 )\n"
"    0 iv=> local-counter\n"
";m\n"
"\n"
":m GET.LOCAL-COUNTER: ( --- alc )\n"
"    local-counter\n"
";m\n"
"\n"
":m PUT.LOCAL-COUNTER: ( alc-value --- )\n"
"    iv=> local-counter\n"
";m\n"
"\n"
"\\ ==========================================\n"
"\n"
"\\ redefined execute: which increments local counter, stores ACTION in\n"
"\\ current-action, and executes stimulus and then response.\n"
"\\ note that EXECUTE: for actions does not follow the HMSL protocol\n"
"\\ specifically, in that there is no time or sender address, since\n"
"\\ none is needed. We have continued to call it EXECUTE: to identify\n"
"\\ it functionally with other morphs. This works ONLY because actions\n"
"\\ are executed only from action-table, and cannot be executed from\n"
"\\ other morphs\n"
"\\ CHANGED TO TASK: to avoid conflicts with HMSL\n"
"\n"
":m TASK: ( -- , only called from ACTION-TABLE )\n"
"\\ stores address of action for turn.self.off routine...\n"
"     self current-action !\n"
"     action-on?   \\ only execute: if ACTION is on\n"
"     IF  local-counter 1+ iv=> local-counter\n"
"\t\t1 action-global-counter +!\n"
"         iv-repeat 0\n"
"         DO  stimulus execute\n"
"             response execute\n"
"         LOOP\n"
"\\ execute fuctions like a Production would.\n"
"\\ time@ 0 execute: super \\ this is obsolete because\n"
"\t\ttime@ vtime!\n"
"\t\tcustom.exec: super 2drop\n"
"     THEN\n"
";m\n"
"\n"
"\n"
";CLASS\n"
"\n";

const char* ob_actions_fth = (const char*) temp_binary_data_46;

//================== ob_array.fth ==================
static const unsigned char temp_binary_data_47[] =
"\\ @(#) ob_array.fth 96/06/11 1.1\n"
"\\ Basic Classes of Array.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 Delta Research\n"
"\\\n"
"\\ MOD: PLB 5/17/91 Split OBJ_ARRAY into OBJ_OBJECT & OBJ_ARRAY\n"
"\\ 00001 PLB 8/27/91 Fixed }stuff when filling completely.\n"
"\n"
"ANEW TASK-OB_ARRAY\n"
"\n"
"\n"
"\\ Support ARRAY classes ----------------------------------\n"
"METHOD AT:              METHOD TO:\n"
"METHOD NEW:             METHOD LIMIT:\n"
"METHOD FREE:            METHOD WIDTH:\n"
"METHOD RANGE:           METHOD FILL:\n"
"METHOD SIZE:            METHOD USE.DICT:\n"
"METHOD DATA.ADDR:       METHOD STUFF:\n"
"METHOD INDEXOF:         METHOD +TO:\n"
"METHOD SET.WIDTH:       METHOD DO.RANGE:\n"
"METHOD EXTEND:          METHOD EMPTY:\n"
"METHOD }STUFF:          METHOD MANY:\n"
"METHOD ?NEW:\n"
"\n"
"U: IF-RANGE-CHECK  ( Use range checking on declared arrays )\n"
"TRUE IF-RANGE-CHECK !\n"
"\n"
": RUN.FASTER  ( -- , set flags to NOT error check. )\n"
"    false if-range-check !\n"
"    false ob-if-check-bind !\n"
";\n"
": RUN.SAFER  ( -- , set flags to error check. )\n"
"    true if-range-check !\n"
"    true ob-if-check-bind !\n"
";\n"
"\n"
"\\ Byte array definition.\n"
":CLASS OB.BARRAY  <SUPER OBJECT\n"
"    IV.SHORT IV-WIDTH    ( width of cell in bytes )\n"
"    IV.LONG  IV-#CELLS   ( elements in array )\n"
"    IV.LONG  IV-PNTR     ( pointer to area in extended memory )\n"
"\\ flag for whether to allocate space from dictionary or heap\n"
"    IV.SHORT IV-USE-DICT\n"
"\\ CFAS for use in basic array access, determine width.\n"
"    IV.LONG  IV-AR-CFA-AT\n"
"    IV.LONG  IV-AR-CFA-TO\n"
"    IV.SHORT IV-RANGE-CHECK?   ( Flag for range checking. )\n"
"\n"
"\\ Define @ and ! for different array widths.\n"
": AR.@ ( index -- value )\n"
"    cell* iv-pntr + @\n"
";\n"
": AR.W@ ( index -- value )\n"
"    2* iv-pntr + w@\n"
";\n"
": AR.C@ ( index -- value )\n"
"    iv-pntr + c@\n"
";\n"
"\n"
": AR.! ( value index -- )\n"
"    cell* iv-pntr + !\n"
";\n"
": AR.W! ( value index -- )\n"
"    2* iv-pntr + w!\n"
";\n"
": AR.C! ( value index -- )\n"
"    iv-pntr + c!\n"
";\n"
"\n"
": <RANGE:>  ( index -- , check for valid range, make subroutine for speed )\n"
"    dup 0 iv-#cells 1- within?\n"
"    IF drop ( OK )\n"
"    ELSE >newline dup . 0 <\n"
"        IF   \" Index < 0\"\n"
"        ELSE \" Index out of range\"\n"
"        THEN \" RANGE: ARRAY\" swap\n"
"        er_fatal ob.report.error  ( does not return )\n"
"    THEN\n"
";\n"
"\n"
":M RANGE: ( index -- , check for index out of range )\n"
"    <range:>\n"
";M\n"
"\n"
"\\ Define with range checking for debugging and testing.\n"
": AR.RANGE.@ ( index -- value )\n"
"    dup <range:>   ar.@\n"
";\n"
": AR.RANGE.W@ ( index -- value )\n"
"    dup <range:>   ar.w@\n"
";\n"
": AR.RANGE.C@ ( index -- value )\n"
"    dup <range:>   ar.c@\n"
";\n"
"\n"
": AR.RANGE.! ( value index -- )\n"
"    dup <range:>   ar.!\n"
";\n"
": AR.RANGE.W! ( value index -- )\n"
"    dup <range:>   ar.w!\n"
";\n"
": AR.RANGE.C! ( value index -- )\n"
"    dup <range:>   ar.c!\n"
";\n"
"\n"
"\n"
":M USE.DICT:   ( flag -- , use dictionary for data? )\n"
"    iv=> iv-use-dict\n"
";M\n"
"\n"
":M FREE: ( -- , free memory used for array )\n"
"    iv-pntr    iv-use-dict  not\n"
"    and IF\n"
"        self empty: []   ( late bound empty )\n"
"        iv-pntr  mm.free\n"
"        0 iv=> iv-pntr  ( mark as unallocated )\n"
"        0 iv=> iv-#cells  ( for range checking )\n"
"    THEN\n"
";M\n"
"\n"
"\n"
":M DATA.ADDR: ( -- address_of_allocated_data )\n"
"    iv-pntr\n"
";M\n"
"\n"
":M LIMIT: ( -- #cells , RETURN # ELEMENTS ALLOCATED )\n"
"    iv-#cells\n"
";M\n"
"\n"
":M SIZE:  ( -- #ENTRIES , will be used more for later classes )\n"
"    iv-#cells\n"
";M\n"
"\n"
":M MANY:  ( -- , how many cells are \"valid\" )\n"
"    iv-#cells\n"
";M\n"
"\n"
"\\ Fast versions for internal use by methods.\n"
": TO.SELF  ( value index -- , store value in array )\n"
"    iv-ar-cfa-to execute\n"
";\n"
": AT.SELF ( index -- value , fetch value from array )\n"
"    iv-ar-cfa-at execute\n"
";\n"
"\n"
":M TO: ( value index -- , store value in array )\n"
"    iv-ar-cfa-to execute\n"
";M\n"
"\n"
":M AT: ( index -- value , fetch value from array )\n"
"    iv-ar-cfa-at execute\n"
";M\n"
"\n"
": AR.SELECT.CFA  ( Select CFAs based on width and range_check. )\n"
"    iv-range-check?\n"
"    IF iv-width         ( WITH Range checking )\n"
"        CASE\n"
"        cell OF 'c ar.range.@ iv=> iv-ar-cfa-at\n"
"            'c ar.range.! iv=> iv-ar-cfa-to\n"
"        ENDOF\n"
"    2    OF 'c ar.range.w@ iv=> iv-ar-cfa-at\n"
"        'c ar.range.w! iv=> iv-ar-cfa-to\n"
"    ENDOF\n"
"    1    OF 'c ar.range.c@ iv=> iv-ar-cfa-at\n"
"        'c ar.range.c! iv=> iv-ar-cfa-to\n"
"    ENDOF\n"
"    \" AR.SELECT.RANGE\" \" Illegal array width!\"\n"
"    er_fatal ob.report.error\n"
"    ENDCASE\n"
"    ELSE iv-width         ( NO range checking. )\n"
"        CASE\n"
"        cell OF 'c ar.@ iv=> iv-ar-cfa-at\n"
"            'c ar.! iv=> iv-ar-cfa-to\n"
"        ENDOF\n"
"    2    OF 'c ar.w@ iv=> iv-ar-cfa-at\n"
"        'c ar.w! iv=> iv-ar-cfa-to\n"
"    ENDOF\n"
"    1    OF 'c ar.c@ iv=> iv-ar-cfa-at\n"
"        'c ar.c! iv=> iv-ar-cfa-to\n"
"    ENDOF\n"
"    \" AR.SELECT.RANGE\" \" Illegal array width!\"\n"
"    er_fatal ob.report.error\n"
"    ENDCASE\n"
"    THEN\n"
";\n"
"\n"
":M DO.RANGE: ( flag -- , Determine whether this array checks range)\n"
"    iv=> iv-range-check?\n"
"    ar.select.cfa\n"
";M\n"
"\n"
":M WIDTH: ( -- #bytes , fetch number of bytes per array unit )\n"
"    iv-width\n"
";M\n"
"\n"
":M SET.WIDTH: ( #bytes -- , set number of bytes per array unit )\n"
"    iv-pntr  ( is data memory already allocated )\n"
"    IF  \" SET.WIDTH: OB.ARRAY\"\n"
"        \" Memory already allocated, FREE: first!\"\n"
"        er_return er.report drop\n"
"    ELSE iv=> iv-width   ( set width )\n"
"        ar.select.cfa   ( change CFAs )\n"
"    THEN\n"
";M\n"
"\n"
":M ?NEW: ( #cells -- addr | 0 , allocate data space in extended memory )\n"
"    ar.select.cfa   ( update CFAs )\n"
"    self free: []  ( free any existing data , late bound )\n"
"    dup iv=> iv-#cells\n"
"    iv-width  *  ( calculate #bytes needed )\n"
"    iv-use-dict  IF\n"
"        .\" Allocating space in dictionary!!\"\n"
"        here swap allot align\n"
"    ELSE\n"
"        mm.zalloc?\n"
"    THEN\n"
"    dup iv=> iv-pntr\n"
";M\n"
"\n"
": <NEW:ERROR> ( 0 | addr -- ,  ABORT if error )\n"
"    0= IF \" NEW:\" \" Not enough memory\"\n"
"        er_fatal ob.report.error\n"
"    THEN\n"
";\n"
"\n"
":M NEW: ( #cells -- , abort if error )\n"
"    ?new: self <new:error>\n"
";M\n"
"\n"
":M INIT: ( -- , clear data )\n"
"    init: super\n"
"    0 iv=> iv-#cells\n"
"    0 iv=> iv-pntr\n"
"    false use.dict: self\n"
"    if-range-check @ iv=> iv-range-check? ( do before SET.WIDTH: )\n"
"    1 set.width: self   ( 1 byte wide )\n"
";M\n"
"\n"
":M +TO: ( value index -- , add value to index cell )\n"
"    dup at.self rot +\n"
"    swap to.self\n"
";M\n"
"\n"
":M FILL: ( val -- , fill array with value )\n"
"    limit: self ?dup\n"
"    IF  0 DO\n"
"        dup i to.self\n"
"    LOOP drop\n"
"    ELSE drop \" FILL:\" \" No data space allocated\"\n"
"        er_return ob.report.error\n"
"    THEN\n"
";M\n"
"\n"
":M CLEAR:  ( -- , zero array )\n"
"    0 fill: self\n"
";M\n"
"\n"
":M EMPTY:  ( -- , just a stub for free: to call )\n"
";M\n"
"\n"
"\\ This is klunky is considered obsolete\n"
":M STUFF:  ( vn-1 vn-2 ... v0 N -- , stuff N values into array )\n"
"    0 ?DO\n"
"        i self to: []\n"
"    LOOP\n"
";M\n"
"\n"
":M INDEXOF:  (  val  --  [index] flag , search array for )\n"
"    0 swap  ( Set false flag. )\n"
"    self size: [] ?dup    ( anything in array? )\n"
"    IF  ( -- 0 val size )\n"
"        0 DO  ( -- 0 val )\n"
"            I  at.self over =\n"
"            IF  ( -- 0 val , replace false flag )\n"
"                nip I true\n"
"                rot   leave  ( -- i true val )\n"
"            THEN\n"
"        LOOP\n"
"    THEN\n"
"    drop  ( val )\n"
";M\n"
"\n"
":M PRINT: ( -- , print array )\n"
"    cr name: self cr\n"
"    self  size: [] ?dup\n"
"    IF  0 DO\n"
"        i dup . self at: [] . cr\n"
"        ?pause\n"
"    LOOP\n"
"    THEN\n"
";M\n"
"\n"
":M EXTEND: ( #items -- , extend data area )\n"
"    iv-pntr\n"
"    IF  >r iv-pntr dup ( -- old-memory old-memory )\n"
"        iv-#cells iv-width * ( -- om om  old-#bytes )\n"
"        r> iv+> iv-#cells    ( update #cells )\n"
"        iv-#cells iv-width * mm.alloc ( allocate new area )\n"
"        dup iv=> iv-pntr\n"
"        swap cmove  ( copy old data to new area )\n"
"        mm.free     ( free old ram )\n"
"    ELSE new: self\n"
"    THEN\n"
";M\n"
"\n"
"variable STUFF{-DEPTH\n"
"\n"
": STUFF{ ( -- , delimit stuff command , save depth )\n"
"    depth stuff{-depth !\n"
";\n"
"\n"
": STUFF.DEPTH  ( -- #items , to stuff )\n"
"    depth stuff{-depth @ - 0 max\n"
";\n"
"\n"
": <}STUFF:>  ( stuff...  --- , load it into object )\n"
"\\    iv-#cells stuff.depth < ( !!! stuff.depth thrown off by IV-#CELLS )\n"
"    stuff.depth iv-#cells >  \\ 00001\n"
"    IF   stuff.depth self new: []\n"
"    ELSE  self clear: []\n"
"    THEN\n"
"\\\n"
"    stuff.depth dup stuff{-depth ! dup 0\n"
"    ?DO 1- tuck ( --... t t tn-2 n-1 tn-1 n-1 ) self to: []\n"
"    LOOP stuff{-depth !\n"
";\n"
"\n"
":M }STUFF:  ( stuff...  --- , load it into object )\n"
"    <}stuff:>\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\n"
"\\ Wider ARRAYS -----------------------------------------------\n"
"\n"
":CLASS OB.WARRAY <SUPER OB.BARRAY\n"
"\n"
":M INIT:  ( -- , set to word width  )\n"
"    init: super\n"
"    2 set.width: self\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"METHOD EXEC:\n"
"\n"
":CLASS OB.ARRAY <SUPER OB.BARRAY\n"
"\n"
":M INIT:  ( -- , set to cell width )\n"
"    init: super\n"
"    cell set.width: self\n"
";M\n"
"\n"
":M EXEC:  ( index -- , execute CFA there )\n"
"    at: self   execute\n"
";M\n"
";CLASS\n"
"\n";

const char* ob_array_fth = (const char*) temp_binary_data_47;

//================== ob_bind.fth ==================
static const unsigned char temp_binary_data_48[] =
"\\ @(#) ob_bind.fth 96/06/11 1.1\n"
"\\ BINDING for Object Oriented Development Environment\n"
"\\\n"
"\\ This code provides words for binding a message to the appropriate\n"
"\\ method for an object.  Binding can occur at compile time ( \"EARLY\" ),\n"
"\\ or at run time, ( \"LATE\" )\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 Phil Burk\n"
"\\\n"
"\\ MOD: PLB 11/29/86 Added MAC RO calls.\n"
"\\   For relocating systems, like on the MAC, relocatable tokens\n"
"\\   are stored in the dictionary, and absolute addresses are used at\n"
"\\   run time (when possible ).  The object stack contains absolute\n"
"\\   addresses.  The CFAs for methods are stored as relocatable tokens.\n"
"\\ MOD: PLB 5/13/87 Change OS-STACK-PTR to OSSTACKPTR for Mac\n"
"\\ MOD: PLB 5/24/87 Compile time check for Illegal Method.\n"
"\\ MOD: PLB 9/6/87 Add binding for Instance Objects.\n"
"\\ MOD: PLB 9/8/87 Preshift late bound offset in OB.LATE.BIND\n"
"\\      mdh 7/2/88 changed appropriate 'literal's to 'aliterals's\n"
"\\ MOD: PLB 7/25/88 USE OB.OBJ->CFA_BASE in OB.BIND.RUN\n"
"\\ MOD: PLB 11/27/90 Warn if recursive call to self.\n"
"\\ 00001 PLB 10/24/91 Allow binding to local variables.\n"
"\\ 00002 PLB 11/12/91 Call LOCAL.REFERENCE to force fetch.\n"
"\\ 00003 PLB 1/22/92 Assembled OB.BAD.CLASS? and added odd check.\n"
"\\ 00004 PLB 6/9/92 Use OB_VALID_OBJECT in OB.VALID?\n"
"\\ 00005 PLB 8/3/92 Objects put absolute address on stack.\n"
"\\ 19961106 PLB Port binding to objects passed as local variables to Pforth.\n"
"\n"
"ANEW TASK-OB_BIND\n"
"\n"
"( Bind a method found in a CFA array. )\n"
"( Object base holds a pointer to an array of method CFAS )\n"
": OB.OBJ->CFA_BASE  ( use_obj_base -- use_cfa_base )\n"
"    @  rel->use  ( relocate rel_cfa_base )\n"
";\n"
"\n"
": OB.OBJ->CLASS  ( use_obj_base -- use_class_base )\n"
"    @ rel->use ob_cfas -\n"
";\n"
"\n"
": OB.CFA@ ( use_obj_base method_index -- rel_method_cfa , CFA for method )\n"
"    cell* swap @ rel->use\n"
"    + @\n"
";\n"
"\n"
"\\ Error Checking for binding --------------------------------------\n"
": OB.VALID?  ( abs_object -- true_if_ok )\n"
"\\ rel->use \\ 00005\n"
"    dup in.dict?   \\ FIXME - what about instantiated objects?\n"
"    IF\n"
"        s@ obj_key ob_valid_object = \\ 00004\n"
"    ELSE\n"
"        drop 0\n"
"    THEN\n"
";\n"
"\n"
": OB.IN.DICT? ( object -- flag )\n"
"\\ rel->use \\ 00005\n"
"    in.dict?\n"
";\n"
"\n"
": OB.BAD.CLASS? ( use_class_base -- bad? )\n"
"    dup 1 and\n"
"    IF\n"
"        drop true\n"
"    ELSE\n"
"        ..@ ob_valid_key ob_valid_class = NOT\n"
"    THEN\n"
";\n"
"\n"
": OB.CHECK.CLASS  ( use_class_base -- , abort if not a class )\n"
"    ob.bad.class?\n"
"    IF\n"
"        \" OB.CHECK.CLASS\" \" Not an ODE class!\"\n"
"        er_fatal er.report\n"
"    THEN\n"
";\n"
"\n"
": OB.CHECK.METHOD  ( method_index use_class_base -- , abort if bad method )\n"
"    ..@ ob_#methods >\n"
"    IF   \" OB.CHECK.METHOD\" \" Method not supported for that object!\"\n"
"        er_fatal er.report\n"
"    THEN\n"
";\n"
"\n"
": OB.CHECK.OBJECT  ( use_object -- , abort if not an object )\n"
"    s@ obj_key ob_valid_object - \\ 00004\n"
"    IF\n"
"        \" OB.CHECK.OBJECT\" \" Not an ODE object!\"\n"
"        er_fatal er.report\n"
"    THEN\n"
";\n"
"\n"
": OB.CHECK.BIND ( use_object method_index -- , abort if bad )\n"
"    swap dup ob.check.object\n"
"    ob.obj->class\n"
"    ob.check.method\n"
";\n"
"\n"
"\\ DO compile time checking for illegal methods.\n"
": OB.CHECK.ILLEGAL ( rel_method_cfa -- )\n"
"    rel->use 'c ob.bad.method =\n"
"    IF \" OB.CHECK.ILLEGAL\" \" Method not defined for this class.\"\n"
"        er_fatal er.report\n"
"    THEN\n"
";\n"
"\n"
"\\ Compile code to execute method for an object. ---------------\n"
"#HOST_PFORTH [IF]\n"
": OB.BIND.CFA  ( use_obj_base rel_method_cfa -- , binds method to object )\n"
"    dup ob.check.illegal swap\n"
"    STATE @ IF\n"
"        [compile] aliteral\n"
"        compile os.push\n"
"        compile,\n"
"        compile os.drop\n"
"    ELSE\n"
"        os.push\n"
"        execute  os.drop\n"
"    THEN\n"
";\n"
"\n"
": OB.BIND.INSTANCE.CFA ( instance_offset rel_method_cfa -- )\n"
"    dup ob.check.illegal swap\n"
"    state @\n"
"    IF  [compile] literal\n"
"        compile os+push\n"
"        compile,\n"
"        compile os.drop\n"
"    ELSE\n"
"        os+push\n"
"        execute os.drop\n"
"    THEN\n"
";\n"
"\n"
"[THEN]\n"
"\n"
"#HOST_AMIGA_JFORTH [IF]\n"
": OB.BIND.CFA  ( use_obj_base rel_method_cfa -- , binds method to object )\n"
"    dup ob.check.illegal swap\n"
"    STATE @ IF\n"
"        [compile] aliteral\n"
"        compile os.push\n"
"        calladr,\n"
"        compile os.drop\n"
"    ELSE\n"
"        os.push\n"
"        execute  os.drop\n"
"    THEN\n"
";\n"
"\n"
": OB.BIND.INSTANCE.CFA ( instance_offset rel_method_cfa -- )\n"
"    dup ob.check.illegal swap\n"
"    state @\n"
"    IF  [compile] literal\n"
"        compile os+push\n"
"        calladr,\n"
"        compile os.drop\n"
"    ELSE\n"
"        os+push\n"
"        execute os.drop\n"
"    THEN\n"
";\n"
"\n"
"[THEN]\n"
"\n"
"#HOST_MAC_H4TH [IF]\n"
": (OB.EXEC.METHOD)  ( rel_method_cfa rel_obj_base -- )\n"
"\\   rel->use \\ 00005\n"
"    os.push ro.execute os.drop\n"
";\n"
"\n"
": OB.BIND.CFA  ( use_obj_base rel_method_cfa -- , binds method to object )\n"
"    dup ob.check.illegal\n"
"    STATE @ IF\n"
"        [compile] literal  ( cfa )\n"
"\\   use->rel [compile] literal    ( obj_base  00005 )\n"
"        [compile] Aliteral    ( obj_base  00005 )\n"
"        compile (ob.exec.method)\n"
"    ELSE\n"
"        swap os.push ro.execute os.drop\n"
"    THEN\n"
";\n"
"\n"
": (OB.EXEC.METHOD.I)  ( rel_method_cfa offset -- )\n"
"    os+push ro.execute os.drop\n"
";\n"
"\n"
": OB.BIND.INSTANCE.CFA ( instance_offset rel_method_cfa -- )\n"
"    dup ob.check.illegal\n"
"    state @\n"
"    IF\n"
"        [compile] literal  ( cfa )\n"
"        [compile] literal  ( offset )\n"
"        compile (ob.exec.method.i)\n"
"    ELSE\n"
"        swap os+push\n"
"        ro.execute os.drop\n"
"    THEN\n"
";\n"
"[THEN]\n"
"\n"
"variable OB-IF-CHECK-BIND\n"
"variable OB-CURRENT-MIND  \\ currently compiling method index\n"
"\n"
": OB.BIND.RUN  ( object method_index*cell -- , run time binding act)\n"
"    >r\n"
"\\ rel->use \\ 00005\n"
"    ob-if-check-bind @\n"
"    IF dup r@ cell/ ob.check.bind\n"
"    THEN\n"
"    dup os.push   ( push object onto object stack )\n"
"    @ rel->use r> +  ( index to method cfa )\n"
"    @ ( rel->use ) execute   ( Perform method on object. )\n"
"    os.drop\n"
";\n"
"\n"
": OB.LATE.BIND  ( [object] method_index -- , do late binding of method )\n"
"\\  object not present at compile time.\n"
"    STATE @\n"
"    IF\n"
"        cell* ( preshift for faster run time )\n"
"        [compile] literal  ( save method index for late binding )\n"
"        compile ob.bind.run\n"
"    ELSE  cell* ob.bind.run\n"
"    THEN\n"
";\n"
"\n"
": SELF ( -- rel_obj_base, of_self )\n"
"    os.copy\n"
"\\   use->rel ( %R 00005 )\n"
";\n"
"\n"
"EXISTS? [] NOT [IF]\n"
": []   ( -- , use late binding if 'method: []' )\n"
"    \" OBJECT USE\" \" '[]' CAN ONLY BE AFTER A METHOD\"\n"
"        er_fatal  er.report\n"
";\n"
"[THEN]\n"
"\n"
": SUPER ( --- , stub for superbinding )\n"
"    \" OBJECT USE\" \" 'SUPER' can only be used inside a METHOD definition\"\n"
"    er_fatal  er.report\n"
";\n"
"\n"
"\\ Binding with super-dooper uses the method defined in a superclasses'\n"
"\\ superclass.\n"
": SUPER-DOOPER ( --- , stub for superbinding with skip )\n"
"    \" OBJECT USE\"\n"
"    \" 'SUPER-DOOPER' can only be used inside a METHOD definition\"\n"
"    er_fatal  er.report\n"
";\n"
"\n"
"\n"
"#HOST_AMIGA_JFORTH [IF]\n"
": OB.BIND.'BASE ( CFA -- , bind CFA to current object )\n"
"    ?comp calladr,\n"
";\n"
"[THEN]\n"
"\n"
"\n"
"#HOST_PFORTH [IF]\n"
": OB.BIND.'BASE ( CFA -- , bind CFA to current object )\n"
"    ?comp compile,\n"
";\n"
"[THEN]\n"
"\n"
"#HOST_MAC_H4th [IF]\n"
": OB.BIND.'BASE  ( rel_CFA -- , bind CFA to current object )\n"
"    ?comp [compile] literal   compile ro.execute\n"
";\n"
"[THEN]\n"
"\n"
"\\ These words work off of a variable that contains a use_cfa_base.\n"
": OB.BIND.VAR ( method_index cfa_base_variable -- , bind from that variable )\n"
"    @ swap cell* + @  ( -- method_cfa )\n"
"    dup ob.check.illegal\n"
"    ob.bind.'base  ( %? )\n"
";\n"
"\n"
": OB.BIND.INSTANCE ( method_index pfa_object_def -- )\n"
"    dup ..@ obi_offset ( get offset )\n"
"    -rot  s@ obi_rel_class .. ob_cfas ( -- off mi acfas )\n"
"    swap cell* + @\n"
"    ob.bind.instance.cfa\n"
";\n"
"\n"
": OB.BIND.NORMAL  ( method_index pfa_object -- )\n"
"    dup rot 2dup ob.check.bind\n"
"    ob.cfa@ ob.bind.cfa\n"
";\n"
"\n"
": OB.EARLY.BIND  ( method_index cfa_object -- )\n"
"    cfa->pfa\n"
"    ob-state @ ob_def_class =\n"
"    IF  dup ob-current-class @\n"
"        ob.is.instance? ( Check to see if this is an Instance Object.)\n"
"        IF ob.bind.instance\n"
"        ELSE ob.bind.normal\n"
"        THEN\n"
"    ELSE ob.bind.normal\n"
"    THEN\n"
";\n"
"\n"
": OB.FIND.OBJECT  { | $name cfa -- cfa , abort if not found }\n"
"    0 -> cfa\n"
"    bl word -> $name\n"
"\\ .\" Word = \" $name count type cr\n"
"\\\n"
"\\ is this a local variable\n"
"    local-compiler @ ?dup\n"
"    IF  ( -- 'compiler )\n"
"        $name swap execute\n"
"        IF \\ if so compile reference and use late binding\n"
"            ['] [] -> cfa   \n"
"        THEN\n"
"    THEN\n"
"    \n"
"\\ do we already have a winner\n"
"    cfa 0=\n"
"    IF\n"
"        $name find NOT\n"
"        IF\n"
"            >newline count type .\"  ?\" cr\n"
"            \" OB.FIND.OBJECT\" \" Object not found!\"\n"
"            er_fatal  er.report\n"
"        THEN\n"
"        -> cfa\n"
"    THEN    \n"
"    cfa\n"
";\n"
"\n"
": OB.CHECK.RECURSE  ( method_index -- , warn in recurse: self )\n"
"    ob-current-mind @ =\n"
"    IF\n"
"        \" OB.CHECK.RECURSE\" \" Recursive message to self!\"\n"
"        er_warning er.report\n"
"        current-method @ id. .\"  SELF\" cr\n"
"    THEN\n"
";\n"
"\n"
"\n"
": OB.BIND   ( method_index <object> -- , bind )\n"
"    ob.find.object  ( -- mi cfa )\n"
"    CASE  ( Different types of binding. )\n"
"\\ Assume rel_obj_base also on stack at runtime for late binding.\n"
"        'c []\n"
"        OF ob.late.bind\n"
"        ENDOF\n"
"\\\n"
"        'c SELF\n"
"        OF  dup ob.check.recurse\n"
"            ob-self-cfas ob.bind.var\n"
"        ENDOF\n"
"\\\n"
"        'c SUPER\n"
"        OF ob-super-cfas ob.bind.var\n"
"        ENDOF\n"
"\\\n"
"        'c SUPER-DOOPER\n"
"        OF ob-dooper-cfas ob.bind.var\n"
"        ENDOF\n"
"\\\n"
"\\ Bind named object.\n"
"        ob.early.bind 0   ( needs zero for dropping )\n"
"    ENDCASE\n"
";\n";

const char* ob_bind_fth = (const char*) temp_binary_data_48;

//================== ob_dlist.fth ==================
static const unsigned char temp_binary_data_49[] =
"\\ Doubly Linked List\n"
"\\\n"
"\n"
"ANEW TASK-OB_DLIST\n"
"\n"
"METHOD GET.PREVIOUS:  ( -- prev_node )\n"
"METHOD GET.NEXT:  ( next_node -- )\n"
"METHOD PUT.NEXT:  ( new_node -- )\n"
"METHOD PUT.PREVIOUS:  ( new_node -- )\n"
"METHOD CONNECT: ( new_node -- , connect new_node after this node )\n"
"METHOD INSERT.AFTER: ( new_node -- )\n"
"METHOD INSERT.BEFORE: ( new_node -- )\n"
"\n"
":CLASS  OB.DOUBLE.NODE  <SUPER OBJECT  \\ node of doubly linked list\n"
"    iv.long  iv-dbl-next\n"
"    iv.long  iv-dbl-previous\n"
"\n"
":M GET.NEXT:  ( -- next_node )\n"
"    iv-dbl-next\n"
";M\n"
":M GET.PREVIOUS:  ( -- prev_node )\n"
"    iv-dbl-previous\n"
";M\n"
"\n"
":M PUT.NEXT:  ( new_node -- )\n"
"    iv=> iv-dbl-next\n"
";M\n"
":M PUT.PREVIOUS:  ( new_node -- )\n"
"    iv=> iv-dbl-previous\n"
";M\n"
"\n"
":M CONNECT: { new_node -- , connect new_node after this node }\n"
"\\ .\" Connect \" name: self .\"  to \" name: new_node  cr\n"
"    new_node iv=> iv-dbl-next\n"
"    self put.previous: new_node\n"
";M\n"
"\n"
":M INSERT.AFTER: { new_node -- }\n"
"    iv-dbl-next\n"
"    new_node connect: self\n"
"    connect: new_node\n"
";M\n"
"\n"
":M INSERT.BEFORE: { new_node -- }\n"
"    new_node iv-dbl-previous \n"
"    self connect: new_node\n"
"    connect: []\n"
";M\n"
"\n"
":M REMOVE:  ( -- , remove from list )\n"
"    iv-dbl-next 0= abort\" REMOVE: twice from list!\"\n"
"    iv-dbl-previous 0= abort\" REMOVE: twice from list!\"\n"
"    \n"
"    iv-dbl-next iv-dbl-previous connect: []\n"
"    \n"
"    0 iv=> iv-dbl-next\n"
"    0 iv=> iv-dbl-previous\n"
";M\n"
"\n"
":M PRINT:\n"
"    >newline\n"
"    iv-dbl-previous\n"
"    IF\n"
"        iv-dbl-previous get.name: [] count type .\"  => \" name: self\n"
"        .\"  => \" iv-dbl-next get.name: [] count type cr\n"
"    ELSE\n"
"        name: self .\"  not in list.\" cr\n"
"    THEN\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"METHOD ADD.HEAD: ( new_node -- )\n"
"METHOD ADD.TAIL: ( new_node -- )\n"
"METHOD ?END:  ( node -- flag , end of forward or backward scan? )\n"
"METHOD ?EMPTY: ( new_node -- )\n"
"\n"
":CLASS  OB.DOUBLE.LIST  <SUPER OB.DOUBLE.NODE  \\ head of doubly linked list\n"
"\n"
":M INIT:\n"
"    self iv=> iv-dbl-next\n"
"    self iv=> iv-dbl-previous\n"
";M\n"
"\n"
":M ?EMPTY:  ( -- flag )\n"
"    iv-dbl-next self =\n"
";M\n"
"\n"
":M ADD.HEAD: ( new_node -- )\n"
"    iv-dbl-next insert.before: []\n"
";M\n"
":M ADD.TAIL: ( new_node -- )\n"
"    iv-dbl-previous insert.after: []\n"
";M\n"
"\n"
":M FIRST:  ( -- node )\n"
"    iv-dbl-next\n"
";M\n"
"\n"
":M LAST:  ( -- node )\n"
"    iv-dbl-previous\n"
";M\n"
"\n"
":M ?END:  ( node -- flag , end of forward or backward scan? )\n"
"    self =\n"
";M\n"
"\n"
":M DO:  { cfa -- }\n"
"    first: self\n"
"    BEGIN\n"
"        dup ?end: self not\n"
"    WHILE\n"
"        dup cfa execute\n"
"        get.next: []\n"
"    REPEAT\n"
"    drop\n"
";M\n"
"        \n"
";CLASS\n"
"\n"
"\n"
"0 [IF]\n"
"\\ test double list objects\n"
"\n"
"ob.double.node nd1\n"
"ob.double.node nd2\n"
"ob.double.node nd3\n"
"ob.double.node nd4\n"
"ob.double.list dbl\n"
"\n"
": validate.result { v1 v2 $msg -- }\n"
"    v1 v2 =\n"
"    IF\n"
"        .\" SUCCESS - \"\n"
"        $msg count type cr\n"
"    ELSE\n"
"        .\" ERROR - \"\n"
"        $msg count type cr\n"
"        abort\n"
"    THEN\n"
";\n"
"\n"
": print.node ( node --  )\n"
"    print: []\n"
";\n"
"\n"
": test.dbl\n"
"    ?empty: dbl   true c\" Initially empty.\" validate.result\n"
"    \n"
"\\ add to head and tail\n"
"    nd2 add.head: dbl\n"
"    first: dbl nd2 c\" Add ND2 head, get first.\" validate.result\n"
"    nd3 add.tail: dbl\n"
"    last: dbl nd3 c\" Add ND3 tail, get last.\" validate.result\n"
"    nd4 add.tail: dbl\n"
"    last: dbl nd4 c\" Add ND4 tail, get last.\" validate.result\n"
"    nd1 add.head: dbl\n"
"    first: dbl nd1 c\" Add ND1 head, get first.\" validate.result\n"
"    \n"
"\\ scan list\n"
"    get.next: nd1 nd2 c\" next...\"  validate.result\n"
"    get.next: nd2 nd3 c\" next...\"  validate.result\n"
"    get.next: nd3 nd4 c\" next...\"  validate.result\n"
"    get.next: nd4 ?end: dbl  true c\" next end...\" validate.result\n"
"    get.next: nd3 ?end: dbl  false c\" not next end...\" validate.result\n"
"    \n"
"    get.previous: nd4 nd3 c\" prev...\" validate.result\n"
"    get.previous: nd3 nd2 c\" prev...\" validate.result\n"
"    get.previous: nd2 nd1 c\" prev...\" validate.result\n"
"    get.previous: nd1 ?end: dbl  true c\" prev end...\" validate.result\n"
"    get.previous: nd2 ?end: dbl  false c\" not prev end...\" validate.result\n"
"    \n"
"    remove: nd2\n"
"    get.next: nd1 nd3 c\" removed, 1->3\"  validate.result\n"
"    get.next: nd2 0 c\" removed, next 0\"  validate.result\n"
"    get.previous: nd2 0 c\" removed, prev 0\" validate.result\n"
"    \n"
"    \n"
"    remove: nd4\n"
"    get.next: nd3 ?end: dbl true c\" removed nd4, 3->end\"  validate.result\n"
"    last: dbl nd3 c\" removed, last 3\"  validate.result\n"
"    \n"
"\\ print list\n"
"    ['] print.node do: dbl\n"
";\n"
"\n"
"test.dbl\n"
"\n"
"[THEN]\n";

const char* ob_dlist_fth = (const char*) temp_binary_data_49;

//================== ob_ivars.fth ==================
static const unsigned char temp_binary_data_50[] =
"\\ @(#) ob_ivars.fth 96/06/11 1.1\n"
"\\ Optimized Instance Variables\n"
"\\ These are intended to make it easier to use instance variables.\n"
"\\ These IVARS will automatically fetch their data.  This can be optimized\n"
"\\ like crazy.  If you want to store into them, you use IV=> .\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 Delta Research\n"
"\\\n"
"\\ MOD: PLB 5/13/87 Make iv&> immediate, use os+\n"
"\\ MOD: PLB 9/13/88 Convert to new addressing mode, add IV.BYTES\n"
"\\      Add signed ivars.\n"
"\\ MOD: PLB 2/7/90 Add IV.STRUCT\n"
"\\ 00001 PLB 4/8/92 Added IV.ARRAY\n"
"\\ 960710 PLB Add IV.RPTR\n"
"\n"
"ANEW TASK-OB_IVARS\n"
"\n"
"decimal\n"
"\\ Support for fetching and storing into instance variables .\n"
"\\ These should not be called directly.\n"
"\n"
"\\ Make JFORTH compile @ ! etc. inline for speed.\n"
"#host_amiga_jforth [IF]\n"
"max-inline @ 20 max-inline !\n"
"[THEN]\n"
"\n"
"false [IF]\n"
": IV@  ( offset -- value , fetch from LONG instance variable )\n"
"    os+ @\n"
";\n"
": IVW@ ( offset -- value , fetch from SHORT instance variable )\n"
"    os+ w@\n"
";\n"
": IVC@ ( offset -- value , fetch from SHORT instance variable )\n"
"    os+ c@\n"
";\n"
"\n"
": IV!  ( value offset -- , store into LONG instance variable )\n"
"    os+ !\n"
";\n"
": IVW!  ( value offset -- , store into SHORT instance variable )\n"
"    os+ w!\n"
";\n"
": IVC!  ( value offset -- , store into BYTE instance variable )\n"
"    os+ c!\n"
";\n"
"[THEN]\n"
"\n"
": IV+!  ( value offset -- , store into LONG instance variable )\n"
"    os+ +!\n"
";\n"
"\n"
"#host_amiga_jforth [IF]\n"
"    max-inline !\n"
"[THEN]\n"
"\n"
": CREATE.IVAR ( size <name> -- )\n"
"    CREATE ob.make.member   immediate\n"
"    DOES>  ( -- address-ivar )\n"
"        ?comp compile os.copy\n"
"        ob.stats compile+@bytes\n"
";\n"
"\n"
"\\ These words are for declaring instance variables.\n"
"\\ Some of this code appears redundant but is needed because they\n"
"\\ are CREATE-DOES> words.\n"
": IV.LONG  ( <name> --IN-- , declare a cell wide instance variable )\n"
"    cell create.ivar\n"
";\n"
"\n"
": IV.RPTR  ( <name> --IN-- , declare a relocatable pointer instance variable )\n"
"    -cell create.ivar\n"
";\n"
"\n"
": IV.SHORT  ( <name> --IN-- , declare a 16 bit wide instance variable )\n"
"    -2 create.ivar\n"
";\n"
"\n"
": IV.USHORT  ( <name> --IN-- , declare a 16 bit wide instance variable )\n"
"    2 create.ivar\n"
";\n"
"\n"
": IV.BYTE  ( <name> --IN-- , declare a byte wide instance variable )\n"
"    -1 create.ivar\n"
";\n"
"\n"
": IV.UBYTE  ( <name> --IN-- , declare a byte wide instance variable )\n"
"    1 create.ivar\n"
";\n"
"\n"
": IV=>  ( value <ivar> -- , store into ivar )\n"
"    ?COMP\n"
"    compile os.copy\n"
"    ob.stats? compile+!bytes\n"
"; immediate\n"
"\n"
": IV+>  ( value <ivar> -- , add value to ivar )\n"
"    ?COMP\n"
"    ob.stats? cell =\n"
"    IF [compile] literal compile iv+!\n"
"    ELSE \" IV+>\" \" only works on IV.LONG !!\"\n"
"        er_fatal er.report\n"
"    THEN\n"
"; immediate\n"
"\n"
": IV&   ( offset -- address_ivar )\n"
"    os+\n"
";\n"
"\n"
": IV&>  ( <ivar> --IN-- address_ivar , calculate address of ivar )\n"
"    ?COMP\n"
"    ob.findit ob.offset@ [compile] literal compile os+\n"
"; immediate\n"
"\n"
"\\ This is for declaring a field of bytes in an object.\n"
": IV.BYTES ( n <name> -- , declare a field of bytes )\n"
"    CREATE ob.make.member immediate\n"
"    DOES> ?comp @ [compile] literal compile os+\n"
";\n"
"\n"
": IV.STRUCT ( <structure> <name> -- ) ( -- addr )\n"
"    [compile] sizeof() iv.bytes\n"
";\n"
"\n"
"\n"
"\\ Fast internal arrays 00001\n"
": (IV.ARRAY) ( index offset -- addr )\n"
"    os+\n"
"    swap cell* +\n"
";\n"
"\n"
": IV.ARRAY  ( size <name> -- )\n"
"    CREATE cells ob.make.member immediate\n"
"    DOES> ( index addr-ivar )\n"
"        ?comp ob.offset@ [compile] literal\n"
"        compile (iv.array)\n"
";\n"
"\n"
": (IV.WARRAY) ( index offset -- addr )\n"
"    os+\n"
"    swap 2* +\n"
";\n"
"\n"
": IV.WARRAY  ( size <name> -- )\n"
"    CREATE 2* ob.make.member immediate\n"
"    DOES> ( index addr-ivar )\n"
"        ?comp ob.offset@ [compile] literal\n"
"        compile (iv.warray)\n"
";\n"
"\n"
": (IV.BARRAY) ( index offset -- addr )\n"
"    os.copy + +\n"
";\n"
"\n"
": IV.BARRAY  ( size <name> -- )\n"
"    CREATE ob.make.member immediate\n"
"    DOES> ( index addr-ivar )\n"
"        ?comp ob.offset@ [compile] literal\n"
"        compile (iv.barray)\n"
";\n"
"\n";

const char* ob_ivars_fth = (const char*) temp_binary_data_50;

//================== ob_main.fth ==================
static const unsigned char temp_binary_data_51[] =
"\\ @(#) ob_main.fth 96/06/11 1.1\n"
"\\ ODE - Object Oriented Development Environment\n"
"\\\n"
"\\ This file contains the basis for the Object Oriented\n"
"\\ Development Environment used by HMSL.  The essential\n"
"\\ words like :CLASS and <SUPER are defined here.\n"
"\\\n"
"\\ Notes:\n"
"\\  RELOCATION: When addresses are stored in the dictionary,\n"
"\\  they are stored in a relocatable form.  For JForth and HForth\n"
"\\  this means they are stored as addresses relative to the base of\n"
"\\  the dictionary.\n"
"\\\n"
"\\ (sizes are for a 32-bit Forth)\n"
"\\ Data Structures:    ( offsets are from PFA )\n"
"\\  CLASS Definition Structure\n"
"\\  offset     name           contents\n"
"\\    0     OB_SIZE        size of object\n"
"\\    4     OB_#METHODS    number of methods\n"
"\\    8     OB_VALID_KEY   key for class validation\n"
"\\   12     OB_SUPER       rel pointer to base of super class\n"
"\\   16     OB_LAST_IVAR   rel pointer to cfa of last of linked ivars\n"
"\\   20     OB_CFAS        base of the CFA array, method_0 CFA\n"
"\\   24       ---          method_1 CFA\n"
"\\   28       ---          method_2 CFA\n"
"\\            etc.\n"
"\n"
"\\ INSTANCE VARIABLE Definition Structure\n"
"\\  offset     contents\n"
"\\    0      offset in object\n"
"\\    4      size of instance variable\n"
"\\\n"
"\\ INSTANCE OBJECT Definition Structure\n"
"\\  offset     name          contents\n"
"\\    0     OBI_OFFSET     offset in parent object\n"
"\\    4     OBI_SIZE       size of object\n"
"\\    8     OBI_PREVIOUS   link to previous Instance Object\n"
"\\   12     OBI_REL_CLASS  rel pointer to class\n"
"\\\n"
"\\ OBJECT Structure\n"
"\\  offset     contents\n"
"\\    0      rel pointer to OB_CFAS of associated class.\n"
"\\    4      object validation flag\n"
"\\    8      start of instance variable space - rel name pointer\n"
"\\\n"
"\\ Parameter description:\n"
"\\    USE_        = Prefix for Forth normal useable address.\n"
"\\    REL_        = Prefix for relocatable token.\n"
"\\ (Note: In JForth: USE_ = REL_ , in HForth: ABS_ = REL_ REL->USE )\n"
"\\    _OBJ_BASE   = Base of object, contains REL_CFA_BASE\n"
"\\    _CFA_BASE   = Address of first CFA in method array.\n"
"\\    _CLASS_BASE = Base of class, offsets added to get to #ivars\n"
"\\    OBJ_TOKEN   = Identifying token for object.\n"
"\\    METHOD_INDEX = index of method in cfa table.\n"
"\\    METHOD_CFA  = CFA for a method.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 Phil Burk\n"
"\\\n"
"\\ MOD: PLB 7/14/86 Converted late binding to use relative addresses.\n"
"\\ MOD: PLB 7/15/86 Added pairing checks to :M - ;M\n"
"\\ MOD: PLB 7/17/86 Added OB.INIT, must be called before any objects.\n"
"\\ MOD: PLB 7/25/86 Fixed stack leftovers bug, added \" ! \" to :CLASS.\n"
"\\ MOD: PLB 8/16/86 Put error checking in BIND operation.\n"
"\\ MOD: PLB 9/15/86 Converted to work with JForth\n"
"\\      Put conditional compilation for OB.IVAR techniques.\n"
"\\ MOD: PLB 9/16/86 Broke up into smaller files:\n"
"\\      OBJ_STACK , OBJ_MAIN , OBJ_BINDING , OBJ_METHODS .\n"
"\\      Added :STRUCT .\n"
"\\ MOD: PLB 10/20/86 Moved :STRUCT to c_struct.\n"
"\\ MOD: PLB 10/23/86 Made MAC mods.\n"
"\\ MOD: PLB 11/29/86 Relocatable method tokens, CREATE MI-NEXT\n"
"\\ MOD: PLB 2/20/87  Put 0 OB-STATE ! in MRESET\n"
"\\ MOD: PLB 5/13/87  Zero ivars when instantiated, add os.push.\n"
"\\ MOD: PLB 9/3/87   Add INHERITANCE.OF\n"
"\\ MOD: PLB 9/8/87   Use structures for CLASS and INSTANCE OBJECTs.\n"
"\\      Support Instance Objects.\n"
"\\ MOD: PLB 1/13/88 Add relocation for Mac for Instance Objects\n"
"\\ MOD: PLB 4/26/88 Add USE->REL to OB.PRELOAD.CFAS for Mac.\n"
"\\      MDH 7/5/88   Modified MAKE.OBJECT to set CLASS_BIT in SFA\n"
"\\      MDH 7/15/88  Modified :CLASS to set :CLASS_BIT in SFA\n"
"\\ 00001 PLB 9/20/91 Sped up OB.SET.NAME on Mac by not doing PFA->NFA\n"
"\\ 00002 PLB 6/8/92  Add validation flag to object\n"
"\\ 00003 PLB 6/9/92  Simplify code by using local variables\n"
"\\ 00004 PLB 8/3/92  Use ..@ and ..! to simplify code\n"
"\\ 00005 PLB 8/3/92 Objects put absolute address on stack.\n"
"\n"
"ANEW TASK-OB_MAIN\n"
"\n"
"\\ Error Detection and reporting. ================================\n"
": OB.BAD.METHOD ( use_obj_base -- , Give error for undefined meth.)\n"
"    pfa->nfa id.\n"
"    \" OB.BAD.METHODS\" \" Illegal method for object!\"\n"
"    ER_FATAL  ER.REPORT\n"
";\n"
"\n"
": OB.PRELOAD.CFAS ( use_cfa_base N -- , Load N methods into table. )\n"
"    0 ?DO ( FOR EACH METHOD )\n"
"        dup i cell* +\n"
"        'c ob.bad.method use->rel swap !\n"
"    LOOP drop\n"
";\n"
"\n"
"\\ Method index counter ========================================\n"
"\\ Every method is assigned a unique index when it is declared.\n"
"\\ This index is used to lookup the appropriate CFA in a table\n"
"\\ kept in the CLASS .\n"
"\n"
"CREATE MI-NEXT 0 ,\n"
"\n"
"\\ Class definition  =========================================\n"
"\\ Define CLASS structure ----------------------------------\n"
"\n"
"U: OB-INSIDE-:M   ( flag for pairs checking )\n"
"\n"
"\\ Structures of Class and Instance Object Definition.\n"
":STRUCT OB.CLASS\n"
"    LONG OB_SIZE\n"
"    LONG OB_#METHODS\n"
"    LONG OB_VALID_KEY\n"
"    RPTR OB_SUPER\n"
"    RPTR OB_LAST_IVAR    ( relative address of last ivar )\n"
"    LONG OB_CFAS\n"
";STRUCT\n"
"\n"
":STRUCT OB.INSTANCE.OBJECT\n"
"    LONG OBI_OFFSET\n"
"    LONG OBI_SIZE\n"
"    RPTR OBI_PREVIOUS    ( relative )\n"
"    RPTR OBI_REL_CLASS\n"
";STRUCT\n"
"\n"
":STRUCT OB.OBJECT\n"
"    RPTR  OBJ_CLASS_CFAS\n"
"    LONG  OBJ_KEY\n"
"    RPTR  OBJ_NAME\n"
";STRUCT\n"
"\n"
"\\ An unlikely number, used for recognizing valid classes.\n"
"$ 518279AF CONSTANT OB_VALID_CLASS\n"
"\\ An unlikely number, used for recognizing valid objects.\n"
"$ 4F626A74 CONSTANT OB_VALID_OBJECT\n"
"\n"
"\\ ----------------------------------------------------------\n"
"V: OB-SELF-CFAS ( use_cfa_base, for current class, fake instance )\n"
"\n"
"1 [IF]\n"
"\\ Set the IV-NAME instance variable in OBJECTS to\n"
"\\ point to the NFA of the Instance Object Definition\n"
": OB.SET.NAME ( addr_inst_obj_def addr_object -- , set IV-NAME )\n"
"\\ This is a rather nasty thing to do - SO DON'T DO IT - TOO SLOW ON MAC!\n"
"\\    swap pfa->nfa swap cell+ !   \\  PFA->NFA is very slow! 00001\n"
"    >r drop \" INSTOBJ\" r> ..! obj_name\n"
";\n"
"[ELSE]\n"
": OB.SET.NAME ( addr_inst_obj_def addr_object -- , set IV-NAME )\n"
"    >r pfa->nfa r> ..! obj_name\n"
";\n"
"[THEN]\n"
"\n"
": OB.SETUP  \\ Setup data in object\n"
"dbug\" ob.setup\"\n"
"{ use_object use_class_base | obi_def use_obi use_cfas -- }\n"
"\\\n"
"\\ Recursively setup instance objects.\n"
"    use_class_base ..@ ob_last_ivar -> obi_def\n"
"    BEGIN obi_def ( is it zero )\n"
"dbug\" ob.setup - recurse through instance objects.\"\n"
"    WHILE\n"
"        obi_def ..@ obi_offset ( get offset )\n"
"        use_object + -> use_obi ( calc address of instance object )\n"
"\\\n"
"\\ recursively call\n"
"        use_obi\n"
"        obi_def ..@ obi_rel_class   ( class of instance object )\n"
"        RECURSE\n"
"\n"
"        obi_def use_obi ob.set.name\n"
"        obi_def ..@ obi_previous -> obi_def\n"
"    REPEAT\n"
"dbug\" ob.setup - finish recursion.\"\n"
"\\\n"
"\\ Compile rel_cfa_base at obj_base.\n"
"    ( -- obj_base class_base )\n"
"    use_class_base .. ob_cfas -> use_cfas\n"
"    use_cfas use_object ..! obj_class_cfas ( set methods pointer in object)\n"
"\\\n"
"dbug\" ob.setup - store validation flag in object\"\n"
"    ob_valid_object use_object ..! obj_key\n"
"\\\n"
"dbug\" ob.setup - execute INIT: method\"\n"
"\\ use_object  use_cfas  abort\n"
"    use_object os.push           ( push object address for method )\n"
"    \\ Don't do rel->use for pForth cuz EXECUTE takes a relocatable token.\n"
"    use_cfas @ ( rel->use ) execute     ( execute INIT: method )\n"
"    os.drop\n"
"dbug\" ob.setup - done\"\n"
";\n"
"\n"
"#HOST_AMIGA_JFORTH [IF]\n"
": MAKE.OBJECT ( abs_class_base -- , Instantiate an object. )\n"
"    CREATE  ( make object header )\n"
"\\\n"
"\\ Mark as CLASS definition for CLONE...\n"
"\\\n"
"    latest name> cell-   dup @ CLASS_BIT or  swap !\n"
"\\\n"
"\\\n"
"        here swap                ( addr_object abs_class_base )\n"
"        dup ..@ ob_size allot    ( make room for ivars )\n"
"        2dup ..@ ob_size erase   ( zero out ivar space )\n"
"        ob.setup\n"
"        IMMEDIATE\n"
"    DOES> ( addr )\n"
"        [compile] aliteral\n"
";\n"
"[ELSE]\n"
": MAKE.OBJECT ( abs_class_base -- , Instantiate an object. )\n"
"    CREATE  ( make object header )\n"
"        here swap         ( addr_object abs_class_base )\n"
"        dup @ allot       ( make room for ivars )\n"
"        2dup @\n"
"        dbug\" MAKE.OBJECT - zero out ivar space\"\n"
"        erase      ( zero out ivar space )\n"
"        ob.setup\n"
"\\   DOES> 00005\n"
"\\       use->rel    ( run time action of object 00005 )\n"
";\n"
"[THEN]\n"
"\n"
": MAKE.INSTANCE.OBJECT  ( abs_class_base -- , Template for embedded object )\n"
"    CREATE here >r\n"
"        dup @ ob.make.member\n"
"\\ Link new instance object to previous instance object.\n"
"        ob-current-class @ ..@ ob_last_ivar\n"
"        if.use->rel , ( relocatable )\n"
"\\\n"
"\\ Update ob_last_ivar field in current class.\n"
"        r> ( -- abs_class_base inst_ivar )\n"
"        ob-current-class @ ..! ob_last_ivar\n"
"\\ Save pointer to class, OB_REL_CLASS .\n"
"        use->rel ,\n"
"    DOES>\n"
"        @ ( get offset )\n"
"        os+\n"
"\\ use->rel  ( -- rel_instance_object 00005 )\n"
";\n"
"\n"
": :CLASS (  -- , Create a class with N methods )\n"
"\\ Check pairs\n"
"    ob-state @\n"
"    IF \" :CLASS\" \" Previous :STRUCT or :CLASS unterminated!\"\n"
"        er_warning er.report\n"
"    THEN\n"
"    ob_def_class ob-state !     ( set pair flags )\n"
"    false ob-inside-:m !\n"
"\\\n"
"\\ Create new class defining word.\n"
"    CREATE\n"
"\\\n"
"\\\n"
"\\ Added mdh...\n"
"[ #HOST_AMIGA_JFORTH [IF] ]\n"
"\\\n"
"\\ Mark as :CLASS definition for CLONE...\n"
"\\\n"
"        latest name> cell-   dup @ :CLASS_BIT or  swap !\n"
"[ [THEN] ]\n"
"\\\n"
"\\\n"
"        here dup ob-current-class !  ( set current )\n"
"        .. ob_cfas ob-self-cfas !       ( for self binding )\n"
"\\ Fill fields in CLASS, must match order as defined !\n"
"        obj_name ,               ( OB_IVAR_SPACE , initial ivar offset 00002 )\n"
"        mi-next @ dup ,         ( OB_#METHODS , # methods allowed )\n"
"        ob_valid_class ,        ( OB_VALID_KEY , key for validation )\n"
"        0 ,                     ( OB_SUPER , space for superclass pointer )\n"
"        0 ,                     ( OB_LAST_IVAR , space for pointer to last )\n"
"        here over cell* allot   ( OB_CFAS , make room for CFAS )\n"
"        swap ob.preload.cfas     ( put error method in for safety)\n"
"    DOES>\n"
"        ob-state @ ob_def_class =\n"
"        IF make.instance.object\n"
"        ELSE make.object\n"
"        THEN\n"
";\n"
"\n"
"\\ INHERITANCE =============================================\n"
"( Methods will be inherited by copying CFAS into CFA array. )\n"
"V: OB-SUPER-CFAS   ( abs_cfa_base of SUPER CLASS )\n"
"V: OB-DOOPER-CFAS  ( abs_cfa_base of SUPER's SUPER CLASS )\n"
"\n"
": OB.SET.DOOPER    ( -- , set dooper cfas based on super )\n"
"    ob-super-cfas @       ( base of cfas )\n"
"    ob_cfas - ..@ ob_super ( superclass of superclass )\n"
"    ob_cfas + ob-dooper-cfas !\n"
";\n"
"\n"
": <SUPER ( <WORD> ---- , COPY METHODS )\n"
"    ho.find.pfa NOT\n"
"    IF \" <SUPER\" \" CLASS NOT FOUND\"\n"
"        ER_FATAL ER.REPORT\n"
"    THEN ( -- super-pfa )\n"
"    ob-current-class @ ( -- super-pfa class-pfa )\n"
"\n"
"\\ Save superclass pointer in class.\n"
"    2dup ..! ob_super\n"
"\\\n"
"\\ Save pointer to last linked ivar object.\n"
"    over ..@ ob_last_ivar\n"
"    over ..! ob_last_ivar\n"
"\\\n"
"\\ Increment IVAR offset to include superclass' ivars\n"
"    2dup\n"
"    swap ..@ ob_size ( -- sp cp cp s# , space for super's ivars )\n"
"    over ..@ ob_size cell- + ( -- sp cp cp c#, 1 cell for class*)\n"
"    swap ..! ob_size\n"
"\n"
"\\ Copy method cfas from superclass\n"
"    over ..@ ob_#methods      ( sp cp #-inherited-methods )\n"
"    cell*                     ( sp cp #bytes , calc bytes to copy )\n"
"    rot  .. ob_cfas           ( cp #bytes super_cfas )\n"
"\\\n"
"\\ Save super_cfas for later binding.\n"
"    dup ob-super-cfas !\n"
"    rot .. ob_cfas            ( #bytes super_cfas class_cfas )\n"
"    rot cmove                 ( copy methods )\n"
"    ob.set.dooper\n"
";\n"
"\n"
": ;CLASS ( -- , terminate class )\n"
"    ob-state @ ob_def_class = NOT\n"
"    IF \" ;CLASS\" \" Missing :CLASS above\" er_fatal er.report\n"
"    THEN\n"
"    0 ob-state !\n"
";\n"
"\n"
": INHERITANCE.OF ( <class> -- , list superclasses of class )\n"
"    ho.find.pfa\n"
"    IF  cr\n"
"        BEGIN  ..@ ob_super dup\n"
"        WHILE  dup pfa->nfa id. space space cr? ?pause\n"
"        REPEAT drop\n"
"    THEN cr\n"
";\n"
"\n"
": OB.IS.INSTANCE? { pfa_object_def class_base | prev result -- flag }\n"
"\\ Scans list of instance variables in class for match.\n"
"    0 -> result   ( default answer = false )\n"
"    class_base ..@ ob_last_ivar -> prev\n"
"    BEGIN  prev\n"
"    WHILE\n"
"        pfa_object_def prev =\n"
"        IF\n"
"            true -> result\n"
"            0 -> prev\n"
"        ELSE\n"
"            prev ..@ obi_previous -> prev\n"
"        THEN\n"
"    REPEAT\n"
"    result\n"
";\n"
"\n"
"\n"
"\\ Tools for debugging ODE\n"
": 'P ( <created_data_structure> -- pfa )\n"
"    [compile] 'c cfa->pfa\n"
";\n"
"\n"
": METHOD@ ( method_index pfa_class -- abs_method_cfa )\n"
"    .. ob_cfas\n"
"    swap cell* + @ rel->use\n"
";\n"
"\n"
": GET.METHOD ( method_index <class> -- method_cfa )\n"
"    'p method@\n"
";\n";

const char* ob_main_fth = (const char*) temp_binary_data_51;

//================== ob_stack.fth ==================
static const unsigned char temp_binary_data_52[] =
"\\ @(#) ob_stack.fth 96/06/11 1.1\n"
"\\ OBJECT Stack =========================================\n"
"\\ This stack is used for storing the current object address.\n"
"\\ Access to instance variables is based on that address.\n"
"\\ This code is a good candidate for optimization.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1995\n"
"\\\n"
"\\ MOD: PLB 1/21/87 Add OS.DEPTH\n"
"\\ MOD: PLB 2/10/87 Assemble and optimize OS.PUSH and OS.DROP\n"
"\\ MOD: PLB 4/19/87 Optimize for Mac too.\n"
"\\ MOD: PLB 4/25/88 Add OS_MAX_DEPTH and expand to 256 bytes.\n"
"\\ 951227 PLB Converted to high level for pForth\n"
"\n"
"ANEW TASK-OB_STACK\n"
"\n"
"256 constant OS_SIZE\n"
"os_size cell/ constant OS_MAX_DEPTH\n"
"VARIABLE OBJECT-STACK os_size VALLOT\n"
"VARIABLE OSSTACKPTR  ( defined in kernel )\n"
"\\ stack grows down in memory\n"
"\n"
": OS.SP!  ( -- , SET USER STACK POINTERS )\n"
"     object-stack os_size + osstackptr !\n"
"; OS.SP!\n"
"\n"
": OS.PUSH  ( N -- , Push onto object stack )\n"
"    osstackptr @\n"
"    cell-    \\ pre-decrement\n"
"    dup osstackptr !\n"
"    !\n"
";\n"
"\n"
": OS.DROP  ( -- , drop top of object stack )\n"
"    cell osstackptr +!\n"
";\n"
"\n"
": OS.COPY  ( -- N , make copy of top of object stack )\n"
"    osstackptr @ @\n"
";\n"
"\n"
": OS+ ( M -- N+M , add top of object stack )\n"
"    os.copy +\n"
";\n"
"\n"
": OS+PUSH  ( N -- , Add to OS TOP and push onto object stack )\n"
"    os.copy +\n"
"    os.push\n"
";\n"
"\n"
": OS.POP  ( -- N , pop from object stack )\n"
"    osstackptr @ dup @\n"
"    swap cell+   \\ post-increment\n"
"    osstackptr !\n"
";\n"
"\n"
": OS.DEPTH ( -- #cells , depth of object stack )\n"
"    object-stack os_size +\n"
"    osstackptr @ - cell/\n"
";\n"
"\n"
": OS.PICK ( n -- Vn , pick value off object stack )\n"
"    cell* osstackptr @ + @\n"
";\n"
"\n"
"\n"
"\\ Benchmark\n"
"if-testing @ [IF]\n"
"VARIABLE #OS.BENCH\n"
"1000 #OS.BENCH !\n"
": OS.BENCH  123 #OS.BENCH @ 0\n"
"    ?DO  os.push os.copy os.drop\n"
"    LOOP drop\n"
";\n"
"[THEN]\n";

const char* ob_stack_fth = (const char*) temp_binary_data_52;

//================== obmethod.fth ==================
static const unsigned char temp_binary_data_53[] =
"\\ @(#) obmethod.fth 96/06/11 1.1\n"
"\\ This file defines the words used to define METHODS for a class.\n"
"\\ Methods are used to manipulate an objects instance variables.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 Phil Burk\n"
"\\\n"
"\\ MOD: PLB 11/29/86 Store CFAs in relocatable form for MAC\n"
"\\ MOD: PLB 2/10/87 Catch redeclared Methods!\n"
"\\ MOD: PLB 9/5/87 Add METHODS.OF and other tools.\n"
"\\ MOD: PLB 9/10/87 Attempt smart forget.\n"
"\\ MOD: PLB 11/16/87 Add CURRENT.OBJECT\n"
"\\ MOD: PLB 1/13/87 Use PFA for backlinking methods instead of NFA.\n"
"\\ MOD: PLB 9/13/88 Add [FORGET] to eliminate need for MRESET\n"
"\\ MOD: PLB 5/22/89 Add 0 ob-state ! to [FORGET]\n"
"\\ MOD: PLB 9/22/89 Fix stack checking for H4th.\n"
"\\ MOD: PLB 12/15/89 Add Defining Class for METHODS.OF\n"
"\\ MOD: PLB 3/31/92 Added INHERIT.METHOD\n"
"\\ 00001 PLB 8/3/92 Objects put absolute address on stack.\n"
"\n"
"ANEW TASK-OBMETHOD\n"
"\n"
": MI++  ( -- index , allocate new method index )\n"
"    mi-next @  ( current )\n"
"    dup 1+ mi-next !   ( increment )\n"
";\n"
"\n"
"\\ Method contents:\n"
"\\    CELL 0 = method index.\n"
"\\    CELL 1 = method back link (in relocatable form ).\n"
"\n"
"\\ Holds PFA of last defined method, relocatable.\n"
"CREATE METHOD-LAST 0 ,\n"
"\n"
": (METHOD)  ( <name:> -- , declare method for later definition )\n"
"    CREATE\n"
"        here  ( for linking )\n"
"        mi++ ,  ( cell1: set index )\n"
"        method-last @ , ( cell2: back pointer )\n"
"        use->rel method-last !   ( point to PFA of this method. )\n"
"        immediate  ( make it immediate )\n"
"    DOES>   @  ob.bind  ( bind message to object )\n"
";\n"
"\n"
": METHOD  ( <name:>  -- , declare method if new )\n"
"    >in @ >r \\ save input pointer\n"
"    ho.find.pfa\n"
"    r> >in !  \\ restore input pointer\n"
"    IF\n"
"        @ mi-next <\n"
"        IF bl word count type .\"  - method already declared.\" cr\n"
"        ELSE   (method)\n"
"        THEN\n"
"    ELSE (method)\n"
"    THEN\n"
";\n"
"\n"
": OB.MIND@ ( <WORD> -- INDEX , return index )\n"
"    ho.find.pfa NOT\n"
"    IF\n"
"        \" OB.MIND@\" \" Method not declared!\"\n"
"        ER_FATAL  ER.REPORT\n"
"    ELSE  ( save NFA of method for debugger )\n"
"        dup pfa->nfa current-method !  @\n"
"    THEN\n"
";\n"
"\n"
"\\ Pairs checking for Method definitions.\n"
": OB.CHECK:M  ( flag -- , report pairing error if flag different )\n"
"    dup ob-inside-:m @ =\n"
"    IF  not ob-inside-:m !\n"
"    ELSE drop \" OB.CHECK:M\" \" Missing :M or ;M in class definition!\"\n"
"        er_fatal er.report\n"
"    THEN\n"
";\n"
"\n"
"\\ :M is one of the most complicated words in the system.\n"
"\\ It generates a headerless secondary with some object stack manipulations\n"
"\\ at the beginning and end.\n"
"\\ It will have to be hand tweaked for each FORTH because of\n"
"\\ differences in the compilers.\n"
"\n"
": :M ( <method> -- , COMPILE A METHOD FOR A CLASS )\n"
"    false ob.check:m\n"
"    ob.mind@  dup ob-current-mind !\n"
"    :noname ( -- mi exectoken , save exectoken )\n"
"\\\n"
"\\ Calculate offset into cfa table for this method.\n"
"    swap cell*                ( -- cfa moffset )\n"
"\\ Store CFA in methods table.\n"
"    ob-current-class @    ob_cfas +   ( -- base_cfas ) + !\n"
";\n"
"\n"
"defer ;M immediate\n"
"\n"
": <;M> ( -- , Terminate method definition )\n"
"    true ob.check:m\n"
"    current-method off\n"
"    -1 ob-current-mind !\n"
"    [compile] ;     ( Go back to interpretation mode , checks stack )\n"
";  immediate\n"
"\\ Use deferred ;M for Locals and Debugger.\n"
"    ' <;M> is ;M\n"
"    \n"
"\n"
"0 MI-NEXT !  ( reset method counter )\n"
"METHOD INIT:  ( INIT: MUST have method index = 0 !!! )\n"
"\n"
"\\ This is handy for inside Forth words called from a method.\n"
": CURRENT.OBJECT ( -- object )\n"
"    os.copy\n"
"\\ use->rel \\ 00001\n"
";\n"
"\n"
"create MRESET-WARN true ,\n"
"\n"
": MRESET ( <method> -- )\n"
"    32 word\n"
"    mreset-warn @\n"
"    IF  .\" MRESET \"  $type\n"
"        .\"  is no longer needed!\" cr\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": [FORGET] ( -- , reset method index )\n"
"    [forget]\n"
"    method-last @ rel->use  ( get last method )\n"
"    BEGIN dup here > ( is it forgotten )\n"
"    WHILE ( -- method_pfa )\n"
"        cell+ @ if.rel->use\n"
"    REPEAT\n"
"    dup if.use->rel method-last !  ( set pointer to last )\n"
"    @ 1+ mi-next !    ( reset index so CFA tables don't grow)\n"
"    0 ob-state !   ( reset state to avoid :CLASS warnings )\n"
";\n"
"\n"
": METHOD.LINK ( method_PFA -- index previous_pfa )\n"
"    dup @ swap cell+ @ ?dup\n"
"    IF rel->use\n"
"    ELSE 0  ( for the Mac )\n"
"    THEN\n"
";\n"
"\n"
": (.METHOD)  ( method_pfa method_index -- , print it )\n"
"    4 .r space pfa->nfa id.\n"
";\n"
"\n"
": ALL.METHODS ( -- list all methods )\n"
"    cr method-last @ rel->use\n"
"    BEGIN dup\n"
"    WHILE dup method.link -rot\n"
"        (.method) cr ?pause\n"
"    REPEAT drop\n"
";\n"
"\n"
"variable OB-SCRATCH\n"
"\n"
": ?DEFINING.CLASS ( method_index pfa_class -- pfa_class' )\n"
"\\ Scan backwards in Class list to find first occurrence of method.\n"
"\\ Do this by checking superclass for bad method, index overrange,\n"
"\\   or 0 pointer.\n"
"    2dup method@ >r  ( cfa to match with )\n"
"\\ Give up if 0 super link.\n"
"    BEGIN dup ..@ ob_super dup ob-scratch ! ( non-zero? )\n"
"        IF  ( super class = 0 for object class )\n"
"\\ Give up if method count of superclass too low.\n"
"            ob-scratch @ ..@ ob_#methods 2 pick >\n"
"\\ Give up if method CFA doesn't match\n"
"            IF  over ob-scratch @ method@ r@ =\n"
"                IF drop ob-scratch @ ( use super ) false\n"
"                ELSE true\n"
"                THEN\n"
"            ELSE true\n"
"            THEN\n"
"        ELSE true\n"
"        THEN\n"
"    UNTIL rdrop nip\n"
";\n"
"\n"
": METHODS.OF ( <class> -- , list valid methods for class )\n"
"    cr ho.find.pfa\n"
"    IF  dup ob.check.class\n"
"        >r\n"
"\\ Start with last method defined, scan all methods,\n"
"\\ print it if its method cfa is not the OB.BAD.METHOD cfa.\n"
"        method-last @ rel->use\n"
"        BEGIN dup  ?pause\n"
"\\ Link to next method header in dictionary.\n"
"        WHILE dup method.link -rot ( -- prev pfa i )\n"
"\\ Check to see if class method table is big enough.\n"
"            dup r@ ..@ ob_#methods <  ( -- prev pfa i f )\n"
"            IF  ( prev pfa index )\n"
"\\ Compare CFA of method.\n"
"                dup r@ method@ 'c ob.bad.method -\n"
"                IF  tuck (.method) 4 spaces\n"
"                    r@ ?defining.class pfa->nfa\n"
"                    BL 20 emit-to-column id. cr\n"
"                ELSE 2drop\n"
"                THEN\n"
"            ELSE 2drop\n"
"            THEN\n"
"        REPEAT drop\n"
"        rdrop\n"
"    ELSE \" METHODS.OF\" \" Not a class!\"\n"
"        er_fatal er.report\n"
"    THEN\n"
";\n"
"\n"
": IS.SUPER? { pfa_class1 pfa_class2 | flag -- flag , is class2 a superclass of class1 }\n"
"    false -> flag\n"
"    pfa_class1\n"
"    BEGIN\n"
"        ..@ ob_super ?dup\n"
"    WHILE\n"
"        dup pfa_class2 =\n"
"        IF\n"
"            true -> flag\n"
"        THEN\n"
"    REPEAT\n"
"    flag\n"
";\n"
"\n"
": INHERIT.METHOD  ( <method> <class> -- )\n"
"    ob-state @ 0=\n"
"    abort\" INHERIT.METHOD only valid between :CLASS and ;CLASS\"\n"
"\\\n"
"\\ get method index of method given\n"
"    ho.find.pfa NOT\n"
"    IF \" INHERIT.METHOD\" \" METHOD not found\"\n"
"        ER_FATAL ER.REPORT\n"
"    THEN ( -- method-pfa )\n"
"    @ >r \\ get method index\n"
"\\\n"
"\\ get class\n"
"    ho.find.pfa NOT\n"
"    IF \" INHERIT.METHOD\" \" CLASS not found\"\n"
"        ER_FATAL ER.REPORT\n"
"    THEN ( -- class-pfa )\n"
"    dup ob.check.class\n"
"\\\n"
"\\ warn if not superclass of current class\n"
"    ob-current-class @ over is.super? not\n"
"    IF\n"
"        .\" Warning from INHERIT.METHOD. \"\n"
"        dup pfa->nfa id.\n"
"        .\"  not a SUPER-class of \"\n"
"        ob-current-class @ pfa->nfa id. cr\n"
"    THEN\n"
"\\\n"
"\\ get cfa for that method\n"
"    .. ob_cfas\n"
"    r@ cells + @  ( method cfa )\n"
"\\\n"
"\\ save in current class\n"
"    ob-current-class @  ( -- pfa-class )\n"
"    .. ob_cfas\n"
"    r> cells + !\n"
";\n"
"\n"
"\\ Required Initialization\n"
": OB.INIT ( -- )\n"
"    os.sp!   ( set object stack pointers )\n"
"    0 ob-state !\n"
"    0 ob-current-class !\n"
"    0 ob-self-cfas !\n"
"    0 ob-super-cfas !\n"
"    0 ob-dooper-cfas !\n"
"    true ob-if-check-bind !\n"
";\n"
": OB.TERM ( -- )\n"
";\n";

const char* obmethod_fth = (const char*) temp_binary_data_53;

//================== obobject.fth ==================
static const unsigned char temp_binary_data_54[] =
"\\ @(#) obobject.fth 96/06/11 1.1\n"
"\\ Basic Classes of Object, Integer and Array.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 Delta Research\n"
"\\\n"
"\\ MOD: PLB 6/29/86 Clear OB-PNTR in INIT:, use INIT: SUPERs\n"
"\\ MOD: PLB 7/03/86 Do FREE: in NEW: , FREE: only if allocated.\n"
"\\ MOD: PLB 7/14/86 Add USE.DICT: method., changed OB-#ELEMS to OB-#CELLS\n"
"\\ MOD: PLB 7/16/86 Fixed bug introduced by last mod, WARRAY & ARRAY\n"
"\\      weren't using INIT: SUPER and so weren't initing OB-USE-DICT\n"
"\\      to false.  Therefore lot's of things were getting allocated\n"
"\\      in the dictionary!\n"
"\\ MOD: PLB 7/26/86 Added STUFF: method.\n"
"\\ MOD: PLB 7/27/86 Added ?DUP IF to INDEXOF: to fix size=0 bug.\n"
"\\                  Moved INDEXOF: from ELMNTS.\n"
"\\ MOD: PLB 7/29/86 Added OB.REPORT for object error reporting.\n"
"\\ MOD: PLB 9/12/86 Added GET.NAME: and PUT.NAME: and +TO:\n"
"\\ MOD: PLB 10/12/86 Changed to new OB.IVAR to IV.LONG system.\n"
"\\ MOD: PLB 10/13/86 Vectored AT: and TO: to allow width changes.\n"
"\\ MOD: PLB 11/21/86 Added width:\n"
"\\ MOD: PLB 12/3/86  Put AR.SELECT.CFA in NEW: for MAC\n"
"\\ MOD: PLB 1/20/87  Change EVENUP.DP to ALIGN\n"
"\\ MOD: PLB 1/21/87 Added INSTANTIATE and DEINSTANTIATE\n"
"\\ MOD: PLB 2/10/87 Added 0 iv=> iv-#cells to FREE:\n"
"\\ MOD: PLB 2/13/87 Added EXTEND: method.\n"
"\\ MOD: PLB 2/19/87 Added EMPTY: stub.  , use MM.ZALLOC\n"
"\\ MOD: PLB 4/2/87  Added USE->REL to OS.DUMP, changed order.\n"
"\\ MOD: PLB 11/16/87 Add RUN.FASTER and RUN.SAFER\n"
"\\          Put CR before name in PRINT:\n"
"\\ MOD: PLB 11/17/87 Added USE->REL to <INSTANTIATE>,\n"
"\\          0 out object when DEINSTANTIATEd to prevent\n"
"\\          continued use.\n"
"\\ MOD: PLB 12/15/87 EXTEND: now does a NEW: if no data.\n"
"\\ MOD: PLB 9/13/88 Allow INSTANTIATE to pass params to INIT:\n"
"\\ MOD: PLB 10/4/89 Add CLASS check to <instantiate>.\n"
"\\ MOD: PLB 11/8/89  Remove USE->REL stuff from INSTANTIATE\n"
"\\ MOD: PLB 12/15/89 Add }stuff: and }NEWStuff:\n"
"\\ MOD: PLB 5/17/91 Split OBJ_ARRAY into OBJ_OBJECT & OBJ_ARRAY\n"
"\\ 00001 PLB 5/22/92 Make PUT.NAME: save name if dynamic.\n"
"\\ 00002 PLB 5/25/92 Add TERM: method when deinstantiated.\n"
"\\ 00003 PLB 6/9/92 Clear object validation key when deinstantiated.\n"
"\\ 00004 PLB 8/3/92 Objects put absolute address on stack.\n"
"\n"
"ANEW TASK-OBOBJECT\n"
"\n"
"variable DYNOBJ-COUNT\n"
"\n"
": <###> ( 0-999 -- addr count , make string with leading zeros )\n"
"    s->d <# # # # #>\n"
";\n"
"\n"
"\\ Support the dynamic allocation of an object.\n"
"32 constant OBJ_NAME_SIZE\n"
":STRUCT  OBJ_DYN_HEADER  \\ Dynamic Header for Object\n"
"    Struct DoubleList odh_node\n"
"    OBJ_NAME_SIZE bytes odh_name\n"
"    4 bytes odh_object\n"
";STRUCT\n"
"\n"
"DoubleList OBJ-DYN-LIST  \\ list of dynamically alloced objs\n"
"\n"
": OBJ.OBJ>DH  ( dynamic_object -- dynamic_header )\n"
"    odh_object -\n"
";\n"
": OBJ.DH>OBJ  ( dynamic_header -- dynamic_object)\n"
"    odh_object +\n"
";\n"
"\n"
": ODH.INIT obj-dyn-list dll.newlist ;\n"
"\n"
": OB.INIT  .\" OB.INIT\" cr ob.init odh.init ;\n"
": AUTO.INIT  auto.init ob.init ;\n"
"\n"
"( declare methods for object, define OBJECT class )\n"
"METHOD TERM: \\ 00002\n"
"METHOD ADDRESS:\n"
"METHOD SPACE:\n"
"METHOD DUMP:\n"
"METHOD NAME:\n"
"METHOD PUT.NAME:\n"
"METHOD GET.NAME:\n"
"METHOD .CLASS:\n"
"\n"
":CLASS OBJECT   ( root class )\n"
"    IV.RPTR IV-NAME  ( This must always be the first IVAR )\n"
"\n"
":M INIT:  ( -- , setup object )\n"
"    0 iv=> iv-name\n"
";M\n"
"\n"
":M TERM: ( -- ) \\ 00002\n"
";M\n"
"\n"
":M ADDRESS:  ( -- addr , leave address of object )\n"
"    os.copy\n"
";M\n"
"\n"
":M SPACE: ( -- NBYTES , size of ivariable space )\n"
"    os.copy  ob.obj->class ( point to base of class )\n"
"    @\n"
";M\n"
"\n"
":M DUMP: ( -- , hex dump ivars )\n"
"    os.copy space: self  dump\n"
";M\n"
"\n"
":M GET.NAME: ( -- $name , put name of object on pad as string )\n"
"    iv-name ?dup 0=\n"
"    IF address: self pfa->nfa nfa->$\n"
"    ELSE dup c@ 31 >\n"
"        IF nfa->$\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M NAME: ( -- , print name of object )\n"
"    get.name: self $.\n"
";M\n"
"\n"
"\\ Object Error Reporting -----------------------------------\n"
": OS.DUMP ( -- , Show objects on OBJECT-STACK )\n"
"    >newline .\" Object Stack --------\" cr\n"
"    os.depth 0\n"
"    ?DO  os.depth i - 1- os.pick\n"
"\\ use->rel \\ 00004\n"
"        4 spaces name: [] cr\n"
"    LOOP\n"
";\n"
"\n"
": OB.REPORT.ERROR  ( $word $message level -- , report error in object )\n"
"    os.dump\n"
"    dup er_fatal =    IF os.sp! THEN\n"
"    er.report\n"
";\n"
"\n"
":M PUT.NAME: ( $name -- , put name of object in object )\n"
"    self in.dict? not  \\ is this dynamically instantiated?\n"
"    IF\n"
"        dup c@ OBJ_NAME_SIZE <\n"
"        IF\n"
"            self obj.obj>dh .. odh_name\n"
"            tuck $move  \\ set dynamic name\n"
"        THEN\n"
"    THEN\n"
"    iv=> iv-name\n"
";M\n"
"\n"
":M .CLASS: ( -- , print class of object )\n"
"    address: self ob.obj->class\n"
"    pfa->nfa id.\n"
";M\n"
"\n"
";CLASS\n"
"\n"
": OBJ.FIND.DYN  { $name | rel_obj tempobj -- rel_obj true | false }\n"
"    0 -> rel_obj\n"
"    obj-dyn-list dll.first\n"
"    BEGIN\n"
"        dup dll.end? not\n"
"        IF\n"
"            dup obj.dh>obj\n"
"\\ use->rel \\ 00004\n"
"            -> tempobj\n"
"            get.name: tempobj $name\n"
"            $equal\n"
"            IF\n"
"                tempobj -> rel_obj true\n"
"            ELSE\n"
"                dll.next false\n"
"            THEN\n"
"        ELSE true\n"
"        THEN\n"
"    UNTIL drop\n"
"    rel_obj ?dup 0= 0=\n"
";\n"
"\n"
": 'O ( <name> -- rel_obj , return relative object )\n"
"    bl word\n"
"    obj.find.dyn 0= abort\" Couldn't find dynamic object!\"\n"
";\n"
"\n"
": OBJ.LIST.DYN  ( -- )\n"
"    >newline\n"
"    obj-dyn-list dll.first\n"
"    BEGIN\n"
"        dup dll.end? not\n"
"    WHILE\n"
"        dup .. odh_name 4 spaces $type cr?\n"
"        dll.next\n"
"    REPEAT\n"
"    drop\n"
";\n"
"\n"
": <?INSTANTIATE> ( pfa_class --  rel_addr_object | 0 , instantiate class )\n"
"    dup ob.check.class\n"
"    dup >r @ ( -- size )\n"
"    odh_object + ( make room for fake name and node)\n"
"    mm.zalloc? ?dup\n"
"    IF\n"
"        dup obj-dyn-list dll.add.head\n"
"        r> ( -- dynheader class )\n"
"        over >r\n"
"        swap .. odh_object swap  \\ convert to object address\n"
"        ob.setup ( use return stack to allow passing to INIT: )\n"
"\\\n"
"\\ Store unique name in OBJ_NAME_SIZE bytes before object.\n"
"        \" DYN\" r@ .. odh_name $move\n"
"        dynobj-count @ 1+ dup dynobj-count ! <###>  ( addr count )\n"
"        r@ .. odh_name $append\n"
"        r@ .. odh_name\n"
"        r> obj.dh>obj\n"
"\\ use->rel \\ 00004\n"
"        tuck put.name: []\n"
"    ELSE\n"
"        rdrop 0\n"
"    THEN\n"
";\n"
"\n"
": <INSTANTIATE> (  pfa_class --  rel_addr_object | ABORT )\n"
"    <?instantiate>\n"
"    dup 0= abort\" <INSTANTIATE> - insufficient memory!\"\n"
";\n"
"\n"
": INSTANTIATE ( <class> -- addr_object | abort , instantiate class )\n"
"    bl word find\n"
"    IF ( -- cfa )\n"
"        >body\n"
"        state @\n"
"        IF [compile] aliteral compile <instantiate>\n"
"        ELSE <instantiate>\n"
"        THEN\n"
"    ELSE ( -- name )\n"
"        >newline $type cr\n"
"        \" INSTANTIATE\" \" Class could not be found!\"\n"
"        er_fatal er.report\n"
"    THEN\n"
"; IMMEDIATE\n"
"\n"
": ?INSTANTIATE ( <class> -- addr_object | 0 , instantiate class )\n"
"    bl word find\n"
"    IF ( -- cfa )\n"
"        >body\n"
"        state @\n"
"        IF [compile] aliteral compile <?instantiate>\n"
"        ELSE <?instantiate>\n"
"        THEN\n"
"    ELSE ( -- name )\n"
"        >newline $type cr\n"
"        \" ?INSTANTIATE\" \" Class could not be found!\"\n"
"        er_fatal er.report\n"
"    THEN\n"
"; IMMEDIATE\n"
"\n"
": DEINSTANTIATE ( object -- , Deallocate an object )\n"
"\\   rel->use \\ 00004\n"
"    dup in.dict?\n"
"    IF\n"
"        drop \\ in dictionary, not allocated\n"
"    ELSE\n"
"        dup ob.valid?\n"
"        IF\n"
"            dup term: []  \\ give object an opportunity to clean up 00002\n"
"            0 over !  ( clear class pointer to disable object )\n"
"            0 over cell+ ! ( clear object validation key  00003 )\n"
"            obj.obj>dh dup dll.remove mm.free\n"
"        ELSE\n"
"            drop \\ maybe already deinstantiated\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
"\\ define OB.INT class --------------------------------------\n"
"METHOD CLEAR:\n"
"METHOD GET:\n"
"METHOD PUT:\n"
"METHOD PRINT:\n"
"METHOD +:\n"
"\n"
":CLASS OB.INT <SUPER OBJECT\n"
"    IV.LONG IV-INT-DATA\n"
"\n"
":M CLEAR: ( -- , set to zero )\n"
"    0 iv=> iv-int-data\n"
";M\n"
"\n"
":M INIT:  ( -- , setup )\n"
"    clear: self\n"
";M\n"
"\n"
":M GET:  ( -- value , fetch )\n"
"    iv-int-data\n"
";M\n"
"\n"
":M PUT: ( value -- , store )\n"
"    iv=> iv-int-data\n"
";M\n"
"\n"
":M PRINT: ( -- , show data )\n"
"    cr get: self . cr\n"
";M\n"
"\n"
":M +: ( value -- , add to contents )\n"
"    iv+> iv-int-data\n"
";M\n"
";CLASS\n"
"\n";

const char* obobject_fth = (const char*) temp_binary_data_54;

//================== p4thbase.fth ==================
static const unsigned char temp_binary_data_55[] =
"\\ @(#) p4thbase.fth 96/06/11 1.1\n"
"\\ Basic Host Dependant Forth words.\n"
"\\ These are provided to make H4th into a generic Forth.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1989 Phil Burk\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 2/13/91 c/ashift/shift/ in CHOOSE for 62000 CHOOSE\n"
"\\ MOD: PLB 6/24/91 Add WARRAY BARRAY\n"
"\\ 00001 PLB 11/20/91 New EXIT, better DUP>R\n"
"ANEW TASK-P4THBASE\n"
"\n"
"decimal\n"
"0 constant #HOST_AMIGA_JFORTH\n"
"0 constant #HOST_MAC_H4TH\n"
"1 constant #HOST_PFORTH\n"
"\n"
": ..!\n"
"    state @\n"
"    IF\n"
"        postpone s!\n"
"    ELSE\n"
"        [compile] s!\n"
"    THEN\n"
"; immediate\n"
"\n"
": ..@\n"
"    state @\n"
"    IF\n"
"        postpone s@\n"
"    ELSE\n"
"        [compile] s@\n"
"    THEN\n"
"; immediate\n"
"\n"
":  N>TEXT ( number -- addr count , convert number to text )\n"
"    (.)\n"
";\n"
"\n"
": TEXT>STRING ( address count -- $string , convert to string on pad )\n"
"    dup pad c!  ( set count )\n"
"    pad 1+ swap cmove\n"
"    pad\n"
";\n"
"\n"
": H. ( N -- , print a number in HEX )\n"
"    base @ swap hex . base !\n"
";\n"
"\n"
": BELL  ( -- , ring bell )\n"
"    cr .\" BEEP!\" cr\n"
";\n"
"\n"
": NOTYET  ( -- )\n"
"    .\" NOT YET IMPLEMENTED!!\" cr\n"
";\n"
"\n"
"decimal\n"
"\n"
"\\ Many FORTHS differ in the way that they implement -FIND\n"
"\\ ' CFA PFA etc.  These should be avoided.\n"
"\\ For the sake of consistency I shall define how I am using these terms:\n"
"\\    CFA = address that can be passed to EXECUTE\n"
"\\    PFA = address of data in a create does word.\n"
"\\    LFA = address of backward link for dictionary.\n"
"\\    NFA = address of count byte for word name.\n"
"HEX\n"
"    \n"
": CFA->PFA  ( cfa -- pfa )\n"
"    >body\n"
";\n"
"DECIMAL\n"
"\n"
": CFA->NFA  ( cfa -- nfa )\n"
"    >name\n"
";\n"
"\n"
"0 [if]\n"
": LFA->NFA  ( lfa -- nfa )\n"
"    10 +\n"
";\n"
": LFA->CFA  ( lfa -- cfa )\n"
"    lfa->nfa nfa->cfa\n"
";\n"
": CFA->LFA  ( cfa -- lfa )\n"
"    cfa->nfa nfa->lfa\n"
";\n"
"[then]\n"
"\n"
": PFA->NFA   ( pfa -- nfa , convert )\n"
"     body> >name\n"
";\n"
"\n"
": NFA->PFA ( nfa -- pfa )\n"
"    name> >body\n"
";\n"
"\n"
"\n"
": HO.FIND.PFA   ( -- , pfa true | false , look for word in dict. )\n"
"\\ Return address of parameter data.\n"
"     32 word find\n"
"     IF  >body true\n"
"     ELSE drop false\n"
"     THEN\n"
";\n"
"\n"
": HO.FIND.CFA   ( -- , cfa true | 0 , look for word in dict. )\n"
"\\ Return address of identifying address\n"
"\\ Returns code address for dumping or comparison.\n"
"     32 word find\n"
"     IF  true\n"
"     ELSE .\" Couldn't find \" id. false\n"
"     THEN\n"
";\n"
"\n"
": V: ( -- , declare variable and set to zero )\n"
"    variable\n"
";\n"
"\n"
"\\ H4th uses absolute addresses.\n"
": USE->ABS\n"
"; immediate\n"
": ABS->USE\n"
"; immediate\n"
"\n"
": u2/  1 rshift ;\n"
"-1 u2/ constant HO_MAX_INT\n"
"HO_MAX_INT 1+ CONSTANT HO_MIN_INT\n"
"\n"
"\\ Used for debugging.\n"
": TIB.DUMP ( -- , Dump current line )\n"
"    source type\n"
";\n"
"\n"
"\\ ======= ====== ARITHMETIC GOODIES ======== ========\n"
": | ( n m -- n|m , for easy AMIGA calls )\n"
"    OR\n"
";\n"
"\n"
"\\ ======= ====== Memory Access ==== ======== =========\n"
"\\ These words are used for accessing absolute memory locations\n"
"\\ like registers, etc.\n"
": ABS!   ( value absolute_address -- , store value )\n"
"    !\n"
";\n"
": ABSW!   ( value absolute_address -- , store value )\n"
"    w!\n"
";\n"
": ABSC!   ( value absolute_address -- , store value )\n"
"    c!\n"
";\n"
"\n"
": ABS@   ( absolute_address -- value , fetch value )\n"
"    @\n"
";\n"
": ABSW@   ( absolute_address -- value , fetch value )\n"
"    w@\n"
";\n"
": ABSC@   ( absolute_address -- value , fetch value )\n"
"    c@\n"
";\n"
"\n"
"\\ FORTH83 uses a different system for PICK !!!\n"
"\\ Mach2 conforms to Forth83, -> PICK is 0 based.\n"
": PICK83 PICK ;\n"
": PICK79 1- PICK ;\n"
"\n"
"0 constant NULL  ( for pointers )\n"
"\n"
": HOST\"  ( <text>\" -- , compile a host string )\n"
"    [compile] \"  ( Mac uses count byte like Forth )\n"
"; immediate\n"
"\n"
".\" Declaring fake user variable!\" cr\n"
": U: ( <name> -- , Make a variable )\n"
"    V:\n"
";\n"
"\n"
": XDUP ( x1 x2 x3 .. xN N -- x1 x2 .. x1 x2  , duplicate N items )\n"
"    dup 1+ swap 0\n"
"    ?DO dup pick79 swap\n"
"    LOOP drop\n"
";\n"
"\n"
": WITHIN? ( N LO HI -- flag , true if within inclusive range )\n"
"    1+ within\n"
";\n"
"\n"
": IN.DICT?  ( address -- flag , inside dictionary? )\n"
"    codebase here within?\n"
";\n"
"\n"
": INLINE ; IMMEDIATE\n"
": BOTH ;   IMMEDIATE\n"
"\n"
": DUP>R ( -- , must be inline , 00001 )\n"
"    postpone dup\n"
"    postpone >r\n"
"; immediate\n"
"\n"
"\\ Benchmark Forth words.\n"
": PRINT.TIME  ( #ticks -- , print as seconds )\n"
"    100 *\n"
"    60 /mod\n"
"    swap 60 / + 0\n"
"    <# # # ascii . hold #s #> type space\n"
";\n"
"\n"
"0 [if]\n"
": MEASURE ( <tib> -- , benchmark whatever follows )\n"
"    Tickcount() >r interpret Tickcount()\n"
"    r> - \n"
"    cr .\" That took \" print.time .\" seconds.\" cr\n"
";\n"
": RDEPTH ( -- return_stack_depth )\n"
"    r0 @ rp@ - cell/\n"
";\n"
"[then]\n"
"\n"
"V: MAX-INLINE   ( stub for JForth compatibility )\n"
"\n"
": VALLOT ALLOT ;\n"
"\n"
": RO.EXECUTE  ( rel_cfa -- )\n"
"    rel->use execute\n"
";\n"
"\n"
"\\ Support to allow the debugger to work with ODE.\n"
"variable CURRENT-METHOD\n"
"\n"
"\\ Initialization needed for all variables!!!\n"
": BASE.INIT\n"
"      8 tab-width !\n"
"      here rand-seed !\n"
";\n"
"\n"
": BASE.TERM ;\n"
"\n"
": S->D  ( s -- d  )\n"
"    dup 0<\n"
"    IF -1\n"
"    ELSE 0\n"
"    THEN\n"
";\n"
"\n"
": 2**N  ( n -- 2**n )\n"
"    1 swap shift\n"
";\n"
"\n"
"HEX\n"
"0 [if]\n"
": ODD@  ( addr -- val , fetch from an odd address )\n"
"    [   5896 w,   \\   addq.l  #4,(a6)\n"
"        205e w,   \\   move.l  (a6)+,a0\n"
"        1d20 w,   \\   move.l  -(a0),-(a6)\n"
"        1d20 w, 1d20 w, 1d20 w,\n"
"    ]\n"
";\n"
".\" Fix RETURN so that it works with DO LOOPs\" cr bell\n"
": RETURN ( -- )\n"
"    compile exit\n"
"; immediate\n"
"\n"
"[then]\n"
"\n"
": 4/  2 arshift ;\n"
"\n"
"cell 8 = [IF]\n"
"    : CELL/  3 arshift ;\n"
"[ELSE]\n"
"    : CELL/  2 arshift ;\n"
"[THEN]\n"
"\n"
": EMIT-TO-COLUMN  ( char col -- )\n"
"    out @ -\n"
"    0 max 80 min  0\n"
"    ?DO dup emit\n"
"    LOOP drop\n"
";\n"
"\n"
"\\ Debug help\n"
"variable if-compile-debug\n"
"variable if-print-debug\n"
"\n"
"if-compile-debug off\n"
"if-print-debug on\n"
"\n"
": DBUG.TYPE ( addr cnt -- )\n"
"    if-print-debug @\n"
"    IF\n"
"        type cr .s\n"
"    ELSE\n"
"        2drop\n"
"    THEN\n"
";\n"
"\n"
": (DBUG\")  ( -- , type following string )\n"
"    r> count 2dup + aligned >r\n"
"    dbug.type\n"
";\n"
"\n"
": DBUG\"  ( string\" -- )\n"
"    if-compile-debug @\n"
"    IF\n"
"        state @\n"
"        IF  compile (dbug\")  ,\"\n"
"        ELSE ascii \" parse dbug.type\n"
"        THEN\n"
"    ELSE\n"
"        ascii \" parse 2drop\n"
"    THEN\n"
"; immediate\n"
"\n"
".\" WARNING: DO redefined as ?DO\" cr\n"
": DO  ( l s -- , should we use ?DO )\n"
"    postpone ?DO\n"
"; immediate\n"
"\n"
": ASHIFT  ( n shifter -- , shift left if positive, right if negative )\n"
"    dup 0>\n"
"    IF\n"
"        lshift\n"
"    ELSE\n"
"        negate\n"
"        arshift\n"
"    THEN\n"
";\n"
"\n"
"variable time-current\n"
"\n"
": 4+ 4 + ;\n"
": 4- 4 - ;\n"
": 4* 2 lshift ;\n"
"\n"
": ?QUIT ( -- false ) false ;\n"
": ?STOP ( -- false ) false ;\n"
"\n"
": ? ( addr - , print contents of variable )\n"
"    @ .\n"
";\n"
"\n"
"$ 1D constant RIGHT_ARROW\n"
"$ 1C constant LEFT_ARROW\n"
"$ 1E constant SHIFT_RIGHT_ARROW\n"
"$ 1F constant SHIFT_LEFT_ARROW\n";

const char* p4thbase_fth = (const char*) temp_binary_data_55;

//================== packed_midi.fth ==================
static const unsigned char temp_binary_data_56[] =
"\\ Tools for handling packed MIDI messages.\n"
"\\ A packed MIDI Message one cell packed as:\n"
"\\     b0-b1-b2-cn\n"
"\\\n"
"\\ 1-3 bytes ORd with a count byte.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1990 Phil Burk\n"
"\\ MOD: PLB 6/19/91 use only vtime\n"
"decimal\n"
"\n"
"ANEW TASK-PACKED_MIDI\n"
"\n"
"variable PM-OUT-PAD  ( only used by this next word in background )\n"
"\n"
": MIDI.UNPACK  ( packed-midi -- addr count )\n"
"    pm-out-pad 2dup be!\n"
"    swap 3 and\n"
";\n"
"\n"
": MIDI.PACK  ( addr count -- packed-midi )\n"
"    dup 4 <\n"
"    IF swap be@ $ FFFFFF00 and OR\n"
"    ELSE .\" MIDI.PACK doesn't handle SYSEX!\" cr 2drop 0\n"
"    THEN\n"
";\n"
"\n"
": INTERP.PACKED.MIDI  ( elmnt# shape instr -- )\n"
"    drop\n"
"    1 swap ed.at: []  ( get packed data )\n"
"    midi.unpack  midi.write\n"
";\n"
"\n"
"defer OLD.MIDI.WRITE\n"
"ob.shape CAPTURED-MIDI   \\ shape to hold captured events\n"
"\n"
"variable CAPTURE-TIME\n"
"variable IF-CAPTURING\n"
"variable ECHO-CAPTURE\n"
"echo-capture on\n"
"\n"
": CAPTURE.MIDI  ( addr count -- , write MIDI to shape )\n"
"    echo-capture @\n"
"    IF 2dup old.midi.write\n"
"    THEN\n"
"    captured-midi ensure.room ( -- a c )\n"
"    midi.pack\n"
"    capture-time @ 0=\n"
"    IF\n"
"        vtime@ capture-time !  \\ first time?\n"
"    THEN\n"
"    vtime@ rtc.time@ max capture-time @ -\n"
"    tuck 0 search.back: captured-midi ( - a c i )\n"
"    insert: captured-midi\n"
";\n"
"\n"
": }CAPTURE  ( -- )\n"
"    if-capturing @\n"
"    IF  what's old.midi.write is midi.write\n"
"        if-capturing off\n"
"    THEN\n"
";\n"
"\n"
": CAPTURE{ ( -- )\n"
"    }capture\n"
"    0 capture-time !\n"
"    what's midi.write is old.midi.write\n"
"    'c capture.midi is midi.write\n"
"    if-capturing on\n"
"    64 2 new: captured-midi\n"
";\n"
": CAPTURE.TERM\n"
"    free: captured-midi\n"
";\n"
"\n"
"if.forgotten capture.term\n"
"\n"
"ob.player pl-capture\n"
"ob.midi.instrument ins-capture\n"
"\n"
": PLAY.CAPTURED  ( -- )\n"
"    captured-midi ins-capture build: pl-capture\n"
"    use.absolute.time: pl-capture\n"
"    'c interp.packed.midi put.on.function: ins-capture\n"
";\n";

const char* packed_midi_fth = (const char*) temp_binary_data_56;

//================== player.fth ==================
static const unsigned char temp_binary_data_57[] =
"\\ This Morph plays the Shapes it contains.\n"
"\\ It keeps track of time and calls an Instrument to make the\n"
"\\ sound occur.\n"
"\\\n"
"\\ The Duration of an event is defined as the time until\n"
"\\ the next event occurs.\n"
"\\ The duration of an event is determined as follows:\n"
"\\   1) If the DUR.FUNCTION is nonzero, the function will\n"
"\\      calculate a duration.\n"
"\\   2) If the dur-dim is >= 0 , the duration will be read from\n"
"\\      the dimension.\n"
"\\   3) Otherwise the duration will come from the duration set by\n"
"\\      PUT.DURATION:\n"
"\\\n"
"\\ The ON time of an event is defined as the time between\n"
"\\ the start (ON) and end (OFF) of an event.\n"
"\\ If the ON time is longer than the DUR then events will overlap.\n"
"\\ The ON time is determined as follows:\n"
"\\   1) If the on-dim is >= 0 , the ON time will be read from\n"
"\\      that dimension.\n"
"\\   2) Otherwise the DUTY cycle will determine the ON time\n"
"\\      as a fraction of the duration.  If the numerator and\n"
"\\      denominator of the duty cycle are both zero then\n"
"\\      there will be no OFF event and no notion of ON time.\n"
"\\ Once the ON-TIME is determined, the value ON.TIME is set\n"
"\\ for reading by interpreters.\n"
"\\\n"
"\\ The calling of the OFF Interpreter was important in the\n"
"\\ the original HMSL but is now mostly obsolete.\n"
"\\\n"
"\\ Allow setting start of player to a specific time.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 3/2/87 Add ABORT: processing.\n"
"\\ MOD: PLB 3/7/87 Add duration scheduling.\n"
"\\ MOD: PLB 3/7/87 Add legato for on>total.\n"
"\\ MOD: PLB 5/23/87 Add STOP: , no done? for TASK:\n"
"\\ MOD: PLB 5/28/87 Add ?HIERARCHICAL:\n"
"\\ MOD: PLB 6/15/87 Add DEFAULT:\n"
"\\ MOD: PLB 10/7/87 Add PUT.DUR.FUNCTION:\n"
"\\ MOD: PLB 9/26/89 Add PREFAB: and BUILD: , add internal pending list,\n"
"\\      Allow absolute time.\n"
"\\ MOD: PLB 10/23/89 Only do PREFAB: if MIDI defined.\n"
"\\ MOD: PLB 10/27/89 Don't fail if empty shape.\n"
"\\ MOD: PLB 3/26/90 Add ON.TIME\n"
"\\ 00001 PLB 10/1/91 print IV-PL-OFFSET\n"
"\\ 00002 PLB 2/6/92 Use EXEC.STACK?\n"
"\\ 00003 PLB 11/20/91 Use EXIT instead of RETURN\n"
"\\ 00004 PLB 3/31/92 INHERIT.METHODS from LIST classes.\n"
"\n"
"ANEW TASK-PLAYER\n"
"\n"
"METHOD PUT.DUTY.CYCLE:      METHOD GET.DUTY.CYCLE:\n"
"METHOD PUT.DUR.DIM:         METHOD GET.DUR.DIM:\n"
"METHOD PUT.ON.DIM:          METHOD GET.ON.DIM:\n"
"METHOD PUT.DUR.FUNCTION:    METHOD GET.DUR.FUNCTION:\n"
"METHOD ?DONE:\n"
"METHOD USE.RELATIVE.TIME:   METHOD USE.ABSOLUTE.TIME:\n"
"METHOD PLAY.ONLY.ON:        METHOD PLAY.ON&OFF:\n"
"METHOD SET.TIMER:\n"
"\n"
":CLASS OB.PLAYER <SUPER OB.JOB\n"
"    IV.LONG  IV-PL-DUR-DIM    ( dimensions holding DURATIONS )\n"
"    IV.LONG  IV-PL-DUR-FUNCTION\n"
"    IV.LONG  IV-PL-CUR-DUR    ( this elements duration )\n"
"\\ IVARs for ON time\n"
"    IV.LONG  IV-PL-DUTY-ON    ( numerator for duty cycle )\n"
"    IV.LONG  IV-PL-DUTY-TOTAL ( denominator for duty cycle )\n"
"    IV.LONG  IV-PL-TIMEOFF    ( portion of time element is off )\n"
"    IV.LONG  IV-PL-ON-DIM     ( dimension holding ON-TIMEs )\n"
"    IV.LONG  IV-PL-LEG-E#     ( element # of legato note )\n"
"\\ This next IV is also used as a flag, 0 if last was not legato.\n"
"    IV.LONG  IV-PL-LEG-SHAPE  ( shape legato note came from )\n"
"\\\n"
"    IV.LONG  IV-PL-SHAPE      ( Shape currently being processed )\n"
"    IV.LONG  IV-PL-ELMNT#     ( Points to current element in shape )\n"
"    IV.LONG  IV-PL-OFFSET     ( time offset for starting )\n"
"    IV.LONG  IV-PL-OFFSET-ADD ( time to add when starting )\n"
"    iv.long  IV-PL-START-REP  ( start on this repetition )\n"
"\n"
"    IV.LONG  IV-PL-ON#        ( index of element while on, waiting for off )\n"
"    IV.LONG  IV-PL-ALLOW?     ( Allow element off? )\n"
"\\\n"
"    IV.BYTE  IV-PL-IF-ABSOLUTE  ( true if use absolute time )\n"
"    IV.BYTE  IV-PL-IF-ON&OFF    ( true if use OFF interpreter )\n"
"    IV.BYTE  IV-PL-IF-PREFAB    ( true if prefabricated )\n"
"    IV.LONG  IV-PL-START-TIME   ( time player started )\n"
"\n"
":M DEFAULT: ( -- )\n"
"\\ Don't get rid of instrument if prefab.\n"
"    iv-pl-if-prefab\n"
"    IF iv-jb-instrument\n"
"       default: super\n"
"       iv=> iv-jb-instrument\n"
"    ELSE default: super\n"
"    THEN\n"
"    4 iv=> iv-pl-duty-on    ( default duty cycle = 4/5 )\n"
"    5 iv=> iv-pl-duty-total\n"
"\\\n"
"    0 iv=> iv-pl-dur-dim\n"
"    -1 iv=> iv-pl-on-dim\n"
"    0 iv=> iv-pl-dur-function\n"
"    8 iv=> iv-jb-duration\n"
"\\\n"
"    false iv=> iv-pl-if-absolute\n"
"    false iv=> iv-pl-if-on&off\n"
";M\n"
"\n"
":M INIT: ( -- )\n"
"    init: super\n"
"    -1 iv=> iv-pl-elmnt#\n"
"    0 iv=> iv-pl-shape      ( current shape )\n"
"    -1 iv=> iv-pl-on#\n"
"    0 iv=> iv-pl-leg-shape\n"
"    false iv=> iv-pl-if-prefab\n"
";M\n"
"\n"
":M FREE: ( -- , free prefab stuff too )\n"
"    iv-pl-if-prefab\n"
"    IF 0 get: self dup free: [] deinstantiate  ( shape )\n"
"       get.instrument: self ?dup\n"
"       IF dup free: [] deinstantiate\n"
"       THEN\n"
"       0 put.instrument: self\n"
"       0 iv=> iv-pl-if-prefab\n"
"    THEN\n"
"    free: super\n"
";M\n"
"\n"
"exists? OB.MIDI.INSTRUMENT [IF]\n"
":M PREFAB:  ( -- , dynamically instantiate shape and instrument )\n"
"    free: self\n"
"    instantiate ob.shape dup prefab: []\n"
"    instantiate ob.midi.instrument\n"
"    build: self\n"
"    true iv=> iv-pl-if-prefab\n"
";M\n"
"[THEN]\n"
"\n"
":M USE.RELATIVE.TIME: ( -- , use time till next event )\n"
"    false iv=> iv-pl-if-absolute\n"
";M\n"
":M USE.ABSOLUTE.TIME: ( -- , use time since start: )\n"
"    true iv=> iv-pl-if-absolute\n"
";M\n"
"\n"
":M PLAY.ON&OFF: ( -- , call if you want player to use both )\n"
"    true iv=> iv-pl-if-on&off\n"
";M\n"
"\n"
":M PLAY.ONLY.ON: ( -- , call if you want player to only use ON )\n"
"    false iv=> iv-pl-if-on&off\n"
";M\n"
"\n"
":M PUT.DUTY.CYCLE: ( on total -- )\n"
"    dup 0= 0= iv=> iv-pl-if-on&off\n"
"    iv=> iv-pl-duty-total\n"
"    iv=> iv-pl-duty-on\n"
";M\n"
"\n"
":M GET.DUTY.CYCLE: ( -- on total )\n"
"    iv-pl-duty-on\n"
"    iv-pl-duty-total\n"
";M\n"
"\n"
":M PUT.DUR.DIM: ( dim -- , set total duration dimension )\n"
"    iv=> iv-pl-dur-dim\n"
";M\n"
":M GET.DUR.DIM: ( -- dim , which dimension has total duration? )\n"
"    iv-pl-dur-dim\n"
";M\n"
"\n"
":M PUT.DUR.FUNCTION: ( cfa -- , set duration function )\n"
"    iv=> iv-pl-dur-function\n"
";M\n"
":M GET.DUR.FUNCTION: ( -- cfa , fetch duration function )\n"
"    iv-pl-dur-function\n"
";M\n"
"\n"
":M PUT.ON.DIM: ( dim | -1 -- , set on time dimension )\n"
"    iv=> iv-pl-on-dim\n"
";M\n"
":M GET.ON.DIM: ( -- dim | -1 , which dimension has on time? )\n"
"    iv-pl-on-dim\n"
";M\n"
"\n"
":M WHERE:  ( -- elmnt# shape# , last one played )\n"
"    iv-pl-elmnt# 1+ iv-current 1-\n"
";M\n"
"\n"
":M GOTO:  ( elmnt# shape# -- , jump to different shape )\n"
"    dup at: self iv=> iv-pl-shape\n"
"    1+ iv=> iv-current  ( set current to after that shape )\n"
"    1- iv=> iv-pl-elmnt#\n"
";M\n"
"\n"
": PL.NEXT.ABSOLUTE ( -- , Set start timer )\n"
"    iv-pl-if-absolute\n"
"    IF  iv-time-next iv=> iv-pl-start-time\n"
"        0 iv-pl-dur-dim iv-pl-shape ed.at: []\n"
"        iv+> iv-time-next  ( set time for first event )\n"
"    THEN\n"
";\n"
"\n"
": PL.START.ABSOLUTE ( -- , Set start timer )\n"
"    iv-pl-if-absolute\n"
"    IF  iv-time-next\n"
"        iv-pl-elmnt# 1+ iv-pl-dur-dim iv-pl-shape ed.at: []\n"
"        iv-pl-offset-add - -\n"
"            iv=> iv-pl-start-time\n"
"        iv-pl-offset-add iv+> iv-time-next  ( set time for first event )\n"
"    THEN\n"
";\n"
"\n"
": PL.NEXT.SHAPE ( -- , move to next shape )\n"
"\\ Keep going until you find a shape with data.\n"
"\\ Set IV-PL-SHAPE to 0 if none found.\n"
"    0 iv=> iv-pl-shape\n"
"    BEGIN manyleft: self 0>\n"
"        IF next: self dup iv=> iv-pl-shape\n"
"           many: [] 0>\n"
"           IF  pl.next.absolute true\n"
"           ELSE 0 iv=> iv-pl-shape false  ( keep looking )\n"
"           THEN\n"
"        ELSE true\n"
"        THEN\n"
"    UNTIL\n"
"    -1 iv=> iv-pl-elmnt#\n"
";\n"
"\n"
":M CUSTOM.EXEC: ( -- time true | false , set start time )\n"
"\\ Check for instrument.\n"
"    iv-jb-instrument 0=\n"
"    IF  \" CUSTOM.EXEC: OB.PLAYER\" \" No instrument!\"\n"
"         er_fatal ob.report.error\n"
"    THEN\n"
"    -1 iv=> iv-pl-on#\n"
"\\\n"
"\\ Get first shape.\n"
"    many: self 0>\n"
"    IF  iv-pl-offset 0=  \\ leave at current position if there\n"
"        IF  reset: self\n"
"            pl.next.shape\n"
"        ELSE\n"
"            iv-pl-shape  \\ avoid crash if set.timer past end\n"
"            IF  pl.start.absolute\n"
"            ELSE\n"
"                0 iv=> iv-pl-offset\n"
"                0 iv=> iv-pl-offset-add\n"
"                0 iv=> iv-pl-start-rep\n"
"            THEN\n"
"            iv-repcount iv-pl-start-rep - iv=> iv-repcount\n"
"        THEN\n"
"        iv-pl-shape 0=\n"
"        iv-repcount 0= OR\n"
"        IF  iv-time-next true   ( let's not bother )\n"
"        ELSE custom.exec: super\n"
"        THEN\n"
"        iv-pl-offset-add iv+> iv-time-next\n"
"    ELSE\n"
"       \" CUSTOM.EXEC: OB.PLAYER\" \" No shapes!\"\n"
"       er_return ob.report.error\n"
"    THEN\n"
"\\\n"
";M\n"
"\n"
": PL.LEGATO.OFF ( -- , turn off legato element )\n"
"    iv-pl-leg-e# iv-pl-leg-shape\n"
"    iv-jb-instrument element.off: []\n"
"    0 iv=> iv-pl-leg-shape\n"
";\n"
"\n"
": PL.ELMNT.OFF ( -- , turn last element off )\n"
"\\ Turn off last element if LEGATO.\n"
"    iv-pl-leg-shape\n"
"    IF pl.legato.off\n"
"    ELSE\n"
"        iv-pl-allow?\n"
"        IF  iv-pl-elmnt# iv-pl-shape\n"
"            iv-jb-instrument element.off: []\n"
"            false iv=> iv-pl-allow?\n"
"        THEN\n"
"        -1 iv=> iv-pl-on#\n"
"\\ Schedule next event.\n"
"        iv-pl-timeoff iv+> iv-time-next\n"
"    THEN\n"
";\n"
"\n"
": PL.SET.LEGATO ( -- )\n"
"    iv-pl-if-on&off  ( is this desired )\n"
"    IF  iv-pl-shape iv=> iv-pl-leg-shape  ( LEGATO this element )\n"
"        iv-pl-elmnt# iv=> iv-pl-leg-e#\n"
"    THEN\n"
";\n"
"\n"
":M GET.DURATION: ( -- duration , calculate duration )\n"
"\\ Is there a DUR.FUNCTION ?\n"
"    iv-pl-dur-function ?dup\n"
"    IF >r iv-pl-elmnt# iv-pl-shape r>\n"
"        -1 exec.stack?  \\ should ( e# sh -- dur )\n"
"\\\n"
"\\ If not, then if no DUR dimension, use DURATION\n"
"    ELSE iv-pl-dur-dim 0<\n"
"        IF iv-jb-duration\n"
"\\\n"
"\\ Read DUR dimension\n"
"        ELSE iv-pl-if-absolute  ( calc ticks to next event )\n"
"\\ ABSOLUTE TIME\n"
"            IF  iv-pl-shape many: [] iv-pl-elmnt# 1+ >\n"
"                 IF iv-pl-elmnt# 1+ iv-pl-dur-dim iv-pl-shape\n"
"                    ed.at: []  ( time of next event )\n"
"                    iv-pl-start-time + iv-time-next -\n"
"                 ELSE 0\n"
"                 THEN\n"
"\\ RELATIVE TIME\n"
"             ELSE iv-pl-elmnt# iv-pl-dur-dim iv-pl-shape ed.at: []\n"
"             THEN\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
": PL.SCAN.TIME ( time -- total false | time true )\n"
"\\ scan for element and shape\n"
"{ time | shape num atime ifhit -- endat ifhit , calculate duration }\n"
"    0 -> ifhit\n"
"\\ Is there a DUR.FUNCTION ?\n"
"    iv-pl-dur-function\n"
"    IF 0 0\n"
"    ELSE iv-pl-dur-dim 0<\n"
"        IF \\ use constant duration\n"
"            time iv-jb-duration /mod -> num\n"
"            iv=> iv-pl-offset-add\n"
"            many: self 0\n"
"            ?DO i at: self ( shape )\n"
"                many: [] dup num >\n"
"                IF  drop num i goto: self\n"
"                    true -> ifhit LEAVE\n"
"                ELSE num swap - -> num\n"
"                THEN\n"
"            LOOP\n"
"            num iv-jb-duration * ifhit\n"
"        ELSE iv-pl-if-absolute  ( calc ticks to next event )\n"
"\\ ABSOLUTE TIME\n"
"            IF  0 -> num\n"
"                many: self 0\n"
"                ?DO i at: self ( shape ) dup -> shape\n"
"                    many: [] 0\n"
"                    ?DO i iv-pl-dur-dim shape ed.at: [] -> atime\n"
"                        num atime + time >=\n"
"                        IF  i j goto: self\n"
"                            num atime + time - iv=> iv-pl-offset-add\n"
"                            true -> ifhit\n"
"                            LEAVE\n"
"                        THEN\n"
"                    LOOP\n"
"                    ifhit\n"
"                    IF LEAVE  ( got it )\n"
"                    THEN\n"
"                    atime num + -> num\n"
"                LOOP\n"
"                num ifhit\n"
"\\ RELATIVE TIME\n"
"            ELSE 0 -> num\n"
"                many: self 0\n"
"                ?DO i at: self ( shape ) dup -> shape\n"
"                    many: [] 0\n"
"                    ?DO i iv-pl-dur-dim shape ed.at: [] ( Rtime )\n"
"                        num + -> num\n"
"                        num time >=\n"
"                        IF  i j goto: self\n"
"                            num time - iv=> iv-pl-offset-add\n"
"                            true -> ifhit LEAVE\n"
"                        THEN\n"
"                    LOOP\n"
"                    ifhit\n"
"                    IF LEAVE  ( got it )\n"
"                    THEN\n"
"                LOOP\n"
"                num ifhit\n"
"            THEN\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
":M SET.TIMER:  ( time -- )\n"
"    dup iv=> iv-pl-offset\n"
"    0 iv=> iv-pl-start-rep\n"
"    iv-start-delay - \\ account for start delay\n"
"    dup pl.scan.time 0=  \\ Is it NOT in first repitition?\n"
"    IF ( time' total )\n"
"        dup 0>\n"
"        IF  ( time' total )\n"
"            iv-repeat-delay +\n"
"            /mod dup iv-repeat < \\ Is it before end of last?\n"
"            IF  ( rem n )\n"
"                iv=> iv-pl-start-rep\n"
"                pl.scan.time\n"
"            ELSE dup iv-repeat min  iv=> iv-pl-start-rep\n"
"            THEN\n"
"        THEN\n"
"    THEN\n"
"    iv-repeat iv-pl-start-rep - iv=> iv-repcount\n"
"    2drop\n"
";M\n"
"\n"
": PL.SET.DELAY ( delay -- , set timenext to delay )\n"
"    iv-jb-epochal?\n"
"    IF iv+> iv-time-next\n"
"    ELSE time@ + iv=> iv-time-next\n"
"    THEN\n"
";\n"
"\n"
": PL.SET.DUR&ON     ( -- , Precalculate timing for element. )\n"
"    get.duration: self  ( -- dur ) dup iv=> iv-pl-cur-dur\n"
"\\\n"
"    iv-pl-on-dim dup 0<\n"
"\\ Calculate ON from duty cycle.  ( -- dur on-dim flag )\n"
"    IF  drop iv-pl-duty-on iv-pl-duty-total\n"
"        >r * r> /\n"
"\\\n"
"\\ OR Look up in \"on\" dimension.\n"
"    ELSE ( -- total on_dim , calc delay from shape )\n"
"        nip iv-pl-elmnt# swap iv-pl-shape ed.at: []  ( -- on_time )\n"
"    THEN\n"
"    -> on.time  ( set global value for interpreters )\n"
";\n"
"\n"
": PL.TIMING  ( -- , determine time till next event )\n"
"    iv-pl-cur-dur on.time\n"
"    iv-pl-if-on&off\n"
"    IF  ( -- dur time_on )\n"
"        2dup <\n"
"        IF pl.set.legato drop 0\n"
"        ELSE tuck -\n"
"        THEN\n"
"        iv=> iv-pl-timeoff  ( -- time_on )\n"
"    ELSE drop   ( -- dur )\n"
"    THEN\n"
"    pl.set.delay\n"
";\n"
"\n"
"\n"
": PL.NEXT.ELMNT ( -- play next element in shape )\n"
"    1 iv+> iv-pl-elmnt#   ( advance pointer )\n"
"\\ Set on time for next events.\n"
"    pl.set.dur&on\n"
"\\\n"
"    jb.in.time?   ( or are we too late )\n"
"    IF\n"
"       iv-pl-elmnt# iv-pl-shape 2dup\n"
"       iv-jb-instrument element.on: []   ( ON )\n"
"       pl.now.playing\n"
"       true iv=> iv-pl-allow?\n"
"    ELSE false iv=> iv-pl-allow?\n"
"    THEN\n"
"\\\n"
"\\ Set number of ON element for later OFF if desired\n"
"    iv-pl-if-on&off\n"
"    IF  iv-pl-elmnt# iv=> iv-pl-on#\n"
"    THEN\n"
"\\\n"
"\\ Now turn off any overlapped LEGATO elements.\n"
"    iv-pl-leg-shape iv-pl-if-on&off AND\n"
"    IF pl.legato.off\n"
"    THEN\n"
"\\\n"
"    pl.timing\n"
"\\\n"
";\n"
"\n"
":M TERMINATE: ( time -- , turn off pending off events )\n"
"    iv-pl-on# 0< NOT\n"
"    IF pl.elmnt.off  ( turn off if on )\n"
"    THEN\n"
"    iv-pl-leg-shape\n"
"    IF pl.legato.off\n"
"    THEN\n"
"    0 iv=> iv-pl-shape\n"
"    0 iv=> iv-pl-elmnt#\n"
"    0 iv=> iv-pl-offset\n"
"    0 iv=> iv-pl-offset-add\n"
"    0 iv=> iv-pl-start-rep\n"
"    terminate: super  ( use OB.JOB termination )\n"
";M\n"
"\n"
":M ?DONE: ( -- , cleanup if the morph is done )\n"
"    col.do.repeat iv-repcount 0=\n"
"    IF iv-time-next terminate: self\n"
"    ELSE\n"
"       reset: self\n"
"       pl.next.shape\n"
"    THEN\n"
";M\n"
"\n"
":M TASK: ( -- , play pending elements. )\n"
"    BEGIN\n"
"        iv-time-next doitnow?\n"
"    WHILE\n"
"        iv-pl-on# 0<   iv-pl-leg-shape OR\n"
"        IF  iv-pl-elmnt# iv-pl-shape many: [] 1- <\n"
"            IF pl.next.elmnt\n"
"            ELSE\n"
"                iv-pl-shape pl.stop.playing\n"
"                pl.next.shape iv-pl-shape 0=\n"
"                IF ?done: self exit  \\ 00003\n"
"                THEN\n"
"            THEN\n"
"        ELSE pl.elmnt.off  ( turn off if on )\n"
"        THEN\n"
"    REPEAT\n"
";M\n"
"\n"
":M PRINT.ELEMENT:  ( e# -- , print the element )\n"
"    get: self  ( get morph)\n"
"    name: []\n"
";M\n"
"\n"
":M PRINT: ( -- )\n"
"    print: super ?pause\n"
"    .\" DURation func.= \" iv-pl-dur-function cfa. cr\n"
"    .\" DURation dim. = \" iv-pl-dur-dim . cr\n"
"    .\" ON dimension  = \" iv-pl-on-dim . cr ?pause\n"
"    .\" Duty Cycle    = \" iv-pl-duty-on . iv-pl-duty-total . cr\n"
"    .\" Offset Time   = \" iv-pl-offset . cr \\ 00001\n"
"    iv-pl-if-absolute\n"
"    IF .\" Absolute Time\" cr\n"
"    ELSE .\" Relative Time\" cr\n"
"    THEN ?pause\n"
";M\n"
"\n"
":M ?HIERARCHICAL:  ( -- flag , true if can contain other morphs)\n"
"    true\n"
";M\n"
"\n"
"\\ Since this is a one-dimensional list, let's inherit a bunch\n"
"\\ of object list methods. \\ 00004\n"
"inherit.method freeall: ob.objlist\n"
"inherit.method deinstantiate: ob.objlist\n"
"inherit.method ?instantiate: ob.objlist\n"
"\n"
";CLASS\n"
"\n"
"\\ Test player\n"
"false [IF]\n"
"\n"
"OB.PLAYER PL1\n"
"OB.MIDI.INSTRUMENT INS1\n"
"OB.SHAPE SH1\n"
"\n"
": TP.FILL\n"
"    32 4 new: sh1\n"
"    20 0\n"
"    DO  10 i *\n"
"        10 i +\n"
"        100 8 add: sh1\n"
"    LOOP\n"
"\\\n"
"    default: ins1\n"
"    4 new: pl1\n"
"    sh1 add: pl1\n"
"    ins1 put.instrument: pl1\n"
"    use.absolute.time: pl1\n"
"    10 put.repeat.delay: pl1\n"
"    2 put.repeat: pl1\n"
"    3 put.on.dim: pl1\n"
";\n"
"\n"
": TP.FREE\n"
"    free: pl1\n"
"    free: sh1\n"
";\n"
"if.forgotten tp.free\n"
"[THEN]\n"
"\n"
"\n";

const char* player_fth = (const char*) temp_binary_data_57;

//================== popup_text.fth ==================
static const unsigned char temp_binary_data_58[] =
"\\ Popup Text Entry for changing parameters in hierarchy editor, etc.\n"
"\\\n"
"\\ Based on Robert Marsanyi's Unit Editor\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1991 Phil Burk\n"
"\\\n"
"\\ 00001 PLB 10/1/92 Add screen title to avoid garbage \n"
"\n"
"ANEW TASK-POPUP_TEXT\n"
"\n"
"\\ Data structures\n"
"\n"
"ob.screen popt-screen\n"
"ob.text.grid popt-text-grid\n"
"\n"
"variable EU-PARENT-SCREEN       ( store the parent in here when activated )\n"
"variable EU-CUR-UNIT\n"
"\n"
"defer POPT.CALLBACK\n"
"\n"
"\\ Functions for controls\n"
"\n"
": CLOSE.POPUP.TEXT ( -- , exit screen )\n"
"    eu-parent-screen @ ?dup\n"
"    IF\n"
"        cg-current-screen off\n"
"        cg-drawing-screen off\n"
"        draw: []\n"
"        eu-parent-screen off\n"
"        eu-cur-unit off\n"
"\\ This should not be needed!  Something is\n"
"\\ turning on tracking but I can't figure out what!!!  %Q\n"
"EV.TRACK.OFF\n"
"    THEN\n"
";\n"
"\n"
": POPT.CR.FUNC ( $text part -- )\n"
"    drop\n"
"    popt.callback  \\ pass string back\n"
"    close.popup.text\n"
";\n"
"\n"
"1000 value POPT_XPOS\n"
"1000 value POPT_YPOS\n"
"700 value POPT_WIDTH\n"
"300 value POPT_HEIGHT\n"
"\n"
": POPT.SET.XY.DC ( xpos ypos -- )\n"
"    -> popt_ypos\n"
"    -> popt_xpos\n"
";\n"
"\n"
": OPEN.POPUP.TEXT { $deftext maxchars callbackcfa -- }\n"
"    $deftext 1+ maxchars gr.textlen 8 + 0\n"
"    scg.delta.dc->wc drop -> popt_width\n"
"    popt_xpos popt_ypos put.xy.dc: popt-screen\n"
"    popt_width popt_height put.wh: popt-text-grid\n"
"    callbackcfa is popt.callback\n"
"    1 1 maxchars new: popt-text-grid\n"
"    $deftext 0 put.text: popt-text-grid\n"
"\\\n"
"    cg-current-screen @ eu-parent-screen !\n"
"    cg-drawing-screen on            ( so it doesn't clear )\n"
"    cg-current-screen off\n"
"    draw: popt-screen\n"
"    cg-drawing-screen off\n"
"    popt-screen cg-current-screen !\n"
";\n"
"\n"
"\\ Build grids, screen\n"
"\n"
": BUILD.POPUP.TEXT\n"
"    1 1 20 new: popt-text-grid\n"
"    765 350 put.wh: popt-text-grid\n"
"    20 30 put.xy: popt-text-grid\n"
"    'c popt.cr.func put.cr.function: popt-text-grid\n"
";\n"
"\n"
": BUILD.POPT.SCREEN\n"
"    10 3 new: popt-screen  \\ make room for custom editing 00001\n"
"    popt-text-grid  10 10 add: popt-screen\n"
"    \" Enter Text\" put.title: popt-screen\n"
";\n"
"\n"
"\\ Init and Term\n"
"\n"
": INIT.POPUP.TEXT\n"
"    build.popup.text\n"
"    build.popt.screen\n"
";\n"
"\n"
": TERM.POPUP.TEXT\n"
"    freeall: popt-screen\n"
"    free: popt-screen\n"
";\n"
"\n"
": SYS.INIT  sys.init init.popup.text ;\n"
": SYS.TERM  term.popup.text sys.term ;\n"
"\n"
"false [IF]\n"
"\n"
"ob.screen test\n"
"ob.menu.grid doit\n"
"\n"
": SHOW.TEXT ( $text -- )\n"
"    .\" Text = \" $type cr\n"
";\n"
"\n"
": DOIT.FUNC ( value part -- )\n"
"    2drop\n"
"    \" Hello\" 20 'c show.text open.popup.text\n"
";\n"
"\n"
": BUILD.TEST\n"
"    1 1 new: doit\n"
"    300 300 put.wh: doit\n"
"    'c doit.func put.up.function: doit\n"
"    \n"
"    10 3 new: test\n"
"    doit 200 500 add: test\n"
"    test default-screen !\n"
";\n"
"\n"
": init.test\n"
"    init.popup.text\n"
"    build.test\n"
";\n"
"\n"
": term.test\n"
"    term.popup.text\n"
"    freeall: test\n"
"    free: test\n"
"    gr.closecurw\n"
";\n"
"if.forgotten term.test\n"
"\n"
": TPT\n"
"    init.test\n"
"    gr.closecurw\n"
"    gr.openhmsl\n"
"    test sc.test\n"
"    gr.closecurw\n"
";\n"
"[THEN]\n";

const char* popup_text_fth = (const char*) temp_binary_data_58;

//================== production.fth ==================
static const unsigned char temp_binary_data_59[] =
"\\ Productions - a simple morph that can be executed\n"
"\\ from other morphs to perform custom functions.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"\\ MOD: PLB 1/27/87 Store CFAs in array, not IVAR.\n"
"\\ MOD: PLB 5/23/87 Add STOP: noop.\n"
"\\ MOD: PLB 5/28/87 Add ?HIERARCHICAL:\n"
"\\ MOD: PLB 9/23/87 Preserve CURRENT-PRODUCTION value in EXECUTE:\n"
"\\ MOD: PLB 5/23/89 Convert to new design, add vtime\n"
"\\ MOD: PLB 4/5/90 New STOP code\n"
"\n"
"ANEW TASK-PRODUCTION\n"
"\n"
"V: CURRENT-PRODUCTION\n"
"\n"
":CLASS OB.PRODUCTION <SUPER OB.MORPH\n"
"\n"
":M ?NEW:  ( Max_elements -- addr | 0 )\n"
"    1 ?NEW: SUPER   ( declare as one dimensional )\n"
";M\n"
"\n"
":M NEW: ( max_elements -- , abort if error )\n"
"    ?new: self <new:error>\n"
";M\n"
"\n"
"\\ Since this is a one-dimensional list, let's inherit a bunch\n"
"\\ of list methods.\n"
"inherit.method delete: ob.list\n"
"inherit.method 0stuff: ob.list\n"
"inherit.method }stuff: ob.list\n"
"\n"
":M CUSTOM.EXEC: ( -- time true  , execute functions )\n"
"    iv-time-next vtime!\n"
"    current-production @ >r\n"
"    self current-production !\n"
"    iv-repeat 0\n"
"    ?DO many: self 0\n"
"       ?DO i at: self  ( get CFA )\n"
"           execute\n"
"       LOOP\n"
"       iv-repeat-delay vtime+!\n"
"    LOOP\n"
"    iv-repeat-delay negate vtime+!  ( in case rep=1 )\n"
"    r> current-production !\n"
"    vtime@ true\n"
";M\n"
"\n"
":M PRINT.ELEMENT: ( e# -- )\n"
"    at: self cfa.\n"
";M\n"
"\n"
":M PRINT.HIERARCHY: ( -- , print name and indent for children )\n"
"    >newline morph-indent @ spaces name: self\n"
"    3 morph-indent +!\n"
"    many: self 0\n"
"    ?DO  >newline morph-indent @ spaces \n"
"        i self print.element: []\n"
"    LOOP\n"
"    -3 morph-indent +!\n"
";M\n"
"\n"
":M ?HIERARCHICAL:  ( -- flag , true if can contain other morphs)\n"
"    false\n"
";M\n"
"\n"
";CLASS\n";

const char* production_fth = (const char*) temp_binary_data_59;

//================== record.fth ==================
static const unsigned char temp_binary_data_60[] =
"\\ Tools for recording notes into shapes,\n"
"\\ playback, shape conversion, player initialization, etc.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1990 Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ MOD: PLB 7/18/90 Allow record on only one channel, RC-REC-CHANNEL\n"
"\\ MOD: PLB 7/19/90 In SH.EXPAND.NOTES add TARGET EMPTY: []\n"
"\n"
"ANEW TASK-RECORD\n"
"\n"
"\\ Utilities for converting one shape to another.\n"
"\\ The two most common forms for storing notes in a shape are:\n"
"\\    1) compressed, 1 element/note with ONTIME\n"
"\\    1) expanded, 2 elements/note with zero velocity for off\n"
"\\\n"
"\\ These utilities will convert between them.\n"
"\\ The times are considered to be in ABSOLUTE form\n"
"\\ which means relative to the beginning of the shape,\n"
"\\ as opposed to RELATIVE to the previous event.\n"
"\n"
": SH.ATLEAST  { #elements #dim shape -- , for dim, at least }\n"
"    shape dimension: []  #dim = not\n"
"    shape max.elements: [] #elements < OR\n"
"    IF #elements #dim shape new: []\n"
"    THEN\n"
";\n"
"\n"
": SH.COMPRESS.NOTES  ( source target -- , extract expanded notes )\n"
"    { source target | time note vel ontime -- , locals }\n"
"\\ Assume times are absolute, sorted.\n"
"\\ Setup target shape\n"
"    source many: [] 2/ 8 +  4  target sh.atleast\n"
"    target empty: []\n"
"\\\n"
"\\ check source\n"
"    source dimension: [] 3 -\n"
"    abort\" SH.COMPRESS - Source must have 3 dimensions.\"\n"
"\\\n"
"\\ Loop through all notes in source\n"
"    source many: []  0\n"
"    ?DO  i source get: []  -> vel -> note -> time\n"
"\\ When we find an ON, look for corresponding OFF\n"
"        vel 0>\n"
"        IF  0 -> ontime\n"
"\\ Loop through remaining notes\n"
"            source many: []  i 1+\n"
"            ?DO  i source get: []  0=  ( OFF event ? )\n"
"                IF note =  ( matching note? )\n"
"                    IF ( -- time_of_off )\n"
"                        time - -> ontime LEAVE\n"
"                    ELSE drop\n"
"                    THEN\n"
"                ELSE 2drop\n"
"                THEN\n"
"            LOOP\n"
"            ontime 0= \n"
"            IF  .\" SH.COMPRESS - Missing OFF event.\" cr\n"
"                1 -> ontime\n"
"            THEN\n"
"\\ Add note to target shape\n"
"            time note vel ontime target add: []\n"
"        THEN\n"
"    LOOP\n"
";\n"
"\n"
": SH.EXPAND.NOTES ( source target -- , expand notes into two )\n"
"    { source target | time note vel ontime -- , locals }\n"
"\\ Make room in target.\n"
"    source many: [] 2*  3 target sh.atleast\n"
"    target empty: []\n"
"\\\n"
"\\ Loop throught source notes.\n"
"    source many: [] 0\n"
"    ?DO  i source get: [] -> ontime -> vel -> note -> time\n"
"\\ Insert ON event\n"
"        time note vel ( values for target shape ON event )\n"
"        time 0 target search.back: []  ( find spot )\n"
"        target insert: []\n"
"\\ Insert OFF event\n"
"        time ontime + note 0 ( values for target shape ON event )\n"
"        time ontime +  0 target search.back: []  ( find spot )\n"
"        target insert: []\n"
"    LOOP\n"
";\n"
"\n"
"\\ Recording Tools for MIDI Parser -----------------------------\n"
"\n"
"variable RC-START-TIME    ( time recording started )\n"
"variable RC-STOP-TIME     ( time recording stopped )\n"
"variable RC-SHAPE         ( hold shape currently being recorded )\n"
"variable RC-INSTR         ( instrument to echo on, holds interpreters )\n"
"variable RC-REC-CHANNEL   ( which channel to record , -1 for OMNI )\n"
"variable RC-ECHO-CHANNEL  ( which channel to echo on, or -1 )\n"
"-1 rc-echo-channel !\n"
"-1 RC-rec-CHANNEL !\n"
"\n"
"\\ MIDI Parser Functions for recording.\n"
": RC.ADD.NOTE.ON ( note velocity -- , add note to shape )\n"
"\\ Check to see if shape is full, extend if it is.\n"
"    rc-shape @ ensure.room\n"
"\\\n"
"\\ Save note in shape using \"absolute time\" not durations.\n"
"    midi.rtc.time@\n"
"    rc-start-time @ - 0 max ( calc relative time )\n"
"    -rot rc-shape @ add: []  ( add individual on/off event )\n"
";\n"
"\n"
": (RC.NOTE.ON) ( note velocity -- , for MIDI Parser )\n"
"    midi.rtc.time@ vtime!\n"
"\\\n"
"\\ Echo to synthesizer using interpreter if instrument set\n"
"    rc-instr @\n"
"    IF  swap dup rc-instr @ detranslate: []\n"
"        IF nip  ( replace by translated version )\n"
"        THEN\n"
"    swap rc.add.note.on\n"
"        rc-shape @ dup many: [] 1- swap  ( elmnt# shape )\n"
"        rc-instr @ element.on: [] ( just use ON when recording )\n"
"    ELSE rc-echo-channel @ dup 0<\n"
"        IF drop mp.channel@  ( use incoming channel if none specified )\n"
"        THEN\n"
"        midi.channel!\n"
"        2dup midi.noteon\n"
"        rc.add.note.on\n"
"    THEN\n"
";\n"
"\n"
": RC.NOTE.ON ( note velocity -- , for MIDI Parser , check channel )\n"
"    rc-rec-channel @ 0>\n"
"    IF mp.channel@ rc-rec-channel @ =\n"
"        IF (rc.note.on)\n"
"        ELSE 2drop\n"
"        THEN\n"
"    ELSE (rc.note.on)\n"
"    THEN\n"
";\n"
"\n"
": RC.NOTE.OFF ( note velocity -- , for MIDI Parser , check channel )\n"
"    rc-rec-channel @ 0>\n"
"    IF mp.channel@ rc-rec-channel @ =\n"
"        IF DROP 0 (rc.note.on)\n"
"        ELSE 2drop\n"
"        THEN\n"
"    ELSE DROP 0 (rc.note.on)\n"
"    THEN\n"
";\n"
"\n"
"\n"
": (RC.NOTE.WAIT)  ( note velocity -- , start recording on first note )\n"
"    midi.rtc.time@ rc-start-time !\n"
"    rc.note.on\n"
"    'c rc.note.on mp-on-vector !\n"
"    'c rc.note.off mp-off-vector !\n"
";\n"
"\n"
": RC.NOTE.WAIT ( note velocity -- , start recording on first note )\n"
"    rc-rec-channel @ 0>\n"
"    IF mp.channel@ rc-rec-channel @ =\n"
"        IF (rc.note.wait)\n"
"        ELSE 2drop\n"
"        THEN\n"
"    ELSE (rc.note.wait)\n"
"    THEN\n"
";\n"
"\n"
": RECORD.START ( time shape -- , Set MIDI parser )\n"
"    rc-shape !\n"
"    rc-start-time !\n"
"    'c rc.note.on mp-on-vector !\n"
"    'c rc.note.off mp-off-vector !\n"
"    midi.parser.on\n"
";\n"
"\n"
": RECORD.WAIT ( shape -- , start recording when first note played )\n"
"    rc-shape !\n"
"    'c rc.note.wait mp-on-vector !\n"
"    'c 2drop mp-off-vector !\n"
"    midi.parser.on\n"
";\n"
"\n"
": RECORD.STOP ( time -- , stop recording )\n"
"    rc-stop-time !\n"
"    'c 2drop mp-on-vector !\n"
"    'c 2drop mp-off-vector !\n"
";\n"
"\n"
": SETUP.EXP.PLAYBACK  ( player -- , setup for playing back recorded shape )\n"
"    dup play.only.on: []\n"
"    dup use.absolute.time: []\n"
"    get.instrument: [] dup use.standard.interp \\ just turn off or on\n"
"    0 swap put.offset: []\n"
";\n"
"\n"
": EXTRACT.RECORDING  { player | shape -- , copy to other shape for playback }\n"
"    player many: [] 1 =\n"
"    IF  0 player get: [] -> shape\n"
"\\ Copy notes from recorded shape\n"
"        rc-shape @  shape sh.compress.notes\n"
"\\ Convert times to \"relative\"\n"
"        rc-stop-time @ rc-start-time @ -\n"
"            0 shape differentiate: []\n"
"\\ Setup player\n"
"        3 player put.on.dim: []\n"
"        player play.only.on: []\n"
"        'c interp.el.on.for\n"
"          player get.instrument: [] ?dup\n"
"          IF put.on.function: []\n"
"          ELSE drop >newline\n"
"              .\" EXTRACT.RECORDING - Player must have instrument!\" cr\n"
"          THEN\n"
"    ELSE >newline .\" EXTRACT.RECORDING - Player must have shape!\" cr\n"
"    THEN\n"
";\n"
"    \n"
"\\ Test Recording tools\n"
"if-testing @ [IF]\n"
"ob.shape rc-shape\n"
"ob.shape target-shape\n"
"ob.player rc-pl\n"
"ob.midi.instrument rc-ins\n"
"\\ for straight playback\n"
"ob.player rc-pl-x\n"
"ob.midi.instrument rc-ins-x\n"
"\n"
": PLAY.STRAIGHT\n"
"    rc-shape rc-ins-x build: rc-pl-x\n"
"    rc-pl-x play.expanded\n"
"    0 put.offset: rc-ins-x\n"
";\n"
"\n"
": TEST.RECORD  ( -- )\n"
"    32 3 new: rc-shape\n"
"    rc-shape record.wait\n"
"    .\" Record until key hit\" cr\n"
"    forbid()\n"
"    midi.clear\n"
"    midi.parse.loop\n"
"    permit()\n"
"    rtc.time@ record.stop\n"
";\n"
"\n"
": TEST.PLAYBACK ( -- )\n"
"    target-shape rc-ins build: rc-pl\n"
"    rc-pl extract.recording\n"
"    0 put.offset: rc-ins\n"
"    rc-pl hmsl.play\n"
";\n"
"\n"
": RC.TEST.TERM\n"
"    free: rc-shape\n"
"    free: rc-pl\n"
"    free: target-shape\n"
"    mp.reset\n"
";\n"
"[THEN]\n";

const char* record_fth = (const char*) temp_binary_data_60;

//================== scg.fth ==================
static const unsigned char temp_binary_data_61[] =
"\\ Scaled graphics for drawing shapes, etc.\n"
"\\ This is loosely based on the GKS Window and Viewport concept. \n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 6/30/86 Added scg.delta.wc->dc , sc.dc->wc\n"
"\\ MOD: PLB 9/30/86 Changed viewport in scg.test to Y=50,150\n"
"\\                  Use -ROT\n"
"\\ MOD: PLB 10/9/86 Converted */ to * scg_scale ashift ( 5Xfaster!)\n"
"\\ MOD: PLB 12/15/86 Expand viewport rectangle in SHOW\n"
"\\ MOD: PLB 5/24/87 Add SYS.INIT\n"
"\\ MOD: PLB 1/26/88 Draw more spaces in SCG.DRAW.XAXIS and YAXIS to\n"
"\\                  cover old big numbers.\n"
"\\ MOD: PLB 2/8/88  Switch sense of Y axis to put 0,0 in TOP,left.\n"
"\\ MOD: PLB 10/27/89 Add SCG.BOX\n"
"\\ MOD: PLB 10/31/90 Add rounding for better precision.\n"
"\n"
"ANEW TASK-SCG\n"
"\n"
"\\ Fixed point shift scale factor.\n"
"-10 CONSTANT SCG_SCALE  ( negative to optimize wc->dc )\n"
"4096 constant SCG_DEFAULT_WC\n"
"\n"
"( Arrays for holding Window Viewport definitions )\n"
"OB.ELMNTS SCG-WINDOWS\n"
"OB.ELMNTS SCG-VIEWPORTS\n"
"8 CONSTANT SCG-MAXTNR   ( Maximum # normalization transforms)\n"
"\n"
"V: SCG-VALID-TNR  ( valid calculated TNR )\n"
"V: SCG-CTNR ( Current Transformation )\n"
"\n"
"( Current transformation factors, quick calculation. )\n"
"V: SCG-XMULT  V: SCG-XADD\n"
"V: SCG-YMULT  V: SCG-YADD\n"
"\n"
"\\ Set and query window and viewport like GKS\n"
": SCG.SWN ( wxmin wxmax wymin wymax tnr -- , set window )\n"
"    put: scg-windows\n"
"    -1 scg-valid-tnr !\n"
";\n"
": SCG.SVP ( vxmin vxmax vymin vymax tnr -- , set viewport )\n"
"    put: scg-viewports\n"
"    -1 scg-valid-tnr !\n"
";\n"
"\n"
": SCG.QWN ( tnr -- wxmin wxmax wymin wymax , set window )\n"
"    get: scg-windows\n"
";\n"
": SCG.QVP ( tnr -- vxmin vxmax vymin vymax , set viewport )\n"
"    get: scg-viewports\n"
";\n"
"\n"
"V: SCG-WMIN V: SCG-WMAX V: SCG-VMIN V: SCG-VMAX\n"
"\n"
"( Calculate A & B for Ax + B transform )\n"
": SCG.CALCXF ( <above variables> -- mult adder )\n"
"    scg-vmax @ scg-vmin @ - scg_scale negate ashift\n"
"    scg-wmax @ scg-wmin @ - /   ( mult )\n"
"    dup scg-wmin @ * scg_scale ashift\n"
"    scg-vmin @ swap -  ( adder )\n"
";\n"
"\n"
": (SCG.SELNT)  ( tnr -- , Select Normalization Transform )\n"
"    dup scg-ctnr !\n"
"    dup get: scg-windows 2drop scg-wmax ! scg-wmin !\n"
"    dup get: scg-viewports 2drop scg-vmax ! scg-vmin !\n"
"    scg.calcxf scg-xadd ! scg-xmult !\n"
"\\\n"
"    dup get: scg-windows scg-wmax ! scg-wmin ! 2drop\n"
"    get: scg-viewports scg-vmax ! scg-vmin ! 2drop\n"
"    scg.calcxf scg-yadd !    scg-ymult !\n"
";\n"
"\n"
": SCG.SELNT  ( tnr -- , recalculate if not valid )\n"
"    dup scg-valid-tnr @ =\n"
"    IF drop  ( already calculated )\n"
"    ELSE dup (scg.selnt) scg-valid-tnr !\n"
"    THEN\n"
";\n"
"    \n"
": SCG.TNR@ ( -- tnr , Query Transformation number )\n"
"     scg-ctnr @\n"
";\n"
"\n"
"\\ Coordinate conversions\n"
": SCG.WC->DC ( WCX WCY -- DCX DCY , Convert world to device)\n"
"      scg-ymult @ *\n"
"      [ 1 scg_scale negate 1- ashift ] literal + ( round )\n"
"      scg_scale ashift\n"
"      scg-yadd @ + >r\n"
"      scg-xmult @ *\n"
"      [ 1 scg_scale negate 1- ashift ] literal + ( round )\n"
"      scg_scale ashift\n"
"      scg-xadd @ + r>\n"
";\n"
"\n"
": SCG.DELTA.WC->DC ( dWCX dWCY -- dDCX dDCY , Convert delta coordinates)\n"
"      scg-ymult @ *\n"
"      [ 1 scg_scale negate 1- ashift ] literal + ( round )\n"
"      scg_scale ashift >r\n"
"      scg-xmult @ *\n"
"      [ 1 scg_scale negate 1- ashift ] literal + ( round )\n"
"      scg_scale ashift r>\n"
";\n"
"\n"
": SCG.DC->WC ( DCX DCY -- WCX WCY , Convert device to world)\n"
"      scg-yadd @ -\n"
"      [ scg_scale negate ] literal ashift\n"
"      scg-ymult @ dup>r 2/ + ( round ) r> / \n"
"      swap scg-xadd @ -\n"
"      [ scg_scale negate ] literal ashift\n"
"      scg-xmult @ dup>r 2/ + ( round ) r> / swap\n"
";\n"
"\n"
": SCG.DELTA.DC->WC ( dDCX dDCY -- dWCX dWCY , Convert delta coordinates)\n"
"      [ scg_scale negate ] literal ashift\n"
"      scg-ymult @ dup>r 2/ + ( round ) r> / \n"
"      swap [ scg_scale negate ] literal ashift\n"
"      scg-xmult @ dup>r 2/ + ( round ) r> / swap\n"
";\n"
"\n"
": SCG.SHOWVP  ( tnr -- , draw box around viewport )\n"
"     get: scg-viewports rot swap\n"
"     1+ >r 1+ >r 1- >r 1-   r> r> r>  ( expand out by one pixel )\n"
"     ug.box\n"
";\n"
"\n"
"\\ Scaled Graphics Drawing Primitives\n"
": SCG.MOVE ( wcx wcy -- , move )\n"
"     scg.wc->dc gr.move\n"
";\n"
"\n"
": SCG.DRAW ( wcx wcy -- , draw )\n"
"     scg.wc->dc gr.draw\n"
";\n"
"\n"
": SCG.XYTEXT ( xwc ywc text -- , Draw text at x,y)\n"
"    -rot scg.move\n"
"    gr.text\n"
";\n"
"\n"
": SCG.RECT { xw1 yw1 xw2 yw2 -- , Fill world region with FACI }\n"
"    xw1 yw1 scg.wc->dc -> yw1 -> xw1\n"
"    xw2 yw2 scg.wc->dc -> yw2 -> xw2\n"
"    xw1 xw2 2sort -> xw2 -> xw1\n"
"    yw1 yw2 2sort -> yw2 -> yw1  ( prevent big crash )\n"
"    xw1 yw1 xw2 yw2 gr.rect\n"
";\n"
"\n"
": SCG.BOX  ( xw1 yw1 xw2 yw2 -- )\n"
"    scg.wc->dc 2swap scg.wc->dc ug.box\n"
";\n"
"\n"
"\\ Control and Initialization\n"
": SCG.INIT ( -- , Set initial Viewports )\n"
"     -1 scg-valid-tnr !\n"
"     scg-maxtnr 4 new: scg-windows\n"
"     scg-maxtnr 4 new: scg-viewports\n"
"     scg-maxtnr dup set.many: scg-windows  set.many: scg-viewports\n"
"     scg-maxtnr 0\n"
"     ?DO \\ Set all transforms\n"
"         0 scg_default_wc 0 scg_default_wc i SCG.SWN\n"
"         gr_xmin gr_xmax  gr_ymin gr_ymax i scg.svp\n"
"         i scg.selnt\n"
"     LOOP\n"
";\n"
"\n"
": SCG.TERM ( -- , Terminate this system )\n"
"    free: scg-windows\n"
"    free: scg-viewports\n"
";\n"
"\n"
": SCG.NUM.RIGHT  { x y n -- , draw right justified }\n"
"     x n n>text gr.textlen -\n"
"     \"  \" count gr.textlen - y gr.move\n"
"     \"  \" gr.text n gr.number\n"
";\n"
"\n"
"\\ Label corners of a viewport with WC values\n"
": SCG.DRAW.XAXIS\n"
"    scg.tnr@ 0 ed.at: scg-viewports\n"
"    scg.tnr@ 2 ed.at: scg-viewports\n"
"    scg.tnr@ 3 ed.at: scg-viewports MAX\n"
"    gr.height@ + 2+ gr.move\n"
"    scg.tnr@ 0 ed.at: scg-windows gr.number  ( X MIN )\n"
"    \"     \" gr.text\n"
"\\\n"
"    scg.tnr@ 1 ed.at: scg-viewports\n"
"    scg.tnr@ 2 ed.at: scg-viewports\n"
"    scg.tnr@ 3 ed.at: scg-viewports MAX\n"
"    gr.height@ + 2+ ( -- x y )\n"
"    scg.tnr@ 1 ed.at: scg-windows\n"
"    scg.num.right\n"
";\n"
"\n"
": SCG.DRAW.YAXIS ( -- , put on left of viewport )\n"
"    scg.tnr@ 0 ed.at: scg-viewports 4 -\n"
"    scg.tnr@ 2 ed.at: scg-viewports 10 +\n"
"    scg.tnr@ 2 ed.at: scg-windows  ( YMIN )\n"
"    scg.num.right\n"
"\\\n"
"    scg.tnr@ 0 ed.at: scg-viewports 4 -\n"
"    scg.tnr@ 3 ed.at: scg-viewports\n"
"    scg.tnr@ 3 ed.at: scg-windows ( Y MAX )\n"
"    scg.num.right  \n"
";\n"
"\n"
": SCG.DRAW.AXES\n"
"    scg.draw.xaxis\n"
"    scg.draw.yaxis\n"
";\n"
"\n"
": SYS.INIT sys.init scg.init ;\n"
": SYS.TERM scg.term sys.term ;\n"
"\n"
"\\ Test SCG routines ------------------------------------\n"
"if-testing @ [IF]\n"
": SCG.FIG1 ( -- draw a figure )\n"
"      0 0 SCG.MOVE   2000 2000 SCG.DRAW\n"
"      1800 1300 SCG.DRAW    300 700 SCG.DRAW\n"
"      0 0 SCG.DRAW\n"
";\n"
": SCG.TESTNTS ( -- , Set test NTs )\n"
"      0 2000 0 2000 0 SCG.SWN   0 200 0 200 0 SCG.SVP\n"
"      0 2000 0 2000 1 SCG.SWN   200 500 50 150 1 SCG.SVP\n"
";\n"
": SCG.TEST1   ( -- , Test drawing )\n"
"      SCG.TESTNTS\n"
"      0 SCG.SELNT 0 SCG.SHOWVP SCG.FIG1\n"
"      1 SCG.SELNT 1 SCG.SHOWVP SCG.FIG1\n"
";\n"
"[THEN]\n"
"\n";

const char* scg_fth = (const char*) temp_binary_data_61;

//================== screen.fth ==================
static const unsigned char temp_binary_data_62[] =
"\\ Screen Class, Holds Several Control Grids\n"
"\\\n"
"\\ Methods required to be in a screen.\n"
"\\\n"
"\\ NAME:  FREE:  PUT.XY: GET.XY.DC: DRAW: PUT.ACTIVE: UNDRAW:\n"
"\\ MOUSE.DOWN: MOUSE.MOVE: MOUSE.UP: KEY: GET.WH:\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 7/14/86 Now stores relative address of control objects.\n"
"\\ MOD: PLB 8/8/88 Call UNDRAW: for each control.\n"
"\\ MOD: PLB 9/22/89 Big Change, Screens set x,y of grids.\n"
"\\ MOD: PLB 10/5/89 Add DUMP.SOURCE:\n"
"\\ MOD: PLB 10/29/89 Add DEFAULT-SCREEN\n"
"\\ MOD: PLB 2/7/90 Add PUT.KEY:\n"
"\\ MOD: PLB 2/23/90 Add CUSTOM-SCREENS auto add:\n"
"\\ MOD: PLB 3/22/90 Undraw: previous when new one drawn:\n"
"\\ MOD: PLB 7/18/90 Check for '3' in NEW:\n"
"\\ MOD: PLB 2/10/91 No GR_BIG_TEXT , use GR-CURWINDOW not HMSL-WINDOW\n"
"\\ 00001 PLB 9/27/91 Add: KEY:\n"
"\\ 00002 PLB 9/28/91 Added calls to PUT.ACTIVE:\n"
"\\ 00003 PLB 10/9/91 Added def of PUT.ACTIVE: for nested screens.\n"
"\\ 00004 PLB 10/9/91 Use FLAG local variable in MOUSE.DOWN: for nesting.\n"
"\\ 00005 PLB 2/6/92 Use EXEC.STACK?\n"
"\\ 00006 PLB 2/12/92 Use put.xy.dc:\n"
"\\ 00007 PLB 2/17/92 Fixed hit in screen causing highlight change.\n"
"\\ 00007 PLB 2/17/92 Added DOWN/MOVE/UP function.\n"
"\\ 00008 PLB 5/25/92 Add DELETE method.\n"
"\\ 00009 PLB 8/3/92 Use OB.IN.DICT? to avoid relative/absolute issue.\n"
"\\ 00010 PLB 10/1/92 Clean up titles on Mac\n"
"\n"
"ANEW TASK-SCREEN\n"
"\n"
"10 constant MAX_CUSTOM_SCREENS\n"
"OB.OBJLIST CUSTOM-SCREENS\n"
"\n"
"variable CG-CURRENT-SCREEN ( holds currently active screen )\n"
"variable CG-DRAWING-SCREEN ( true when drawing, allow sub-screens )\n"
"variable DEFAULT-SCREEN    ( holds screen to display on startup )\n"
"variable SCR-LAST-KEY  ( for sequential allocation )\n"
"ascii A 1- scr-last-key !\n"
"\n"
"\\ Make sure custom screens don't have garbage in them.\n"
": [FORGET]  ( -- )\n"
"    [forget]\n"
"    reset: custom-screens\n"
"    BEGIN manyleft: custom-screens\n"
"    WHILE next: custom-screens\n"
"        dup ob.in.dict? not  ( in dictionary )\n"
"        IF dup delete: custom-screens\n"
"           dup free: [] >newline\n"
"           name: [] .\"  removed from CUSTOM-SCREENS\" cr\n"
"        ELSE drop\n"
"        THEN\n"
"    REPEAT\n"
"\\ Make sure DEFAULT screen is still in dictionary.\n"
"    default-screen @ ?dup\n"
"    IF  ob.in.dict? 0=\n"
"        IF  default-screen off\n"
"            >newline .\" DEFAULT-SCREEN set to 0\" cr\n"
"        THEN\n"
"    THEN\n"
"\\ Make sure CURRENT screen is still in dictionary.\n"
"    cg-current-screen @ ?dup\n"
"    IF  ob.in.dict? 0=\n"
"        IF  cg-current-screen off\n"
"            >newline .\" CG-CURRENT-SCREEN set to 0\" cr\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
"\n"
"METHOD PUT.KEY:  METHOD GET.KEY:\n"
"\n"
":CLASS OB.SCREEN <SUPER OB.ELMNTS\n"
"    IV.LONG IV-SC-TITLE  ( pointer to title string )\n"
"    IV.LONG IV-SC-CTRL-HIT\n"
"    IV.LONG IV-SC-DRAW-CFA\n"
"    IV.LONG IV-SC-UNDRAW-CFA\n"
"\\\n"
"\\ provide functions for screen hits\n"
"    IV.LONG IV-SC-DOWN-CFA\n"
"    IV.LONG IV-SC-MOVE-CFA\n"
"    IV.LONG IV-SC-UP-CFA\n"
"    \n"
"    IV.BYTE IV-SC-KEY        ( character to use for Menu )\n"
"    IV.BYTE IV-SC-DRAWN\n"
"    IV.SHORT IV-SCR-LEFTX\n"
"    IV.SHORT IV-SCR-TOPY\n"
"\n"
":M INIT:\n"
"    init: super\n"
"\\    \" <HMSL>\" iv=> iv-sc-title  \\ VERY BAD IDEA in HForth 00010\n"
"    0 iv=> iv-sc-ctrl-hit\n"
"    0 iv=> iv-sc-draw-cfa\n"
"    0 iv=> iv-sc-undraw-cfa\n"
"\\\n"
"\\ Assign sequential characters.\n"
"    scr-last-key @ 1+ dup ascii Z >\n"
"    IF drop ascii A\n"
"    THEN dup scr-last-key !\n"
"    iv=> iv-sc-key\n"
";M\n"
"\n"
"\\ Methods for setting up a control, specify appearance, etc.\n"
":M PUT.XY.DC: ( leftx topy -- )\n"
"    iv=> iv-scr-topy    iv=> iv-scr-leftx\n"
";M\n"
"    \n"
":M GET.XY.DC: ( -- leftx topy )\n"
"    iv-scr-leftx iv-scr-topy\n"
";M\n"
"\n"
":M PUT.XY: ( leftx topy -- )\n"
"    scg.wc->dc\n"
"    iv=> iv-scr-topy    iv=> iv-scr-leftx\n"
";M\n"
"    \n"
":M GET.XY: ( -- leftx topy )\n"
"    iv-scr-leftx iv-scr-topy\n"
"    scg.dc->wc\n"
";M\n"
"\n"
":M NEW: ( #elmnts 3 -- , new: then add to custom-screens )\n"
"    dup 3 -\n"
"    IF \" NEW: screen\" \" must have 3 dimensions, eg. 10 3 NEW:\"\n"
"       er_warning ob.report.error\n"
"       drop 3\n"
"    THEN\n"
"    new: super\n"
"    self add: custom-screens\n"
";M\n"
"\n"
":M FREE: ( -- , delete from custom-screens )\n"
"    free: super\n"
"    self delete: custom-screens\n"
";M\n"
"\n"
":M DELETE: { control -- , to make it easy to delete controls }\n"
"    many: self 0\n"
"    ?DO\n"
"        i 0 ed.at: self control =\n"
"        IF\n"
"            i remove: self LEAVE\n"
"        THEN\n"
"    LOOP\n"
";M\n"
"\n"
":M PUT.KEY:  ( character -- , set char for menu )\n"
"    iv=> iv-sc-key\n"
";M\n"
"\n"
":M GET.KEY:  ( -- character )\n"
"    iv-sc-key\n"
";M\n"
"\n"
":M PUT.TITLE:  ( string-address -- , SET screen title )\n"
"    iv=> iv-sc-title\n"
";M\n"
":M GET.TITLE:  ( -- string-address, GET screen title )\n"
"    iv-sc-title dup 0=\n"
"    IF\n"
"        drop \" Untitled_Screen\"   \\ 00010\n"
"    THEN\n"
";M\n"
"\n"
":M PUT.DRAW.FUNCTION: ( cfa -- , called before draw )\n"
"    iv=> iv-sc-draw-cfa\n"
";M\n"
":M GET.DRAW.FUNCTION: ( -- cfa , called before draw )\n"
"    iv-sc-draw-cfa\n"
";M\n"
"\n"
":M PUT.UNDRAW.FUNCTION: ( cfa -- , called after undraw )\n"
"    iv=> iv-sc-undraw-cfa\n"
";M\n"
":M GET.UNDRAW.FUNCTION: ( -- cfa , called after undraw )\n"
"    iv-sc-undraw-cfa\n"
";M\n"
"\n"
":M PUT.DOWN.FUNCTION: ( cfa --  , cfa to execute when mouse down )\n"
"     iv=> iv-sc-down-cfa\n"
";M\n"
":M GET.DOWN.FUNCTION:  ( -- cfa )\n"
"    iv-sc-down-cfa\n"
";M\n"
":M PUT.MOVE.FUNCTION: ( cfa --  , cfa to execute when mouse moves )\n"
"     iv=> iv-sc-move-cfa\n"
";M\n"
":M GET.MOVE.FUNCTION:  ( -- cfa )\n"
"    iv-sc-move-cfa\n"
";M\n"
":M PUT.UP.FUNCTION: ( cfa --  , cfa to execute when mouse up )\n"
"     iv=> iv-sc-up-cfa\n"
";M\n"
":M GET.UP.FUNCTION:  ( -- cfa )\n"
"    iv-sc-up-cfa\n"
";M\n"
"\n"
":M PRINT.ELEMENT: ( e# -- , print name,x,y )\n"
"    get: self\n"
"    4 spaces rot name: []\n"
"    swap 8 .r 8 .r\n"
";M\n"
"\n"
":M FREEALL:  ( -- , free held control grids )\n"
"    many: self 0\n"
"    ?DO i 0 ed.at: self free: []\n"
"    LOOP\n"
";M\n"
"\n"
": (SCREEN.DRAW) ( -- )\n"
"    cg-drawing-screen @ 0= dup  ( leave flag for OFF at end )\n"
"    IF  cg-drawing-screen on     ( top level screen )\n"
"        gr.clear 1 gr.color!     ( don't clear if sub-screen )\n"
"    THEN\n"
"    service.tasks\n"
"\\\n"
"    0 scg.selnt   ( set normalization transform for CGs )\n"
"    iv-sc-draw-cfa ?dup\n"
"    IF\n"
"        0 exec.stack?\n"
"    THEN\n"
"    service.tasks\n"
"\\\n"
"    gr.height@\n"
"    gr_big_text gr.height!\n"
"    0 200 scg.move\n"
"    get.title: self gr.text\n"
"    gr.height!\n"
"\\\n"
"    many: self ?dup\n"
"    IF 0 DO\n"
"           i get: self  2dup + 0>  ( specify x,y ? )\n"
"           IF 2 pick put.xy: []  ( set x,y of control )\n"
"           ELSE 2drop\n"
"           THEN ( -- control|subscreen )\n"
"\\ add screen offsets for subscreen\n"
"           iv-scr-leftx  iv-scr-topy + 0>\n"
"           IF\n"
"              dup>r get.xy.dc: []\n"
"              >r iv-scr-leftx +  \\ add offsets\n"
"              r> iv-scr-topy +\n"
"              r@ put.xy.dc: [] \\ 00006\n"
"              r>\n"
"           THEN\n"
"           draw: []\n"
"           service.tasks\n"
"       LOOP\n"
"    ELSE \" DRAW: in OB.SCREEN\" \" No controls!\"\n"
"         er_return  er.report\n"
"    THEN\n"
"    IF  cg-drawing-screen off\n"
"        self cg-current-screen !\n"
"    THEN\n"
";\n"
"\n"
":M UNDRAW: ( -- , undraw controls and then do undraw.function )\n"
"\\ deactivate any active control 00002\n"
"    iv-sc-ctrl-hit ?dup\n"
"    IF\n"
"        0 swap put.active: []\n"
"        0 iv=> iv-sc-ctrl-hit\n"
"    THEN\n"
"\\\n"
"    gr-curwindow @\n"
"    IF  many: self 0\n"
"        ?DO\n"
"            i 0 ed.at: self undraw: []\n"
"        LOOP\n"
"        iv-sc-undraw-cfa ?dup\n"
"        IF\n"
"            0 exec.stack?\n"
"        THEN\n"
"        false iv=> iv-sc-drawn\n"
"    THEN\n"
"    0 cg-current-screen !\n"
"    0 cg-drawing-screen !\n"
";M\n"
"\n"
":M DRAW:   ( -- , Draw all the control objects )\n"
"    hmsl-window @\n"
"    IF hmsl.set.window\n"
"       cg-current-screen @ ?dup\n"
"       IF undraw: []\n"
"       THEN\n"
"       (screen.draw)\n"
"       true iv=> iv-sc-drawn\n"
"    ELSE \" DRAW: SCREEN\" \" No window to DRAW: in!\"\n"
"        er_fatal er.report\n"
"        cg-current-screen off\n"
"    THEN\n"
";M\n"
"\n"
":M ?DRAWN: ( -- flag , true if drawn )\n"
"    iv-sc-drawn\n"
";M\n"
"\n"
":M PUT.ACTIVE: ( active? -- , stub for embedded screens 00003 )\n"
"    drop\n"
";M\n"
":M GET.ACTIVE: (  -- active? , stub for embedded screens )\n"
"    FALSE\n"
";M\n"
"\n"
":M MOUSE.DOWN:   { x y | flag -- flag, process mouse down event, scan controls }\n"
"    false -> flag  \\ default to no hit 00004\n"
"    hmsl.set.window\n"
"    rnow\n"
"    many: self  0\n"
"    ?DO   ( Check for hits )\n"
"        x y i 0 ed.at: self mouse.down: []   ( mouse event trapped? )\n"
"        IF\n"
"            true -> flag  \\ yes we hit one\n"
"            i 0 ed.at: self\n"
"\\ change activation if ctrl changes\n"
"            dup iv-sc-ctrl-hit = not\n"
"            IF  iv-sc-ctrl-hit ?dup\n"
"                IF\n"
"                    FALSE swap put.active: []\n"
"                THEN\n"
"\\ activate new control\n"
"                TRUE over put.active: []\n"
"            THEN\n"
"            iv=> iv-sc-ctrl-hit         ( save for up )\n"
"            leave \n"
"        THEN\n"
"    LOOP\n"
"    flag dup not\n"
"    IF\n"
"        0 iv=> iv-sc-ctrl-hit\n"
"        iv-sc-down-cfa ?dup\n"
"        IF\n"
"            >r x y r> -2 exec.stack?\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M MOUSE.UP:     ( x y -- , process mouse up event )\n"
"    hmsl.set.window\n"
"    iv-sc-ctrl-hit  ?dup \n"
"    IF rnow mouse.up: []\n"
"    ELSE\n"
"        iv-sc-up-cfa ?dup\n"
"        IF\n"
"            -2 exec.stack?\n"
"        ELSE\n"
"            2drop\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M MOUSE.MOVE:     ( x y -- , process mouse movement )\n"
"    hmsl.set.window\n"
"    iv-sc-ctrl-hit  ?dup \n"
"    IF rnow mouse.move: []\n"
"    ELSE\n"
"        iv-sc-move-cfa ?dup\n"
"        IF\n"
"            -2 exec.stack?\n"
"        ELSE\n"
"            2drop\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
"\n"
":M KEY:     ( char -- , process keyboard input )\n"
"    hmsl.set.window\n"
"    iv-sc-ctrl-hit  ?dup \n"
"    IF rnow key: []\n"
"    ELSE drop\n"
"    THEN\n"
";M\n"
"\n"
":M DUMP.SOURCE:  ( -- , print code for screen layout )\n"
"    >newline \n"
"\\ Print width and height code for Controls\n"
"    many: self 0\n"
"    ?DO 4 spaces\n"
"       i 0 ed.at: self dup get.wh: [] swap . .\n"
"       .\"  put.wh: \" name: [] cr\n"
"    LOOP\n"
"\\ Print code to build screen.\n"
"    4 spaces max.elements: self . .\"  3 new: \" name: self cr\n"
"    many: self 0\n"
"    ?DO 4 spaces\n"
"       i get: self rot name: []    bl 22 emit-to-column\n"
"       swap 8 .r 8 .r\n"
"       .\"   add: \" name: self cr\n"
"    LOOP\n"
";M\n"
"\n"
":M PRINT:  ( -- )\n"
"    print: super\n"
"    .\" Command Key = \" iv-sc-key emit cr\n"
";M\n"
"\n"
";CLASS\n"
"\n"
": SC.CHECK.EVENT ( -- done? , Process one event from event queue. )\n"
"    false         ( default done flag )\n"
"    ev.get.event  ( get one event )\n"
"    CASE\n"
"        EV_NULL OF ENDOF\n"
"\n"
"        EV_MOUSE_DOWN OF cg-current-screen @ ?dup\n"
"                 IF ev.getxy rot mouse.down: [] drop THEN\n"
"             ENDOF\n"
"\n"
"        EV_MOUSE_UP OF cg-current-screen @ ?dup \n"
"                 IF ev.getxy rot mouse.up: [] THEN\n"
"             ENDOF\n"
"\n"
"        EV_MOUSE_MOVE OF cg-current-screen @ ?dup \n"
"                 IF ev.getxy rot mouse.move: [] THEN\n"
"             ENDOF\n"
"\n"
"         EV_KEY OF ev.get.key ?dup \\ 00001\n"
"                 IF cg-current-screen @ ?dup\n"
"                    IF key: []\n"
"                    ELSE drop\n"
"                    THEN\n"
"                 THEN\n"
"             ENDOF\n"
"             \n"
"        EV_CLOSE_WINDOW OF drop true .s\n"
"             ENDOF\n"
"    ENDCASE\n"
";\n"
"\n"
": SC.RESET ( -- )\n"
"    \" SC.RESET\" debug.type\n"
"    gr-curwindow @\n"
"    IF gr.clear\n"
"    THEN\n"
"    cg-drawing-screen off\n"
"    cg-current-screen off\n"
"    default-screen off\n"
";\n"
"\n"
": SC.INIT ( -- )\n"
"    \" SC.INIT -- OB.SCREEN initialization!\" debug.type\n"
"    sc.reset\n"
"    max_custom_screens new: custom-screens\n"
";\n"
": SC.TERM  ( -- )\n"
"    \" SC.TERM\" debug.type\n"
"    free: custom-screens\n"
";\n"
"\n"
": SYS.INIT sys.init sc.init ;\n"
": SYS.RESET sys.reset sc.reset ;\n"
": SYS.TERM sc.term sys.term ;\n"
"\n"
"true [IF]\n"
": SC.TEST  ( screen -- )\n"
"    dup draw: []\n"
"    stack.mark\n"
"    BEGIN\n"
"        stack.check\n"
"        sc.check.event\n"
"    UNTIL\n"
"    undraw: []\n"
";\n"
"\n"
"[THEN]\n"
"\n";

const char* screen_fth = (const char*) temp_binary_data_62;

//================== service_tasks.fth ==================
static const unsigned char temp_binary_data_63[] =
"\\ Support pseudo multi-tasking by calling a CFA\n"
"\\ from within words that take a long time.\n"
"\\ HMSL maintains the real time polling by calling this\n"
"\\ word from inside the interactive graphics words.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\n"
"ANEW TASK-SERVICE_TASKS\n"
"\n"
"U: TASKS-CFA  ( Set by later definitions )\n"
"U: SERVICING-TASKS\n"
"\n"
": SERVICE.TASKS  ( -- , Execute real time tasks )\n"
"\\ Avoid recursion by setting flag when going in.\n"
"    servicing-tasks @ 0=\n"
"    IF servicing-tasks on\n"
"       tasks-cfa @ execute\n"
"       servicing-tasks off\n"
"    THEN\n"
";\n"
"\n"
"U: TASKS-COUNT\n"
": SERVICE.TASKS/16  ( -- , Service tasks at 16th rate )\n"
"    tasks-count @ dup\n"
"    1+ 15 AND tasks-count !  0=\n"
"    IF service.tasks\n"
"    THEN\n"
";\n"
"\n"
": ST.INIT\n"
"    'c noop  tasks-cfa !  ( Default is do nothing )\n"
";\n"
"st.init\n"
"\n"
": SYS.INIT sys.init st.init ;\n"
": SYS.STATUS sys.status .\" SERVICE.TASK = \" tasks-cfa @ cfa. cr ;\n"
"\n";

const char* service_tasks_fth = (const char*) temp_binary_data_63;

//================== set_vectors.fth ==================
static const unsigned char temp_binary_data_64[] =
"\\ Set vectors for HMSL\n"
"\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\n"
"ANEW TASK-SET_VECTORS\n"
"\n"
"DEFER OLD.ABORT\n"
"\n"
": SET.ABORT  ( cfa -- , set abort function )\n"
"    what's old.abort ' quit -\n"
"    IF cr >name id. cr\n"
"       .\" SET.ABORT - Abort already set!\" cr\n"
"    ELSE\n"
"       what's abort is old.abort\n"
"       is abort\n"
"    THEN\n"
";\n"
"\n"
": RESET.ABORT ( -- , reset abort to original function )\n"
"    what's old.abort ' quit -\n"
"    IF  what's old.abort is abort\n"
"        ' quit is old.abort\n"
"    THEN\n"
";\n"
"\n"
"DEFER OLD.KEY\n"
"\n"
": SET.KEY  ( cfa -- , set KEY function )\n"
"    what's OLD.KEY ' quit -\n"
"    IF cr >name id. cr\n"
"       .\" SET.KEY - KEY already set!\" cr\n"
"    ELSE\n"
"       what's KEY is old.KEY\n"
"       is KEY\n"
"    THEN\n"
";\n"
"\n"
": RESET.KEY ( -- , reset KEY to original function )\n"
"    what's OLD.KEY ' quit -\n"
"    IF  what's old.KEY is KEY\n"
"        ' quit is old.key\n"
"\\    ELSE cr .\" RESET.KEY - KEY not set!\" cr\n"
"    THEN\n"
";\n"
"\n"
"DEFER OLD.EMIT\n"
"\n"
": SET.EMIT  ( cfa -- , set EMIT function )\n"
"    what's OLD.EMIT ' quit -\n"
"    IF cr >name id. cr\n"
"       .\" SET.EMIT - EMIT already set!\" cr\n"
"    ELSE\n"
"       what's EMIT is old.EMIT\n"
"       is EMIT\n"
"    THEN\n"
";\n"
"\n"
": RESET.EMIT ( -- , reset EMIT to original function )\n"
"    what's OLD.EMIT ' quit -\n"
"    IF  what's old.EMIT is EMIT\n"
"        ' quit is old.EMIT\n"
"\\    ELSE cr .\" RESET.EMIT - EMIT not set!\" cr\n"
"    THEN\n"
";\n"
"\n";

const char* set_vectors_fth = (const char*) temp_binary_data_64;

//================== shape.fth ==================
static const unsigned char temp_binary_data_65[] =
"\\ SHAPES are an abstract set of points in N dimensional space.\n"
"\\ They can be manipulated using special methods like TRANSPOSE:\n"
"\\ and can be edited using the shape editor.  They can also be\n"
"\\ converted to musical events by a user defined interpretation\n"
"\\ process.\n"
"\\\n"
"\\ Each dimension can have a name + average, min, max & sum.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 7/30/86 Added SERVICE.TASKS calls to DRAW.DIM:\n"
"\\ MOD: PLB 10/8/86 Changed PICK to PICK83\n"
"\\ MOD: PLB 10/13/86 Changed to IV.LONG system.\n"
"\\ MOD: PLB 11/5/86 Added TRANSPOSE:, INVERT: etc.\n"
"\\ MOD: PLB 11/8/86 Store names in separate array.\n"
"\\ MOD: PLB 11/8/86 Fix bogus names in GET.DIM.NAME: after FREE:\n"
"\\      Remove METRIC methods.\n"
"\\ MOD: PLB 12/26/86 Add DUMP.SOURCE: method.\n"
"\\ MOD: PLB 3/10/87 Fix bad PRINT: after FREE:\n"
"\\ MOD: PLB 5/13/87 Add calculation of mean.\n"
"\\ MOD: PLB 5/23/87 Changed AVE to MEAN\n"
"\\ MOD: PLB 9/3/87 Change REVERSE: to not use so much stack.\n"
"\\ MOD: PLB 9/10/87 Use internal instance objects for names,\n"
"\\      mins, maxes, etc.\n"
"\\      Add SCALE: and CLIP.ED.TO:\n"
"\\ MOD: PLB 10/7/87 Fix PRINT.STATS: stack leftovers.\n"
"\\ MOD: PLB 11/16/87 Add UPDATE: stub. Print stats before data.\n"
"\\      Don't print dim names in DUMP.SOURCE:\n"
"\\      Add SHAPE_CUSTOM_DATA\n"
"\\ MOD: PLB 12/15/87 Add SWAP: and SCRAMBLE:, thanks to\n"
"\\      Henry Lowengard for the scramble algorithm.\n"
"\\ MOD: PLB 5/14/89 Added SEARCH.BACK: , INTEGRATE.DIM: ,\n"
"\\      DIFFERENTIATE.DIM: and DIM.SUM:\n"
"\\      Converted CALC.DIM.STATS: to locals,  13.68 => 11.58 secs\n"
"\\      Converted REVERSE: to locals,  5.58 => 4.86\n"
"\\ MOD: PLB 9/26/89 Added PREFAB: , clipped DIFFERENTIATE to 0.\n"
"\\ MOD: PLB 10/3/89 Make NEXT: wrap around if at end.\n"
"\\ MOD: PLB 11/15/89 Add CLONE: method and ENSURE.ROOM\n"
"\\ MOD: PLB 3/12/90 Changed INTEGRATE.DIM: to INTEGRATE:\n"
"\\ MOD: PLB 7/18/90 Use late bound SELF NEW: [] in PREFAB:\n"
"\\ MOD: PLB 10/30/90 Fix crash in DIFFERENTIATE: if MANY=0\n"
"\\ MOD: PLB 6/19/91 Fix off by one error in DIFFERENTIATE:, added 1-\n"
"\\ MOD: PLB 5/7/92 Added methods for executing shapes directly.\n"
"\\ 00001 PLB 5/21/92 Add EDIT: method.\n"
"\\ 00002 PLB 7/26/93 Fixed DUMP.SOURCE.BODY:\n"
"\n"
"ANEW TASK-SHAPE\n"
"\n"
"0 value ON.TIME\n"
"\n"
"\\ These words can be used by other systems that want to\n"
"\\ know what's playing, eg. the Shape Editor.\n"
"\n"
"defer PL.NOW.PLAYING  ( elmnt# shape -- )\n"
"'c 2drop is pl.now.playing\n"
"defer PL.STOP.PLAYING  ( shape -- )\n"
"'c drop is pl.stop.playing\n"
"\n"
"\n"
"decimal\n"
"METHOD PUT.DIM.ATTR:     METHOD GET.DIM.ATTR:\n"
"METHOD GET.DIM.NAME:     METHOD PUT.DIM.NAME:\n"
"METHOD CALC.DIM.STATS:   METHOD GET.DIM.MEAN:\n"
"METHOD GET.DIM.MIN:      METHOD GET.DIM.MAX:\n"
"METHOD GET.DIM.SUM:\n"
"METHOD CALC.STATS:       METHOD PRINT.STATS:\n"
"METHOD DRAW.DIM:         METHOD SCRAMBLE:\n"
"METHOD RANDOMIZE:        METHOD REVERSE:\n"
"METHOD TRANSPOSE:        METHOD INVERT:\n"
"METHOD SCALE:            METHOD CLIP.ED.TO:\n"
"METHOD PUT.DIM.LIMITS:   METHOD GET.DIM.LIMITS:\n"
"METHOD UPDATE:           METHOD SWAP:\n"
"method SEARCH.BACK:\n"
"method INTEGRATE.DIM:\n"
"method DIFFERENTIATE.DIM:\n"
"method INTEGRATE:\n"
"method DIFFERENTIATE:\n"
"method CLONE:\n"
"\n"
"METHOD PUT.CHANNEL:\n"
"METHOD GET.CHANNEL:\n"
"METHOD PUT.MUTE:\n"
"METHOD GET.MUTE:\n"
"METHOD PUT.PLAY.FUNCTION:\n"
"METHOD GET.PLAY.FUNCTION:\n"
"METHOD GET.OFFSET:\n"
"METHOD PUT.OFFSET:\n"
"METHOD PUT.DUR.FUNCTION:\n"
"METHOD GET.DUR.FUNCTION:\n"
"METHOD PUT.DURATION:\n"
"METHOD GET.DURATION:\n"
"METHOD USE.RELATIVE.TIME:\n"
"METHOD USE.ABSOLUTE.TIME:\n"
"METHOD ?DONE:\n"
"\n"
": (DEFAULT.PLAY.FUNCTION) { elmnt# seqobj -- }\n"
"    get.channel: seqobj midi.channel!  \\ set channel\n"
"    elmnt# 1 ed.at: seqobj ?dup  \\ note \n"
"    IF\n"
"        get.offset: seqobj +     \\ transpose\n"
"        dimension: seqobj 2 >\n"
"        IF\n"
"            elmnt# 2 ed.at: seqobj   \\ velocity\n"
"        ELSE\n"
"            64\n"
"        THEN\n"
"        on.time                  \\ on time\n"
"        midi.noteon.for\n"
"    THEN\n"
";\n"
"\n"
"defer DEFAULT.PLAY.FUNCTION\n"
"\n"
"'c (default.play.function) is default.play.function\n"
"\n"
"\\ The attributes of a given dimension are stored in an\n"
"\\ instance array.\n"
"\\ Element number of attribute defined here.\n"
"0 constant SHAPE_MIN\n"
"1 constant SHAPE_MAX\n"
"2 constant SHAPE_SUM\n"
"3 constant SHAPE_NAME\n"
"4 constant SHAPE_LOLIM\n"
"5 constant SHAPE_HILIM\n"
"6 constant SHAPE_CUSTOM_DATA\n"
"7 constant SHAPE_#ATTRIBUTES\n"
"\n"
"\\ DEFINE OB.SHAPE CLASS \n"
":CLASS OB.SHAPE  <SUPER OB.MORPH\n"
"    OB.ELMNTS IV-SH-ATTRIBUTES\n"
"    IV.LONG  IV-SH-START-TIME   ( time player started )\n"
"    IV.LONG  IV-SH-DURATION   ( use this if >0 )\n"
"    IV.LONG  IV-SH-DUR-FUNCTION   ( use this if !0 )\n"
"    IV.LONG  IV-SH-OFFSET     ( transpose by this much )\n"
"    IV.LONG  IV-SH-CHANNEL    ( MIDI or other channel type )\n"
"    IV.LONG  IV-SH-PLAY-CFA\n"
"    IV.BYTE  IV-SH-IF-ABSOLUTE  ( true if use absolute time )\n"
"    IV.SHORT IV-SH-MUTE         ( if true, play function not executed )\n"
"\n"
":M DEFAULT:\n"
"    default: super\n"
"    1 iv=> iv-sh-channel\n"
"    -1 iv=> iv-sh-duration\n"
"    0 iv=> iv-sh-dur-function\n"
";M\n"
"\n"
":M FREE: ( -- , Free dim attributes too.)\n"
"    free: super\n"
"    free: iv-sh-attributes\n"
";M\n"
"\n"
":M PUT.DIM.ATTR:  ( value dim code -- , set attribute to value )\n"
"      swap ed.to: iv-sh-attributes\n"
";M\n"
":M GET.DIM.ATTR:  ( dim code -- value , get attr of dimension )\n"
"      swap ed.at: iv-sh-attributes\n"
";M\n"
"\n"
":M PUT.DIM.LIMITS: ( low high dim -- , set limits for dimension )\n"
"      tuck shape_hilim put.dim.attr: self\n"
"      shape_lolim put.dim.attr: self\n"
";M\n"
"\n"
":M GET.DIM.LIMITS: ( dim -- low high , fetch limits for dimension )\n"
"      dup shape_lolim get.dim.attr: self\n"
"      swap shape_hilim get.dim.attr: self\n"
";M\n"
"\n"
":M CLIP.ED.TO: ( value e# dim -- , clip before setting )\n"
"    >r swap r@ get.dim.limits: self clipto\n"
"    swap r> ed.to: self\n"
";M\n"
"\n"
":M ?NEW: ( maxindex #dimensions -- addr | 0, declare space )\n"
"    tuck ?new: super\n"
"    IF  shape_#attributes swap\n"
"        ?new: iv-sh-attributes\n"
"        IF  0 fill: iv-sh-attributes\n"
"\\ Set default limits.\n"
"            dimension: self 0\n"
"            ?DO 0 ho_max_int i put.dim.limits: self\n"
"            LOOP\n"
"\\ return address\n"
"            data.addr: self\n"
"        ELSE 0\n"
"        THEN\n"
"    ELSE 0\n"
"    THEN\n"
";M\n"
"\n"
":M NEW: ( #cells -- , abort if error )\n"
"    ?new: self <new:error>\n"
";M\n"
"\n"
":M GET.DIM.MIN: ( dim -- min , minimum value of dimension)\n"
"       shape_min get.dim.attr: self\n"
";M\n"
":M GET.DIM.MAX: ( dim -- max , maximum value of dimension)\n"
"       shape_max get.dim.attr: self\n"
";M\n"
"\n"
":M GET.DIM.MEAN: ( dim -- mean , average value of dimension)\n"
"       shape_sum get.dim.attr: self many: self /\n"
";M\n"
"\n"
":M GET.DIM.SUM: ( dim -- sum , sum of values of dimension)\n"
"       shape_sum get.dim.attr: self\n"
";M\n"
"\n"
"\n"
":M CALC.DIM.STATS:  { dim | smin smax ssum -- , calculate dimension stats }\n"
"    ho_max_int -> smin  ( set up)\n"
"    ho_min_int -> smax\n"
"    0 -> ssum\n"
"    many: self 0\n"
"    ?DO  i dim ed.at: self   ( get value )\n"
"        dup smin min -> smin\n"
"        dup smax max -> smax\n"
"        ssum + -> ssum\n"
"    LOOP\n"
"    smin dim shape_min  put.dim.attr: self\n"
"    smax dim shape_max  put.dim.attr: self\n"
"    ssum dim shape_sum  put.dim.attr: self\n"
";M\n"
"\n"
":M PUT.DIM.NAME:  ( $NAME DIM -- , place pointer in name )\n"
"    shape_name put.dim.attr: self\n"
";M\n"
"\n"
":M GET.DIM.NAME:  ( dim -- $name | 0, get name of dimension )\n"
"    shape_name get.dim.attr: self\n"
";M\n"
"\n"
":M CALC.STATS:  ( -- , calc all stats )\n"
"    dimension: self 0\n"
"    ?DO\n"
"        i calc.dim.stats: self\n"
"    LOOP\n"
";M\n"
"\n"
": SH.PRINT.STAT ( code $string -- , print statistic )\n"
"    $. dimension: self 0\n"
"    ?DO i over get.dim.attr: self 8 .r space\n"
"    LOOP drop cr\n"
";\n"
"\n"
":M PRINT.STATS: ( -- , print statistics )\n"
"    dimension: self\n"
"    IF  calc.stats: self\n"
"        shape_min   \" MIN:      \" sh.print.stat\n"
"        shape_max   \" MAX:      \" sh.print.stat\n"
"        shape_sum   \" SUM:      \" sh.print.stat\n"
"        shape_lolim \" LO LIMIT: \" sh.print.stat\n"
"        shape_hilim \" HI LIMIT: \" sh.print.stat\n"
"    THEN\n"
";M\n"
"\n"
":M PRINT: ( -- , print contents )\n"
"    cr name: self cr\n"
"    many: self\n"
"    IF  .\" -- Stats -----------------\" cr\n"
"        print.stats: self ?pause\n"
"        .\" -- Dimension Names -------\" cr\n"
"        dimension: self 0\n"
"        ?DO  ( print names of dimensions )\n"
"            i . space\n"
"            i get.dim.name: self ?dup\n"
"            IF   $.   ( print it)\n"
"            ELSE .\" ---\" ( mark space if not named)\n"
"            THEN cr ?pause\n"
"        LOOP cr\n"
"    THEN\n"
"    print: super\n"
";M\n"
"\n"
":M DRAW.DIM: ( start end dim -- , draw dimension )\n"
"    many: self 1 >\n"
"    IF swap rot ( -- d e s)\n"
"       dup 3 pick83 ed.at: self ( -- d e s y0 , first Y )\n"
"       over swap scg.move          ( move to first point )\n"
"       1+ swap 1+ swap ( -- d e+1 s+1 )\n"
"       ?DO   i over ed.at: self  ( draw to following points )\n"
"            i swap scg.draw\n"
"            service.tasks/16\n"
"       LOOP drop\n"
"    ELSE\n"
"        2drop drop\n"
"    THEN\n"
";M\n"
"\n"
"\\ Support for special music operations.\n"
"V: ZZZZDIM#  ( storage for dim to prevent stack dancing.)\n"
"\n"
": SH.RANDOMIZE ( min max elmnt# dim -- , set random value )\n"
"    >r >r swap wchoose r> r>\n"
"    clip.ed.to: self\n"
";\n"
"\n"
":M RANDOMIZE: ( min max start end dim -- , Put random values in.)\n"
"    zzzzdim# ! 1+ swap\n"
"    ?DO  zzzzdim# @ 0<\n"
"        IF dimension: self 0\n"
"            ?DO 2dup j i sh.randomize\n"
"            LOOP\n"
"        ELSE 2dup i zzzzdim# @ sh.randomize\n"
"        THEN\n"
"    LOOP\n"
"    2drop\n"
";M\n"
"\n"
":M TRANSPOSE: { val start endl dim -- , add value to shape }\n"
"    endl 1+ start\n"
"    ?DO val  i dim ed.at: self  +\n"
"       i dim clip.ed.to: self\n"
"    LOOP\n"
";M\n"
"\n"
":M SCALE: { numer denom start endl dim -- , scale values }\n"
"    endl 1+ start\n"
"    ?DO i dim ed.at: self\n"
"       numer denom */\n"
"       i dim clip.ed.to: self\n"
"    LOOP\n"
";M\n"
"\n"
":M INVERT: { val start endl dim -- , reflect values in shape }\n"
"    endl 1+ start\n"
"    ?DO val 2*  i dim ed.at: self\n"
"       -   i dim clip.ed.to: self\n"
"    LOOP\n"
";M\n"
"\n"
":M REVERSE: { start endl dim -- , Reverse order of values. }\n"
"    start endl 2sort -> endl -> start\n"
"    BEGIN\n"
"        start endl <\n"
"    WHILE\n"
"        dim 0<\n"
"        IF  start get: self endl get: self\n"
"            start put: self endl put: self\n"
"        ELSE\n"
"            start dim ed.at: self\n"
"            endl dim ed.at: self\n"
"            start dim ed.to: self\n"
"            endl dim ed.to: self\n"
"        THEN\n"
"        1 +-> start\n"
"       -1 +-> endl\n"
"    REPEAT\n"
";M\n"
"\n"
":M SWAP: { elm1 elm2 dim -- , swap elements }\n"
"    dim 0<\n"
"    IF  ( swap entire elements )\n"
"        elm1 get: self elm2 get: self ( -- v0s v1s )\n"
"        elm1 put: self elm2 put: self\n"
"    ELSE  ( swap single values )\n"
"        elm1 dim ed.at: self\n"
"        elm2 dim ed.at: self  ( -- v1 v2 )\n"
"        elm1 dim ed.to: self\n"
"        elm2 dim ed.to: self\n"
"    THEN\n"
";M\n"
"\n"
"\\ Choose one element from range, swap with bottom,\n"
"\\ then move bottom up.  Allow swap of one element.\n"
":M SCRAMBLE: ( start end dim -- , reorder )\n"
"    -rot     tuck  \n"
"    swap ( -- dim end end start )\n"
"    ?DO  dup 1+ i wchoose   ( pick element to swap )\n"
"        i 3 pick swap: self\n"
"    LOOP 2drop\n"
";M\n"
"\n"
":M UPDATE: ( -- , useful in later subclasses )\n"
";M\n"
"\n"
":M SEARCH.BACK:  { val dim | index -- index , next highest if false }\n"
"    many: self dup -> index 0\n"
"    ?DO  index 1- dup -> index\n"
"        dim ed.at: self val <=\n"
"        IF index 1+ -> index leave\n"
"        THEN\n"
"    LOOP\n"
"    index\n"
";M\n"
"\n"
":M INTEGRATE: { dim | sum -- sum , convert from delta to abs }\n"
"    0 -> sum\n"
"    many: self 0\n"
"    ?DO  i dim ed.at: self\n"
"        sum dup i dim ed.to: self\n"
"        + -> sum\n"
"    LOOP\n"
"    sum\n"
";M\n"
"\n"
":M DIFFERENTIATE: { sum dim -- sum , convert from abs to delta }\n"
"    many: self ?dup\n"
"    IF  1- 0\n"
"        ?DO i 1+ dim ed.at: self\n"
"            i dim ed.at: self  - ( -- v[i+1] v[i]  )\n"
"            sum over - -> sum   ( track sum )\n"
"            i dim ed.to: self\n"
"        LOOP\n"
"        sum  0 max many: self 1- dim ed.to: self\n"
"    THEN\n"
";M\n"
"\n"
":M DIFFERENTIATE.DIM: ( sum dim -- )\n"
"    .\" DIFFERENTIATE.DIM: is obsolete! Use DIFFERENTIATE:\" cr\n"
"    self DIFFERENTIATE: []\n"
";M\n"
"\n"
":M INTEGRATE.DIM: ( dim -- )\n"
"    .\" INTEGRATE.DIM: is obsolete! Use INTEGRATE:\" cr\n"
"    self INTEGRATE: []\n"
";M\n"
"\n"
":M PREFAB: { | smalldur lastnote -- , setup a default shape }\n"
"\\ Build a simple melody using a random walk.\n"
"\\ This data will be appropriate duration in dim0, pitch\n"
"\\ in dim1 and velocity in dim2.\n"
"    ticks/beat @ 4/ -> smalldur  ( use 1/4 beat per unit  )\n"
"    24 -> lastnote\n"
"\\\n"
"\\ Allocate space for 32 notes.\n"
"    32 3 self new: []\n"
"\\ Add 16 notes.\n"
"    16 0\n"
"    DO smalldur 2 choose IF 2* THEN  ( dur = 1 or 2 units )\n"
"\\ do a random walk for the dim 1\n"
"       lastnote 3 choose+/- + 1 20 clipto  ( note )\n"
"           dup -> lastnote\n"
"       60 choose 40 +    ( velocity )\n"
"       add: self\n"
"    LOOP\n"
";M\n"
"\n"
":M NEXT:  ( -- v1 v2 ... vn , return next element and inc pntr)\n"
"     current: self\n"
"\\\n"
"\\ Wrap around if we reach end.\n"
"     iv-current 1+ dup\n"
"     iv-many >\n"
"     IF drop 0\n"
"     THEN\n"
"     iv=> iv-current\n"
";M\n"
"\n"
":M CLONE: ( shape -- , make duplicate of self )\n"
"    >r  ( save on RS for ease )\n"
"    r@ max.elements: [] max.elements: self <  ( less room )\n"
"    r@ width: [] width: self = not OR\n"
"    r@ dimension: [] dimension: self = not OR\n"
"    IF ( shape )\n"
"        r@ free: []\n"
"        width: self r@ set.width: []\n"
"        many: self dimension: self r@ new: []\n"
"    THEN\n"
"    many: self r@ set.many: []\n"
"    0 0 many: self r@ copy: self\n"
"    r> dimension: self 0\n"
"    ?DO i get.dim.limits: self ( sh min max )\n"
"       i 3 pick put.dim.limits: []\n"
"       i get.dim.name: self  i 2 pick put.dim.name: []\n"
"    LOOP drop\n"
";M\n"
"\n"
"\n"
"\\ For shape execution ---------------------------------\n"
"\n"
":M PUT.DURATION: ( dur -- )\n"
"    iv=> iv-sh-duration\n"
";M\n"
":M GET.DURATION: ( -- dur )\n"
"    iv-sh-duration\n"
";M\n"
"\n"
":M PUT.DUR.FUNCTION: ( cfa -- , set duration function )\n"
"    iv=> iv-sh-dur-function\n"
";M\n"
":M GET.DUR.FUNCTION: ( -- cfa , fetch duration function )\n"
"    iv-sh-dur-function\n"
";M\n"
"\n"
":M PUT.MUTE: ( flag -- , set mute flag )\n"
"    iv=> iv-sh-mute\n"
";M\n"
":M GET.MUTE: ( -- flag , set mute flag )\n"
"    iv-sh-mute\n"
";M\n"
"\n"
":M USE.RELATIVE.TIME: ( -- , use time till next event )\n"
"    false iv=> iv-sh-if-absolute\n"
";M\n"
":M USE.ABSOLUTE.TIME: ( -- , use time since start: )\n"
"    true iv=> iv-sh-if-absolute\n"
";M\n"
"\n"
":M PUT.OFFSET: ( offset -- )\n"
"    iv=> iv-sh-offset\n"
";M\n"
":M GET.OFFSET: ( -- offset)\n"
"    iv-sh-offset\n"
";M\n"
"\n"
":M PUT.CHANNEL: ( channel -- )\n"
"    iv=> iv-sh-channel\n"
";M\n"
":M GET.CHANNEL: ( -- channel )\n"
"    iv-sh-channel\n"
";M\n"
"\n"
"\n"
":M PUT.PLAY.FUNCTION: ( cfa -- )\n"
"    iv=> iv-sh-play-cfa\n"
";M\n"
":M GET.PLAY.FUNCTION: ( -- cfa )\n"
"    iv-sh-play-cfa\n"
";M\n"
"\n"
":M CUSTOM.EXEC: ( -- time true | false , set start time )\n"
"    reset: self\n"
"    iv-repcount 0>\n"
"    many: self 0> AND\n"
"    IF\n"
"        false iv=> iv-col-done?\n"
"        iv-sh-if-absolute\n"
"        IF\n"
"            iv-time-next 0 at.self + iv=> iv-sh-start-time\n"
"        THEN\n"
"        self ao.post false\n"
"    ELSE\n"
"        iv-time-next true   ( let's not bother )\n"
"    THEN\n"
";M\n"
"\n"
":M TERMINATE: ( time -- )\n"
"    iv-if-active\n"
"    IF\n"
"        self ao.unpost\n"
"        morph.stop\n"
"    ELSE drop\n"
"    THEN\n"
"    self pl.stop.playing\n"
";M\n"
"\n"
":M ?DONE: ( -- , cleanup if the morph is done )\n"
"    col.do.repeat\n"
"    iv-repcount 0=\n"
"    IF iv-time-next terminate: self\n"
"    ELSE\n"
"       reset: self\n"
"       iv-time-next\n"
"        iv=> iv-sh-start-time \\ for absolute time\n"
"    THEN\n"
";M\n"
"\n"
": SEQ.GET.DURATION ( -- dur )\n"
"\\ Is there a DUR.FUNCTION ?\n"
"    iv-sh-dur-function ?dup\n"
"    IF >r iv-current self r>\n"
"        -1 exec.stack?  \\ should ( e# sh -- dur )\n"
"    ELSE\n"
"        iv-sh-duration dup 0<\n"
"        IF\n"
"            drop\n"
"            iv-current 0 ed.at: self\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
": SEQ.NEXT.ELMNT  ( -- , play next element )\n"
"\\ set IV-NEXT-TIME and ON.TIME\n"
"    iv-sh-if-absolute\n"
"    IF\n"
"        iv-current 1+ many: self <\n"
"        IF\n"
"            iv-current 1+ 0 ed.at: self\n"
"            iv-sh-start-time +\n"
"            dup iv-time-next - -> on.time\n"
"            iv=> iv-time-next\n"
"        THEN\n"
"    ELSE\n"
"        seq.get.duration\n"
"        dup -> on.time\n"
"        iv+> iv-time-next\n"
"    THEN\n"
"\\\n"
"    iv-current self\n"
"    iv-sh-mute not\n"
"    IF\n"
"        2dup\n"
"        iv-sh-play-cfa ?dup\n"
"        IF \n"
"            -2 exec.stack?\n"
"        ELSE\n"
"            default.play.function\n"
"        THEN\n"
"    THEN\n"
"    pl.now.playing   \\ track in shape editor %Q, remove from player\n"
"\\\n"
"    1 iv+> iv-current\n"
";\n"
"\n"
":M TASK: ( -- , play the next element )\n"
"    iv-time-next doitnow?\n"
"    IF\n"
"        iv-current many: self <\n"
"        IF seq.next.elmnt\n"
"        ELSE\n"
"            ?done: self\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M CLASS.NAME: ( -- $name )\n"
"    \" OB.SHAPE\"\n"
";M\n"
"\n"
"defer EDIT.SHAPE\n"
"' drop is edit.shape\n"
"\n"
":M EDIT: ( -- , edit using current editor ) \\ 00001\n"
"    self edit.shape\n"
";M\n"
"\n"
":M DUMP.SOURCE.BODY:\n"
"    dump.morph.body\n"
"\\\n"
"    iv-pntr \n"
"    IF\n"
"        tab max.elements: self . dimension: self .\n"
"        .\"  new: \" name: self cr\n"
"\\\n"
"        many: self 0\n"
"        ?DO\n"
"            i self dump.element: []\n"
"        LOOP\n"
"    THEN\n"
"    \n"
"    cr\n"
"    tab iv-sh-channel . .\" put.channel: \" name: self cr\n"
"    iv-sh-duration 0>\n"
"    IF\n"
"        tab iv-sh-duration . .\" put.duration: \" name: self cr\n"
"    THEN\n"
"\\\n"
"    iv-sh-dur-function\n"
"    IF\n"
"        tab .\" 'c \" iv-sh-dur-function cfa.\n"
"        .\" put.dur.function: \" name: self cr\n"
"    THEN\n"
"\\\n"
"    iv-sh-play-cfa\n"
"    IF\n"
"        tab .\" 'c \" iv-sh-play-cfa cfa.\n"
"        .\" put.play.function: \" name: self cr\n"
"    THEN\n"
"\\\n"
"    iv-sh-offset 0>\n"
"    IF\n"
"        tab iv-sh-offset . .\" put.offset: \" name: self cr\n"
"    THEN\n"
"\\\n"
"    iv-sh-if-absolute\n"
"    IF\n"
"        tab .\" use.absolute.time: \" name: self cr\n"
"    THEN\n"
";M\n"
"\n"
";CLASS\n"
"\n"
": ENSURE.ROOM ( shape -- , add room if needed )\n"
"    dup max.elements: []\n"
"    over many: [] =\n"
"    IF 64 swap extend: []\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
"if-testing @ [IF]\n"
"\n"
"OB.SHAPE SH1\n"
": FILL.SH1\n"
"    10 2 new: sh1\n"
"    8 0 DO\n"
"        i 10 * dup 1+ add: sh1\n"
"    LOOP\n"
";\n"
"\n"
"OB.SHAPE  SEQ1\n"
"\n"
": TSEQ.INIT\n"
"    32 3 new: seq1\n"
"    stuff{\n"
"        10 60 90\n"
"        10 67 60\n"
"        20 72 60\n"
"        10 64 60\n"
"        30  0 60\n"
"    }stuff: seq1\n"
"    1000 put.repeat: seq1\n"
"    clear: shape-holder\n"
"    seq1 add: shape-holder\n"
";\n"
"\n"
": TSEQ.INIT.ABS\n"
"    4 3 new: seq1\n"
"    stuff{\n"
"         0 60 90\n"
"        20 67 60\n"
"        40 72 60\n"
"        60 76 60\n"
"    }stuff: seq1\n"
"    use.absolute.time: seq1\n"
"    1000 put.repeat: seq1\n"
"    20 put.repeat.delay: seq1\n"
"    clear: shape-holder\n"
"    seq1 add: shape-holder\n"
";\n"
"\n"
": TSEQ.PLAY { elmnt# seqobj -- }\n"
"    get.channel: seqobj midi.channel!  \\ set channel\n"
"    elmnt# 1 ed.at: seqobj ?dup  \\ note \n"
"    IF\n"
"        get.offset: seqobj +     \\ transpose\n"
"        elmnt# 2 ed.at: seqobj   \\ velocity\n"
"        elmnt# 3 ed.at: seqobj   \\ on time\n"
"        midi.noteon.for\n"
"    THEN\n"
";\n"
"\n"
": TSEQ.INIT.ON\n"
"    32 4 new: seq1\n"
"    stuff{\n"
"         0 60 90 10\n"
"        20 67 60 3\n"
"        40 72 60 15\n"
"        60 76 60 20\n"
"        80 62 90 10\n"
"        80 69 60 10\n"
"        80 74 60 10\n"
"        100 80 60 30\n"
"    }stuff: seq1\n"
"    use.absolute.time: seq1\n"
"    1000 put.repeat: seq1\n"
"    20 put.repeat.delay: seq1\n"
"    'c tseq.play put.play.function: seq1\n"
"    clear: shape-holder\n"
"    seq1 add: shape-holder\n"
";\n"
"\n"
": TSEQ.TERM\n"
"    free: seq1\n"
";\n"
"\n"
"if.forgotten tseq.term\n"
"\n"
": TSEQ\n"
"    tseq.init\n"
"    seq1 ao.exec\n"
"    start: seq1\n"
";\n"
"[THEN]\n"
"\n"
"\n";

const char* shape_fth = (const char*) temp_binary_data_65;

//================== shape_editor.fth ==================
static const unsigned char temp_binary_data_66[] =
"\\ Shape Editor\n"
"\\\n"
"\\ Shapes, which includes waveforms, can be edited with this\n"
"\\ screen.  A special class of control grid, an OB.CTRL.EDIT\n"
"\\ is defined that can do operations on a contained shape.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 - David Rosenboom, Larry Polansky, Phil Burk.\n"
"\\\n"
"\\ MOD: 11/5/86 PLB Add range selection, transpose, cut, copy, paste.\n"
"\\ MOD: 11/6/86 PLB Improve ranging and updating, add random mode.\n"
"\\ MOD: 11/21/86 PLB Don't calc.stats for bytewide, draw once after\n"
"\\      randomize.\n"
"\\ MOD: PLB 12/6/86 Change ' to 'c\n"
"\\ MOD: PLB 12/9/86 Fix text overdraw, and INIT: SE-PLAYER in SE.INIT\n"
"\\ MOD: PLB 12/15/86 Remove special code for overdraw, not needed now.\n"
"\\ MOD: PLB 3/5/87 Stay on dimension when switching shapes.\n"
"\\ MOD: PLB 3/6/87 Select values, start and end, are now before point.\n"
"\\ MOD: PLB 3/10/87 Don't PASTE if no CUTS done.\n"
"\\          Add SE.STARTUP\n"
"\\ MOD: PLB 7/8/87 Extend SE-MODECG\n"
"\\ MOD: PLB 9/20/87 Use low level COPY: to speed up SE.CUT and SE.PASTE\n"
"\\ MOD: PLB 10/7/87 Show new position if UP or DOWN of single point.\n"
"\\ MOD: PLB 10/22/87 Show new position of first point in UP or DOWN.\n"
"\\ MOD: PLB 10/26/87 Set SE-IF-ZOOMED to FALSE in SE.INIT, min to 8.\n"
"\\ MOD: PLB 12/15/87 Implemented SCRAMBLE button.\n"
"\\ MOD: PLB 4/27/88 Changed SE.SET.SHAPE and SE.SETUP so HMSL.EDIT.PLAY\n"
"\\          edits the specified shape.\n"
"\\ MOD: PLB 9/28/88 Converted to new control grids.\n"
"\\ MOD: PLB 3/28/89 Newer control grid design.\n"
"\\ MOD: PLB 10/3/89 Add player tracking & SE.UPDATE.SHAPE\n"
"\\ MOD: PLB 10/29/89 Make SE.STARTUP the DRAW function.\n"
"\\ MOD: PLB 12/13/89 Converted to v/p system.\n"
"\\ MOD: PLB 4/9/91 Rearranged screen, fixed hit range.\n"
"\\ MOD: PLB 4/18/91 Made shape select immediate, just redraw box.\n"
"\\ MOD: PLB 5/20/91 FREE: SHAPE-1 and SE-PLAYER\n"
"\\ MOD: PLB 6/24/91 Fix dimension selection in PUT.OBJECT:  c/MAX/MIN/\n"
"\\ 00001 PLB 10/1/91 Make additions to SHAPE-HOLDER immediately accesible\n"
"\\ 00002 PLB 4/27/92 Move Shape Holder validation to H:MORPH_LISTS\n"
"\n"
"ANEW TASK-SHAPE_EDITOR\n"
"\n"
"V: SE-MODE\n"
"V: SE-QUIT\n"
"\n"
"\\ Objects used in support of shape editor.\n"
"OB.PLAYER SE-PLAYER   \\ Used for Playing Shape\n"
"\n"
"OB.SCREEN SE-SCREEN\n"
"\n"
"0 constant SE_CTRL_TNR\n"
"5 constant SE_EDIT_TNR\n"
"\n"
"\\ Mode control --------------------------------------------\n"
"0 constant SE_INSERT\n"
"1 constant SE_DELETE\n"
"2 constant SE_REPLACE\n"
"3 constant SE_SELECT\n"
"4 constant SE_RUBBER\n"
"5 constant SE_TRACE    \\ draw\n"
"6 constant SE_SET_Y\n"
"7 constant SE_RANDOMIZE\n"
"\n"
"OB.RADIO.GRID SE-MODECG\n"
"\n"
": SE.SETMODE ( value mode -- , Set mode to based on last hit )\n"
"    se-mode ! drop\n"
";\n"
"\n"
": BUILD.SE-MODE ( -- )\n"
"    2 4 new: se-modecg\n"
"    se_insert se-mode !\n"
"    530 280 put.wh: se-modecg\n"
"    \" Set Mode\" put.title: se-modecg\n"
"    'c se.setmode put.down.function: se-modecg\n"
"    stuff{ \" Insert\"  \" Delete\"  \" Replace\"\n"
"      \" Select\"  \" Rubber\"  \" Draw\"\n"
"      \" Set Y \"  \" Random\"\n"
"    }stuff.text: se-modecg\n"
";\n"
"\n"
"\\ Editor Control Grid ---------------------------------\n"
"\\\n"
"\\ This Ctrl provides methods for editing morphs.\n"
"METHOD PUT.DIM:         METHOD GET.DIM:\n"
"METHOD PUT.SELECT:      METHOD GET.SELECT:\n"
"METHOD PUT.RANGE:       METHOD GET.RANGE:\n"
"METHOD GET.YMARK:\n"
"METHOD UPDATE.DRAW:     METHOD TELL.XY:\n"
"METHOD PUT.OBJECT:      METHOD GET.OBJECT:\n"
"METHOD DRAW.DATA:\n"
"\\ Methods for showing played element.\n"
"METHOD NOW.PLAYING:     METHOD STOP.PLAYING:\n"
"\n"
":CLASS OB.CTRL.EDIT <SUPER OB.CONTROL\n"
"    IV.LONG IV-EDIT-DIM   ( currently edited dimension )\n"
"    IV.LONG IV-EDIT-TNR   ( edit transformation )\n"
"    IV.LONG IV-EDIT-START ( start of select )\n"
"    IV.LONG IV-EDIT-END   ( end of select )\n"
"    IV.LONG IV-EDIT-LEFT  ( left index of display range )\n"
"    IV.LONG IV-EDIT-RIGHT ( right index of display range )\n"
"    IV.LONG IV-EDIT-YMARK ( mark vertical value )\n"
"    IV.LONG IV-EDIT-X     ( Position of mouse hit. )\n"
"    IV.LONG IV-EDIT-Y\n"
"    IV.LONG IV-EDIT-TOP   ( Value at top of box. )\n"
"    IV.LONG IV-EDIT-BOT\n"
"    IV.LONG IV-EDIT-WIDTH/2 ( in DC, half width of element )\n"
"    IV.LONG IV-EDIT-HEIGHT/2\n"
"    IV.LONG IV-EDIT-SHAPE\n"
"    IV.LONG IV-EDIT-FIRST-ELM\n"
"    IV.LONG IV-EDIT-FIRST-VAL\n"
"    IV.LONG IV-EDIT-LAST-ELM\n"
"    IV.LONG IV-EDIT-LAST-VAL\n"
"    IV.LONG IV-EDIT-PLAYING  ( -1 if none displayed, or cur elmnt )\n"
"\n"
":M INIT:   ( -- , Initialize )\n"
"    init: super\n"
"    se_edit_tnr iv=> iv-edit-tnr\n"
"    -1 iv=> iv-edit-playing\n"
";M\n"
"\n"
":M PUT.OBJECT: ( rel_morph_addr -- , set shape to edit )\n"
"    dup iv=> iv-edit-shape\n"
"    dup max.elements: [] 1- iv=> iv-edit-right   ( set bounds )\n"
"    dimension: [] 1- iv-edit-dim MIN iv=> iv-edit-dim\n"
"    0 iv=> iv-edit-left\n"
"    0 iv=> iv-edit-start\n"
"    0 iv=> iv-edit-end\n"
";M\n"
"\n"
":M GET.OBJECT: ( -- shape )\n"
"    iv-edit-shape\n"
";M\n"
"\n"
":M PUT.DIM: ( dim -- , set dim of morph to edit )\n"
"    iv=> iv-edit-dim\n"
";M\n"
":M GET.DIM: ( -- dim , Get dim of morph to edit )\n"
"    iv-edit-dim \n"
";M\n"
"\n"
":M PUT.RANGE: ( left right -- , set display range )\n"
"    2sort\n"
"    iv-edit-shape max.elements: [] 1- MIN iv=> iv-edit-right\n"
"    0 MAX iv=> iv-edit-left\n"
";M\n"
"\n"
":M GET.RANGE: ( -- left right , fetch display range )\n"
"     iv-edit-left iv-edit-right\n"
";M\n"
"\n"
":M PUT.SELECT: ( start end -- , set selection range )\n"
"    2sort\n"
"\\  Clip to points in shape.\n"
"    iv-edit-shape ?dup\n"
"    IF many: [] >r\n"
"    ELSE 0 >r\n"
"    THEN\n"
"    0 max r@ min iv=> iv-edit-end\n"
"    0 max r> min iv=> iv-edit-start\n"
";M\n"
"\n"
":M GET.SELECT: ( -- start end , fetch selection range )\n"
"     iv-edit-start iv-edit-end\n"
";M\n"
"\n"
":M GET.YMARK: ( -- ymark , Fetch Y mark for inversion, etc. )\n"
"    iv-edit-ymark\n"
";M\n"
"\n"
":M UPDATE:  ( -- , update all draw parameters based on current state)\n"
"    iv-edit-left  iv-edit-right   ( xmin xmax )\n"
"    iv-edit-shape width: [] 1 > ( byte OR bigger )\n"
"    IF\n"
"        iv-edit-shape   dup many: []  ( any data? )\n"
"        IF\n"
"            get.dim: self swap calc.dim.stats: []\n"
"\\ invert Y axis for more normal editing\n"
"            get.dim: self  iv-edit-shape get.dim.max: [] \n"
"            dup 2/ + ( *3/2 )  8 max  ( maximum Y )\n"
"            get.dim: self  iv-edit-shape get.dim.min: []\n"
"            dup 0<\n"
"            IF   dup 2/ -4 min +\n"
"            ELSE 2/  8 max  8 -\n"
"            THEN   ( minimum Y )\n"
"        ELSE\n"
"            drop 64 0   ( default range when no data yet in shape )\n"
"        THEN\n"
"\\ Use complete range for byte wide shape for fast waveform editing.\n"
"    ELSE 128 -128\n"
"    THEN  ( -- topy boty )\n"
"    2dup iv=> iv-edit-bot iv=> iv-edit-top\n"
"    2dup 2sort iv-edit-ymark ( keep mark in range )\n"
"    -rot clipto iv=> iv-edit-ymark\n"
"    se_edit_tnr scg.swn    ( set window for data )\n"
"\n"
"\\ set viewport for data\n"
"\\ add one to avoid select range wiping out left edge\n"
"    iv-cg-leftx dup iv-cg-width +\n"
"    iv-cg-topy dup iv-cg-height +\n"
"    se_edit_tnr scg.svp\n"
"    se_edit_tnr scg.selnt  ( update calculation )\n"
"    0 scg.selnt  ( reset transform )\n"
";M\n"
"\n"
"\n"
": SE.CALC.SXY  ( wx wy -- dx dy , calculate device x,y for select)\n"
"    >r iv-edit-left iv-edit-right clipto\n"
"    r> scg.wc->dc   ( -- xd1 yd1 )\n"
";\n"
"\n"
": SE.DRAW.SELECT ( -- , highlight range )\n"
"    \\ Is the selected range visible?\n"
"    iv-edit-start iv-edit-left iv-edit-right within?\n"
"    iv-edit-end   iv-edit-left iv-edit-right within? OR\n"
"    IF  iv-edit-start iv-edit-top se.calc.sxy\n"
"        iv-edit-start iv-edit-left >\n"
"        IF swap iv-edit-width/2 - swap\n"
"        THEN\n"
"        iv-edit-end iv-edit-bot se.calc.sxy\n"
"        iv-edit-end iv-edit-left 1+ iv-edit-right within?\n"
"        IF swap iv-edit-width/2 - swap\n"
"        THEN\n"
"\\ Sort X and Ys  ( x1 y1 x2 y2 )\n"
"        rot 2sort >r >r   ( Ys )\n"
"        2sort r> swap\n"
"        1+ \\ make it wider so it is visible\n"
"        r>  ( Xs )\n"
"        gr.highlight\n"
"    THEN\n"
";\n"
"\n"
": SE.DRAW.PLAYING ( -- , play currently playing element )\n"
"    iv-edit-playing iv-edit-left iv-edit-right within?\n"
"    IF gr.color@\n"
"       gr_cyan gr.color!\n"
"       iv-edit-playing iv-edit-top scg.move\n"
"       iv-edit-playing iv-edit-bot scg.draw\n"
"       gr.color!\n"
"    THEN\n"
";\n"
"\n"
"\n"
": SE.DRAW.SHAPE ( -- )\n"
"    iv-edit-shape\n"
"    IF  iv-edit-left \n"
"        iv-edit-right    iv-edit-shape  many: [] 1-  min \n"
"        iv-edit-dim \n"
"        iv-edit-shape draw.dim: [] ( draw shape )\n"
"    THEN\n"
";\n"
"\n"
": SE.CLEAR.RECT ( -- , clear background behind the lines )\n"
"    se_edit_tnr scg.selnt\n"
"    gr.color@\n"
"    0 gr.color!\n"
"    -1 get.rect: self gr.rect    ( blank out rect )\n"
"    gr.color!\n"
";\n"
"\n"
": SE.DRAW.LINES ( -- , clear and redraw data )\n"
"    service.tasks\n"
"    se_edit_tnr scg.selnt\n"
"    se.draw.shape\n"
"    se.draw.playing\n"
"    0 scg.selnt\n"
";\n"
"\n"
": SE.DRAW.YMARK ( -- , Draw horizontal Y level )\n"
"    gr.color@ 2 gr.color!\n"
"    iv-edit-right iv-edit-ymark scg.move\n"
"    iv-edit-left  iv-edit-ymark scg.draw\n"
"    gr.color!\n"
";\n"
"\n"
": SE.DRAW.TRIM ( -- , draw select ed, ymark, axes, etc.)\n"
"\\ Get half cell sizes for x,y adjustments\n"
"    se_edit_tnr scg.showvp\n"
"    se_edit_tnr scg.selnt\n"
"    1 1 scg.delta.wc->dc\n"
"    2/ iv=> iv-edit-height/2\n"
"    2/ iv=> iv-edit-width/2\n"
"    se.draw.select   ( highlight selected range )\n"
"    se.draw.ymark\n"
"    0 scg.selnt\n"
";\n"
"\n"
":M DRAW.DATA:   ( -- , Draw control and morph )\n"
"    service.tasks\n"
"    se.clear.rect\n"
"    se.draw.trim\n"
"    se.draw.lines\n"
";M\n"
"\n"
":M NOW.PLAYING:  ( elmnt# shape -- )\n"
"    iv-edit-shape =\n"
"    IF  iv=> iv-edit-playing\n"
"        draw.data: self\n"
"    ELSE drop\n"
"    THEN\n"
";M\n"
"\n"
":M STOP.PLAYING: ( shape -- , turn off display if right shape )\n"
"    iv-edit-shape =   iv-edit-playing -1 > and\n"
"    IF  -1 iv=> iv-edit-playing\n"
"        draw.data: self\n"
"    THEN\n"
";M\n"
"\n"
": SE.TELL.SHAPE ( -- )\n"
"    iv-cg-leftx iv-cg-topy iv-cg-height +\n"
"    gr.height@ + 2+ gr.move\n"
"    \"         \" gr.text   ( move over)\n"
"    iv-edit-shape dup get.name: [] gr.text  ( Shape name)\n"
"    \"    \" gr.text\n"
"    iv-edit-dim swap get.dim.name: [] dup 0=\n"
"    IF drop \" ----\"\n"
"    THEN gr.text  ( Dimension name)\n"
"    \"             \" gr.text\n"
";\n"
"\n"
":M DRAW:   ( -- , Draw axes, etc. )\n"
"    update: self\n"
"    draw: super\n"
"    se_edit_tnr  scg.selnt\n"
"    se.tell.shape\n"
"    scg.draw.axes\n"
"    draw.data: self\n"
"    0 scg.selnt\n"
";M\n"
"\n"
":M UPDATE.DRAW:  ( -- , Update only if really needed. )\n"
"    iv-edit-shape width: [] 1 > ( byte OR bigger )\n"
"    IF   ( only check if wider than byte )\n"
"        get.dim: self iv-edit-shape\n"
"        2dup calc.dim.stats: []\n"
"        2dup get.dim.max: [] >r\n"
"        get.dim.min: [] r>       ( -- dim.min dim.max )\n"
"\\ Check for data in range.\n"
"        iv-edit-bot iv-edit-top within?\n"
"        >r  iv-edit-bot iv-edit-top within?  r> AND NOT\n"
"        IF draw: self\n"
"        ELSE draw.data: self\n"
"        THEN\n"
"    ELSE draw.data: self\n"
"    THEN\n"
";M\n"
"\n"
":M TELL.XY:   ( value elmnt# -- , display x,y at top )\n"
"    iv-cg-leftx 4+ iv-cg-topy 4-\n"
"    \" X = \"   gr.xytext gr.number\n"
"    \" , Y = \" gr.text   gr.number\n"
"    \"      \"  gr.text ( blank out rest )\n"
";M\n"
"\n"
": SE.CLIP.SELECT ( -- , clip select to shape limits)\n"
"    get.select: self    put.select: self\n"
";\n"
"\n"
": SE.INSERT ( value elmnt# -- , Insert a value into shape )\n"
"    1 iv-edit-shape check.over: []\n"
"    IF 2drop bell\n"
"    ELSE  \n"
"        iv-edit-shape many: []\n"
"        IF ( make room for one more )\n"
"            dup 1- 0 max 1 iv-edit-shape  stretch: []\n"
"        ELSE ( make one 0 element )\n"
"            1 iv-edit-shape set.many: []\n"
"            0 iv-edit-shape fill: []\n"
"        THEN \n"
"        get.dim: self iv-edit-shape clip.ed.to: []\n"
"    THEN\n"
"    iv-edit-shape update: []\n"
";\n"
"\n"
": SE.RANDOMIZE ( value -- ,generate random values, ymark->value)\n"
"    iv-edit-ymark 2sort   ( data range )\n"
"    iv-edit-start iv-edit-end ( index range )\n"
"    2dup <\n"
"    IF  1- iv-edit-dim  iv-edit-shape   randomize: []\n"
"    ELSE 2drop 2drop\n"
"    THEN\n"
";\n"
"\n"
": SE.EXEC.DOWN  ( value elmnt# -- , Perform action based on mode )\n"
"    service.tasks\n"
"    2dup tell.xy: self\n"
"    se-mode @\n"
"    CASE  ( -- value elmnt# )\n"
"        SE_INSERT OF\n"
"            se.insert se.clip.select\n"
"            draw.data: self\n"
"        ENDOF\n"
"        SE_DELETE OF\n"
"            iv-edit-shape remove: []   drop se.clip.select\n"
"            draw.data: self\n"
"            iv-edit-shape update: []\n"
"        ENDOF\n"
"        SE_REPLACE OF \n"
"            2drop ev.track.on\n"
"        ENDOF\n"
"        SE_TRACE OF \n"
"            get.dim: self iv-edit-shape clip.ed.to: []\n"
"            draw.data: self\n"
"            ev.track.on\n"
"        ENDOF\n"
"        SE_SELECT OF  ( pick first point )\n"
"            se_edit_tnr scg.selnt\n"
"            dup put.select: self drop\n"
"            ev.track.on\n"
"            draw.data: self\n"
"            0 scg.selnt\n"
"        ENDOF\n"
"        SE_SET_Y OF\n"
"            2drop ev.track.on\n"
"        ENDOF\n"
"        SE_RANDOMIZE OF\n"
"            drop se.randomize\n"
"            draw.data: self\n"
"        ENDOF\n"
"        SE_RUBBER OF\n"
"            ev.track.on 2drop\n"
"        ENDOF\n"
"    ENDCASE\n"
";\n"
"\n"
": SE.EXEC.MOVE ( value elmnt -- )\n"
"    2dup tell.xy: self\n"
"    se-mode @\n"
"    CASE\n"
"        SE_TRACE OF\n"
"\\ Add to end if traced past.\n"
"            dup iv-edit-shape many: [] =\n"
"            IF ( make room for one more if past end )\n"
"              dup 1- 0 max 1 iv-edit-shape  stretch: []\n"
"              iv-edit-shape update: []\n"
"              get.dim: self iv-edit-shape clip.ed.to: []\n"
"            ELSE ( -- v e )\n"
"\\ Interpolate values if elements skipped.\n"
"              dup iv-edit-last-elm - abs 1 >\n"
"              IF  ( -- v e , more than one element traced )\n"
"                tuck swap\n"
"                iv-edit-last-elm iv-edit-last-val  set.interp\n"
"                ( -- e ) iv-edit-last-elm -2sort >r 1+ r>\n"
"                DO i interp  i\n"
"                   get.dim: self iv-edit-shape clip.ed.to: []\n"
"                LOOP\n"
"              ELSE ( -- v e )\n"
"                get.dim: self iv-edit-shape clip.ed.to: []\n"
"              THEN\n"
"            THEN\n"
"            draw.data: self\n"
"        ENDOF\n"
"        SE_RUBBER OF\n"
"            gr.color@ >r\n"
"            draw.data: self\n"
"            gr_green gr.color!\n"
"            se_edit_tnr scg.selnt\n"
"            iv-edit-first-elm iv-edit-first-val scg.move\n"
"            ( -- value elmnt )swap scg.draw\n"
"            r> gr.color!\n"
"        ENDOF\n"
"        2drop  \n"
"    ENDCASE\n"
";\n"
"\n"
": SE.EXEC.UP ( value elmnt -- )\n"
"    se-mode @\n"
"    CASE\n"
"        SE_REPLACE OF \n"
"            get.dim: self iv-edit-shape clip.ed.to: []\n"
"            update.draw: self\n"
"        ENDOF\n"
"        SE_RUBBER OF\n"
"            2drop\n"
"            iv-edit-first-elm iv-edit-last-elm -\n"
"            IF  iv-edit-first-elm iv-edit-first-val\n"
"                iv-edit-last-elm iv-edit-last-val  set.interp\n"
"                iv-edit-first-elm iv-edit-last-elm -2sort >r 1+ r>\n"
"                DO i interp i\n"
"                   get.dim: self iv-edit-shape clip.ed.to: []\n"
"                LOOP\n"
"                draw.data: self\n"
"            THEN\n"
"        ENDOF\n"
"        SE_SET_Y OF\n"
"            drop iv=> iv-edit-ymark\n"
"            draw.data: self\n"
"        ENDOF\n"
"        SE_TRACE OF\n"
"            2drop\n"
"            draw.data: self\n"
"        ENDOF\n"
"        2drop\n"
"    ENDCASE\n"
"    ev.track.off\n"
";\n"
"\n"
": SE.XY>VAL.ELM  ( x y -- value elmnt , unclipped)\n"
"    service.tasks\n"
"    iv-edit-shape 0= IF\n"
"       \" EXECUTE: OB.CTRL.EDIT\" \" NO shape.\" er_fatal er.report\n"
"    THEN\n"
"\n"
"    se_edit_tnr scg.selnt\n"
"    scg.dc->wc  SWAP ( val elmnt# )\n"
"    0 scg.selnt\n"
";\n"
"\n"
": SE.CLIP.ELM ( elemnt -- elemnt' , clipped to current range )\n"
"    0 iv-edit-shape  many: []  clipto   ( clip to max+1 )\n"
"    iv-edit-shape max.elements: [] 1- min  ( clip to limit )\n"
";\n"
"\n"
": SE.GET.VAL.ELM  ( x y -- value elmnt , clipped )\n"
"    se.xy>val.elm\n"
"    se.clip.elm\n"
";\n"
"\n"
":M EXEC.DOWN: ( -- , perform current edit mode on morph)\n"
"    iv-edit-x iv-edit-y\n"
"    se.get.val.elm\n"
"    2dup iv=> iv-edit-last-elm iv=> iv-edit-last-val\n"
"    2dup iv=> iv-edit-first-elm iv=> iv-edit-first-val\n"
"    se.exec.down\n"
"    0 scg.selnt\n"
";M\n"
"\n"
":M MOUSE.MOVE: ( x y -- , perform current edit mode on morph)\n"
"    se-mode @ SE_SELECT =\n"
"    IF\n"
"        se.xy>val.elm 2dup\n"
"\\ same as before?\n"
"        dup iv-edit-last-elm =\n"
"        2 pick iv-edit-last-val = AND not\n"
"        IF  \n"
"            se_edit_tnr scg.selnt\n"
"            iv-edit-first-elm 2sort\n"
"            put.select: self\n"
"            draw.data: self\n"
"            drop \\ don't need value\n"
"        ELSE 2drop\n"
"        THEN\n"
"        iv=> iv-edit-last-elm iv=> iv-edit-last-val\n"
"        0 scg.selnt\n"
"    ELSE\n"
"        2dup ?hit: self\n"
"        IF  se.get.val.elm 2dup\n"
"\\ same as before?\n"
"            dup iv-edit-last-elm =\n"
"            2 pick iv-edit-last-val = AND not\n"
"            IF  se.exec.move\n"
"            ELSE 2drop\n"
"            THEN\n"
"            iv=> iv-edit-last-elm iv=> iv-edit-last-val\n"
"            0 scg.selnt\n"
"        ELSE 2drop\n"
"        THEN\n"
"    THEN\n"
";M\n"
"\n"
":M MOUSE.UP: ( x y -- , perform current edit mode on morph)\n"
"    se.get.val.elm\n"
"    se.exec.up\n"
"    0 scg.selnt\n"
";M\n"
"    \n"
":M MOUSE.DOWN: (  x y -- trapped? , process mouse DOWN event )\n"
"    2dup  iv=> iv-edit-y  iv=> iv-edit-x\n"
"    mouse.down: super\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\\ Declare edit objects -------------------------------------\n"
"OB.CTRL.EDIT SE-EDITBOX\n"
"\n"
"\\ Support words for Shape Edit Operations\n"
": SE.GET.SHAPE ( -- shape , currently being edited )\n"
"    get.object: se-editbox\n"
";\n"
": SE.GET.SELECT ( -- lo hi , elment range selected )\n"
"    get.select: se-editbox\n"
";\n"
": SE.GET.DIM ( -- dimension , currently shown )\n"
"    get.dim: se-editbox\n"
";\n"
": SE.GET.YMARK ( -- ymark_value , as used by invert and randomize )\n"
"    get.ymark: se-editbox\n"
";\n"
": SE.UPDATE.DRAW ( -- , redraw shape after change )\n"
"    update.draw: se-editbox\n"
";\n"
"\n"
"\\ Functions for deferred showing of what a player is playing.\n"
"\n"
": SE.NOW.PLAYING  ( elmnt# shape -- )\n"
"    cg-current-screen @ se-screen =\n"
"    servicing-tasks @ 0= and\n"
"    IF gr.check\n"
"       now.playing: se-editbox\n"
"    ELSE 2drop\n"
"    THEN\n"
";\n"
"\n"
": SE.STOP.PLAYING  ( shape -- )\n"
"    cg-current-screen @ se-screen =\n"
"    servicing-tasks @ 0= and\n"
"    IF gr.check\n"
"       stop.playing: se-editbox\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": SE.TRACK.ON ( -- )\n"
"    'c se.now.playing is pl.now.playing\n"
"    'c se.stop.playing is pl.stop.playing\n"
";\n"
"\n"
"\n"
": SE.TRACK.OFF ( -- )\n"
"    'c 2drop is pl.now.playing\n"
"    'c drop is pl.stop.playing\n"
";\n"
"\n"
": BUILD.SE-EDITBOX  ( -- , build shape editor )\n"
"    2700 2300 put.wh: se-editbox\n"
";\n"
"\n"
"if.forgotten se.track.off\n"
"\\ Declare Dimension counter -----------------------------------\n"
"OB.COUNTER SE-DIMCOUNT\n"
"\n"
": SE.DODIM ( value part -- , process change in dimension )\n"
"    drop\n"
"    put.dim: se-editbox\n"
"    draw: se-editbox\n"
";\n"
"\n"
": BUILD.SE-DIMCOUNT\n"
"    \" Dim\" put.title: se-dimcount\n"
"    1 0 put.value: se-dimcount\n"
"    1 put.dim: se-editbox\n"
"\n"
"\\ Set Geometry\n"
"    200 700 put.wh: se-dimcount\n"
"\n"
"\\ Set word to execute when hit\n"
"    'c se.dodim put.down.function: se-dimcount\n"
";\n"
"\n"
"\\ Numeric Grid for A,B,C operations. ------------------\n"
"OB.NUMERIC.GRID SE-ABC-CG\n"
"\n"
": BUILD.ABC  ( -- )\n"
"    3 1 new: se-abc-cg\n"
"    270 300 put.wh: se-abc-cg\n"
"    -100 -1 put.min: se-abc-cg\n"
"    100 -1 put.max: se-abc-cg\n"
"    \"  A    B    C\" put.title: se-abc-cg\n"
"    2 0 put.value: se-abc-cg\n"
"    1 1 put.value: se-abc-cg\n"
"    0 2 put.value: se-abc-cg\n"
";\n"
"\n"
"\\ Options Grid ------------------------------------------------\n"
"OB.CHECK.GRID SE-OPTIONS-CG\n"
"\n"
"variable SE-IF-ALL\n"
"\n"
": SE.OPTIONS.FUNC   ( value part -- )\n"
"    CASE\n"
"       0 OF se-if-all ! ENDOF\n"
"       1 OF IF se.track.on\n"
"            ELSE se.track.off\n"
"                 se.get.shape   stop.playing: se-editbox\n"
"            THEN\n"
"         ENDOF\n"
"    ENDCASE\n"
";\n"
"\n"
": BUILD.OPTIONS ( -- )\n"
"    2 1 new: se-options-cg\n"
"    350 300 put.wh: se-options-cg\n"
"    stuff{ \" All/1\" \" Track\" }stuff.text: se-options-cg\n"
"    'c se.options.func put.down.function: se-options-cg\n"
"\\\n"
"\\ set tracking ON by default\n"
"    true 1 put.value: se-options-cg\n"
"    se.track.on\n"
"\\    \" Options\" put.title: se-options-cg\n"
";\n"
"\n"
"\\ Declare Operations Grid -------------------------------------\n"
"OB.MENU.GRID SE-OPERCG\n"
"-1  ( The order of these constants must match that in BUILD.SE-OPERCG)\n"
"1+ dup constant SE_CUT\n"
"1+ dup constant SE_COPY\n"
"1+ dup constant SE_PASTE\n"
"1+ dup constant SE_*A/B+C\n"
"1+ dup constant SE_-C*B/A\n"
"1+ dup constant SE_UP_1\n"
"1+ dup constant SE_DOWN_1\n"
"1+ dup constant SE_REVERSE\n"
"1+ dup constant SE_INVERT\n"
"1+ dup constant SE_SCRAMBLE\n"
"1+ dup constant SE_ZOOM\n"
"1+ dup constant SE_UNZOOM\n"
"1+ dup constant SE_PAN_LEFT\n"
"1+ dup constant SE_PAN_RIGHT\n"
"1+ dup constant SE_CUSTOM\n"
"drop\n"
"\n"
": SE.REVERSE  ( -- , Reverse values in range. )\n"
"    se.get.select 2dup <\n"
"    IF 1-    se-if-all @ IF -1 ELSE se.get.dim THEN\n"
"       se.get.shape\n"
"       reverse: []\n"
"       draw.data: se-editbox  ( update display )\n"
"    ELSE 2drop\n"
"    THEN\n"
";\n"
"\n"
": SE.SCRAMBLE  ( -- , SCRAMBLE values in range. )\n"
"    se.get.select 2dup <\n"
"    IF 1-    se-if-all @ IF -1 ELSE se.get.dim THEN\n"
"       se.get.shape\n"
"       scramble: []\n"
"       draw.data: se-editbox  ( update display )\n"
"    ELSE 2drop\n"
"    THEN\n"
";\n"
"\n"
": SE.SHOW.XY ( -- , show position of first point in range )\n"
"    se.get.select drop\n"
"    dup se.get.dim  ( -- elmnt# elmnt# dim )\n"
"    se.get.shape ed.at: []  ( -- elmnt# value )\n"
"    swap tell.xy: se-editbox\n"
";\n"
"\n"
": SE.TRANSPOSE  ( value -- , transpose select )\n"
"    se.get.select 2dup <\n"
"    IF 1- se.get.dim\n"
"       se.get.shape\n"
"       transpose: []\n"
"       se.update.draw\n"
"       se.show.xy\n"
"    ELSE 2drop drop\n"
"    THEN\n"
";\n"
"\n"
": SE.TRANSPOSE.DOWN  ( -- , Transpose values down in select. )\n"
"    -1 se.transpose\n"
";\n"
"\n"
": SE.TRANSPOSE.UP ( -- , Transpose values up in select. )\n"
"    1 se.transpose\n"
";\n"
"\n"
"\n"
": SE.*A/B+C  ( -- , scale and transpose data )\n"
"    1 get.value: se-abc-cg 0= 0=\n"
"    se.get.select < and\n"
"    IF 0 get.value: se-abc-cg\n"
"       1 get.value: se-abc-cg\n"
"       se.get.select\n"
"       1- se.get.dim\n"
"       se.get.shape\n"
"       scale: []\n"
"\\\n"
"       2 get.value: se-abc-cg\n"
"       se.get.select\n"
"       1- se.get.dim\n"
"       get.object: se-editbox\n"
"       transpose: []\n"
"       se.update.draw\n"
"       se.show.xy\n"
"    THEN\n"
";\n"
"\n"
"\n"
": SE.-C*B/A  ( -- , inverse of scale and transpose data )\n"
"    0 get.value: se-abc-cg 0= 0=\n"
"    se.get.select < and\n"
"    IF 2 get.value: se-abc-cg negate\n"
"       se.get.select\n"
"       1- se.get.dim\n"
"       se.get.shape\n"
"       transpose: []\n"
"\\\n"
"       1 get.value: se-abc-cg\n"
"       0 get.value: se-abc-cg\n"
"       se.get.select\n"
"       1- se.get.dim\n"
"       se.get.shape\n"
"       scale: []\n"
"       se.update.draw\n"
"       se.show.xy\n"
"    THEN\n"
";\n"
"\n"
"OB.ELMNTS SE-PASTE   ( Paste buffer)\n"
"\n"
": SE.COPY  ( -- , copy select region to paste buffer )\n"
"    se.get.select  ( -- s e )\n"
"    over -    ( -- s count )\n"
"    ?dup\n"
"    IF    ( -- s count )\n"
"        free: se-paste se.get.shape width: []\n"
"        set.width: se-paste\n"
"        dup se.get.shape dimension: [] new: se-paste\n"
"        dup set.many: se-paste\n"
"        0 swap se-paste  ( -- start 0 count se-paste )\n"
"        se.get.shape copy: []\n"
"\\\n"
"\\ Enable PASTE\n"
"        se_paste get.enable: se-opercg 0=\n"
"        IF true se_paste put.enable: se-opercg\n"
"           draw: se-opercg\n"
"        THEN\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": SE.CHOP ( -- , Remove selected range. )\n"
"    se.get.select 2dup <\n"
"    IF  ( -- s e )\n"
"        over -   ( -- s count )\n"
"        se.get.shape chop: []\n"
"        se.get.select drop  ( reset select range )\n"
"        dup put.select: se-editbox\n"
"        se.get.shape update: []\n"
"    ELSE 2drop\n"
"    THEN\n"
";\n"
"\n"
": SE.CUT   ( -- , cut and copy select to paste buffer )\n"
"    se.copy\n"
"    se.chop\n"
"    draw.data: se-editbox  ( update display )\n"
";\n"
"\n"
": <SE.PASTE>   ( -- , perform actual paste)\n"
"\\ Destroy selected range.\n"
"    se.chop\n"
"\\\n"
"    se.get.select drop\n"
"    many: se-paste  ( -- start count )\n"
"\\ Make room for new data. Check for being at end.\n"
"    over se.get.shape many: [] <\n"
"    IF 2dup   se.get.shape split: []\n"
"    ELSE dup se.get.shape dup >r many: [] +\n"
"         r> set.many: []\n"
"    THEN\n"
"\\ Move from paste buffer.  ( -- start count )\n"
"    0 -rot se.get.shape copy: se-paste\n"
"    draw.data: se-editbox  ( update display )\n"
";\n"
"\n"
": SE.PASTE   ( -- , paste from current position paste buffer )\n"
"\\ Check PASTE buffer.\n"
"    many: se-paste\n"
"    IF\n"
"\\ Check to make sure paste has same width and dimension\n"
"\\ as target.\n"
"        se.get.shape width: []\n"
"        width: se-paste =\n"
"        se.get.shape dimension: []\n"
"        dimension: se-paste = AND\n"
"        IF\n"
"\\ Check for overflow.\n"
"            se.get.select swap -  ( -- #selected )\n"
"            many: se-paste swap -          ( -- #to_add )\n"
"            se.get.shape check.over: []\n"
"            IF\n"
"                \" SE.PASTE\" \" Paste would overflow shape!\"\n"
"                er_return er.report\n"
"            ELSE  <se.paste>        ( actually do it! )\n"
"            THEN\n"
"            se.get.select put.select: se-editbox\n"
"        ELSE\n"
"            \" SE.PASTE\" \" Different dimension and width!\"\n"
"            er_return er.report\n"
"        THEN\n"
"\\ No DATA\n"
"    ELSE\n"
"        \" SE.PASTE\" \" Must do CUT or COPY first!\"\n"
"         er_return er.report\n"
"    THEN\n"
";\n"
"\n"
": SE.INVERT  ( -- , Invert portion of shape. )\n"
"    se.get.select 2dup <\n"
"    IF se.get.ymark -rot 1-\n"
"       se.get.dim\n"
"       se.get.shape invert: []\n"
"       se.update.draw\n"
"    ELSE 2drop\n"
"    THEN\n"
";\n"
"\n"
"V: SE-IF-ZOOMED\n"
": SE.ZOOM ( -- , Zoom on selected range. )\n"
"    se.get.select\n"
"    2dup  2- >\n"
"    IF 2drop \" SE.ZOOM\" \" Must select range first.\"\n"
"       er_return er.report \n"
"    ELSE\n"
"       1- put.range: se-editbox\n"
"       draw: se-editbox\n"
"       se-if-zoomed @ NOT\n"
"       IF  1 se_unzoom put.enable: se-opercg\n"
"           1 se_pan_left put.enable: se-opercg\n"
"           1 se_pan_right put.enable: se-opercg\n"
"           draw: se-opercg\n"
"       THEN true se-if-zoomed !\n"
"    THEN\n"
";\n"
"\n"
": SE_MAX_INDEX   ( -- maximum_index )\n"
"    se.get.shape\n"
"    max.elements: [] 1-\n"
";\n"
"\n"
": SE.UNZOOM ( -- , UnZoom )\n"
"    0 se_max_index put.range: se-editbox\n"
"    draw: se-editbox\n"
"    false se-if-zoomed !\n"
"    0 se_pan_left put.enable: se-opercg\n"
"    0 se_pan_right put.enable: se-opercg\n"
"    draw: se-opercg\n"
";\n"
"\n"
": SE.FIT.WITHIN ( x1 x2 -- x1' x2' )\n"
"    over - >r    ( width )\n"
"    0 se_max_index r@ - clipto   ( position left edge )\n"
"    dup r> +    ( calc right )\n"
";\n"
"\n"
": SE.PAN ( shift_count -- , Shift viewing range. )\n"
"    get.range: se-editbox 2 pick83 +\n"
"    >r + r> se.fit.within put.range: se-editbox\n"
"    draw: se-editbox\n"
";\n"
"\n"
": SE.PAN.LEFT ( -- , Pan to the left )\n"
"    get.range: se-editbox swap - 2/ negate se.pan\n"
";\n"
"\n"
": SE.PAN.RIGHT ( -- , Pan to the left )\n"
"    get.range: se-editbox swap - 2/ se.pan\n"
";\n"
"\n"
"OB.OBJLIST SE-OPER-CFAS\n"
"VARIABLE SE-OPER-PAGE   ( contains page of operators )\n"
"\n"
": SE.EXEC.OPER  ( value part -- )\n"
"    nip exec: se-oper-cfas\n"
";\n"
"\n"
": BUILD.SE-OPERCG ( -- )\n"
"\\ Build first page.\n"
"    stuff{ 'c se.cut  'c se.copy 'c se.paste\n"
"      'c se.*a/b+c 'c se.-c*b/a\n"
"      'c se.transpose.up 'c se.transpose.down 'c se.reverse\n"
"      'c se.invert  'c se.scramble \n"
"      'c se.zoom  'c se.unzoom 'c se.pan.left 'c se.pan.right\n"
"      'c noop\n"
"    }stuff: se-oper-cfas\n"
"\n"
"    5 3 new: se-opercg\n"
"\\    \" Operations\" put.title: se-opercg\n"
"\\\n"
"\\ Set Geometry\n"
"    570 280 put.wh: se-opercg\n"
"    'c se.exec.oper put.down.function: se-opercg\n"
"    false se_paste   put.enable: se-opercg\n"
"    false se_Pan_left  put.enable: se-opercg\n"
"    false se_Pan_right put.enable: se-opercg\n"
"    false se_custom  put.enable: se-opercg\n"
"    stuff{ \" Cut\"      \" Copy\"    \" Paste\"\n"
"      \" *A/B+C\"   \" -C*B/A\"  \" Up 1\"\n"
"      \" Down 1\"   \" Reverse\" \" Invert\"\n"
"      \" Scramble\" \" Zoom\"    \" UnZoom\"\n"
"      \" <= Pan\"   \" Pan =>\"   \" Custom\"\n"
"    }stuff.text: se-opercg\n"
";\n"
"\n"
": SE.SET.CUSTOM  ( text cfa -- , allow custom function in SE )\n"
"    se_custom put: se-oper-cfas\n"
"    se_custom put.text: se-opercg\n"
"    true se_custom put.enable: se-opercg\n"
";\n"
"\n"
": SE.RESET.CUSTOM ( -- )\n"
"    \" Custom\" 'c noop se.set.custom\n"
"    false se_custom put.enable: se-opercg\n"
";\n"
"\n"
": SE.DRAW.SCREEN   ( -- , Make shape editor current screen )\n"
"    draw: se-screen\n"
";\n"
"\n"
": SE.SET.SHAPE  ( shape -- , Set shape in editor )\n"
"\\ Check for allocated space.\n"
"    dup limit: [] 0=\n"
"    IF cr .\" Space automatically allocated.  32 3 NEW: \" \n"
"       dup name: [] beep cr \n"
"       32 3   2 pick83 new: []\n"
"       10 20 100  3 pick83 add: []\n"
"    THEN\n"
"\\\n"
"\\ Set up dimension counter\n"
"    dup dimension: []  1- \n"
"    dup 0 put.max: se-dimcount  ( set max dimension )\n"
"\\ Attempt to stay on same dimension as before.\n"
"    se.get.dim MIN dup put.dim: se-editbox\n"
"    0 put.value: se-dimcount\n"
"\\\n"
"\\ Set up edit display box  ( -- shape )\n"
"    dup put.object: se-editbox\n"
"    update: se-editbox\n"
"\\\n"
"\\ Make sure it is in SHAPE-HOLDER\n"
"    dup indexof: shape-holder\n"
"    IF 2drop\n"
"    ELSE add: shape-holder\n"
"    THEN    \n"
";\n"
"\n"
": SE.EDIT.SHAPE ( shape -- )\n"
"    se.set.shape\n"
"    draw: se-screen\n"
";\n"
"\n"
"\\ Setup -------------------------------------------------------\n"
": SE.SETUP  ( shape -- , set up shape editor for a shape )\n"
"    se.set.shape\n"
"    draw: se-editbox\n"
"    draw: se-dimcount\n"
";\n"
"\n"
": SE.STARTUP ( -- , Set shape editor to known state. )\n"
"    ml.validate  ( make sure all shapes valid, 00002 )\n"
"    many: shape-holder 0=\n"
"    IF  shape-1 add: shape-holder\n"
"        shape-1\n"
"    ELSE se.get.shape\n"
"        dup indexof: shape-holder\n"
"        IF ( -- shape index )\n"
"            drop ( shape found in shape-holder, use it. )\n"
"        ELSE ( -- bad_shape )\n"
"            drop 0 get: shape-holder\n"
"        THEN\n"
"    THEN  ( -- shape )\n"
"    se.set.shape\n"
"    0 scg.selnt\n"
";\n"
"\n"
"\\ Selector -----------------------------------------\n"
"OB.COUNTER SE-SHSELCG\n"
": SE.CHOOSESH    ( index part -- , Make selected shape current.)\n"
"    swap  ( get index )\n"
"    dup many: shape-holder <\n"
"    IF  get: shape-holder   se.setup\n"
"    ELSE drop\n"
"    THEN\n"
"\\\n"
"\\ redraw entire screen if hit in middle\n"
"    dup 1 = swap 2 = or\n"
"    IF  se.draw.screen\n"
"    THEN\n"
";\n"
"\n"
": SE.TEXT.FUNC ( index -- addr count , get name of shape )\n"
"    ml.validate ( 00002 )\n"
"    many: shape-holder 1- 0 put.max: se-shselcg \\ 00001\n"
"    get: shape-holder get.name: [] count\n"
";\n"
"\n"
": BUILD.SE-SHSELCG\n"
"    \" Select Shape\" put.title: se-shselcg\n"
"    800 700 put.wh: se-shselcg\n"
"    'c se.choosesh put.down.function: se-shselcg\n"
"    'c se.text.func put.text.function: se-shselcg\n"
";\n"
"    \n"
"\\ Define edit screen ------------------------------------------\n"
"\n"
": BUILD.ESCR\n"
"    build.se-mode\n"
"    build.se-editbox\n"
"    build.se-dimcount\n"
"    build.se-opercg\n"
"    build.se-shselcg\n"
"    build.abc\n"
"    build.options\n"
"    10  3 new: SE-SCREEN\n"
"    SE-EDITBOX            1330     303  add: SE-SCREEN\n"
"    SE-OPERCG              100    3000  add: SE-SCREEN\n"
"    SE-OPTIONS-CG         3158    3537  add: SE-SCREEN\n"
"    SE-ABC-CG             3150    3000  add: SE-SCREEN\n"
"    SE-SHSELCG             100    2141  add: SE-SCREEN\n"
"    SE-DIMCOUNT            958    2141  add: SE-SCREEN\n"
"    SE-MODECG              100     652  add: SE-SCREEN\n"
"\n"
"    \" Shape Editor\" put.title: se-screen\n"
"    ascii S put.key: se-screen\n"
"\\\n"
"\\ Set DRAW function.\n"
"    'c se.startup put.draw.function: se-screen\n"
";\n"
"\n"
": SE.INIT   ( -- , Initialize shape editor )\n"
"    \" SE.INIT\" debug.type\n"
"    false se-if-zoomed !\n"
"\\ Fix up the default player for shape editor\n"
"    free: se-player\n"
"    init: se-player   ( to ensure proper CFAs on Mac )\n"
"    4 new: se-player\n"
"\\\n"
"[ exists? INS-MIDI-1 [IF] ]\n"
"    ins-midi-1 put.instrument: se-player\n"
"[ [THEN] ]\n"
"\\\n"
"    1000000 put.repeat: se-player\n"
"\\\n"
"    build.escr\n"
"\\\n"
"    32 3 new: shape-1\n"
"    rtc.rate@ 3 /    \\ duration\n"
"    dup 10 choose 10 + 100 add: shape-1\n"
"    dup 10 choose 10 +  90 add: shape-1\n"
"    dup 10 choose 10 +  90 add: shape-1\n"
"    dup 10 choose 10 +  90 add: shape-1\n"
"    drop\n"
"    shape-1 se.set.shape\n"
"\\\n"
"    se-screen default-screen !\n"
"    'c se.edit.shape is edit.shape\n"
";\n"
"\n"
": SE.TERM\n"
"    \" SE.TERM\" debug.type\n"
"    free: se-player\n"
"    free: shape-1\n"
"    freeall: se-screen\n"
"    free: se-oper-cfas\n"
"    free: se-screen\n"
"    'c drop is edit.shape\n"
";\n"
"\n"
"\\ These are loaded above HMSL.INIT as optional modules\n"
"\\ so use USER.INIT\n"
": USER.INIT user.init se.init ;\n"
": USER.TERM se.term user.term ;\n"
"\n"
"\\ A few user accessible SE words\n"
": SE.UPDATE.SHAPE  ( shape -- , update drawing if being shown )\n"
"    se.get.shape =  ( same shape? )\n"
"    IF  cg-current-screen @ se-screen =  ( in SE ? )\n"
"        IF  servicing-tasks @ 0=  ( not called from SERVICE.TASKS )\n"
"            IF servicing-tasks on  \\ disable it\n"
"               gr.check se.update.draw\n"
"               servicing-tasks off\n"
"            THEN\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
": HMSL.EDIT.PLAY ( shape -- , edit and simultaneously play a shape )\n"
"    hmsl.init\n"
"    limit: se-player 1 <\n"
"    IF 4 new: se-player\n"
"    THEN\n"
"    clear: se-player dup add: se-player\n"
"    hmsl.open  ( make window available for drawing )\n"
"    se.set.shape   ( set up shape editor )\n"
"    se-screen default-screen !\n"
"    se-player hmsl.play\n"
";\n"
"\n"
": SHEP  ( -- , quickly play and edit a shape )\n"
"    shape-1 hmsl.edit.play\n"
";\n"
"\n"
"\n"
"\\ ---------------------------------------------------------\n"
"if.forgotten se.term\n"
"\n"
"false [IF]\n"
": HMSL.CHECK.EVENT ( -- done? , Process one event from event queue. )\n"
"    false         ( default done flag )\n"
"    ev.get.event  ( get one event )\n"
"    CASE \n"
"         EV_NULL OF ENDOF\n"
"\n"
"         EV_MOUSE_DOWN OF cg-current-screen @ ?dup\n"
"                 IF gr.getxy rot mouse.down: [] drop THEN\n"
"             ENDOF\n"
"\n"
"         EV_MOUSE_UP OF cg-current-screen @ ?dup \n"
"                 IF gr.getxy rot mouse.up: [] THEN\n"
"             ENDOF\n"
"\n"
"         EV_MOUSE_MOVE OF  cg-current-screen @ ?dup \n"
"                 IF gr.getxy rot mouse.move: [] THEN\n"
"             ENDOF\n"
"\n"
"\\         EV_REFRESH OF\n"
" \\               hmsl.refresh\n"
"  \\       ENDOF\n"
"\n"
"\\         EV_MENU_PICK OF\n"
" \\               process.menus\n"
"  \\       ENDOF\n"
"\n"
"         EV_CLOSE_WINDOW OF drop true \\ STOP HMSL !\n"
"             ENDOF\n"
"    ENDCASE\n"
";\n"
"\n"
": LOOP.SCREEN\n"
"    stack.mark\n"
"    BEGIN\n"
"        stack.check\n"
"        hmsl.check.event\n"
"    UNTIL\n"
";\n"
"\n"
": TEST.SE\n"
"    SE.INIT\n"
"    gr.check\n"
"    draw: se-screen\n"
"    loop.screen\n"
"    SE.TERM\n"
";\n"
"\n"
"[THEN]\n";

const char* shape_editor_fth = (const char*) temp_binary_data_66;

//================== stacks.fth ==================
static const unsigned char temp_binary_data_67[] =
"\\ Generic stack support.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1989 Phil Burk\n"
"\n"
"ANEW TASK-STACKS\n"
"decimal\n"
"\n"
":STRUCT STACK.HEADER\n"
"    long   st_base    ( relative address of base of stack )\n"
"    long   st_depth\n"
"    long   st_limit\n"
";STRUCT\n"
"\n"
": STACK.EMPTY? ( stack -- flag , true if empty )\n"
"    ..@ st_depth 1 <\n"
";\n"
"\n"
": STACK.FULL?  ( stack -- flag , true if full )\n"
"    dup>r ..@ st_depth r> ..@ st_limit >=\n"
";\n"
"\n"
": STACK.CLEAR ( stack -- )\n"
"    0 swap ..! st_depth\n"
";\n"
"\n"
": STACK.SETUP ( data limit stack -- )\n"
"    dup>r ..! st_limit\n"
"    0 r@ ..! st_depth\n"
"    use->rel r> ..! st_base\n"
";\n"
"\n"
": STACK.PUSH ( val stack -- )\n"
"    dup stack.full?\n"
"    IF .hex . .\" - Custom stack full!\" cr\n"
"    ELSE dup>r ..@ st_depth cell*\n"
"         r@ ..@ st_base rel->use + !\n"
"     1 r> .. st_depth +!\n"
"    THEN\n"
";\n"
"\n"
": STACK.POP ( stack -- val )\n"
"    dup stack.empty?\n"
"    IF .hex .\" - Custom stack empty!\" cr 0\n"
"    ELSE dup>r ..@ st_depth 1- dup r@ ..! st_depth\n"
"         cell*\n"
"         r> ..@ st_base rel->use + @\n"
"    THEN\n"
";\n"
"\n"
": STACK.DROP ( stack -- )\n"
"    dup stack.empty?\n"
"    IF .hex .\" - Custom stack empty!\" cr\n"
"    ELSE dup>r ..@ st_depth 1- r> ..! st_depth\n"
"    THEN\n"
";\n"
"\n"
": STACK.COPY ( stack -- val , copy from top of stack, like R@ )\n"
"    dup stack.empty?\n"
"    IF .hex .\" - Custom stack empty!\" cr 0\n"
"    ELSE dup>r ..@ st_depth 1-\n"
"         cell*\n"
"         r> ..@ st_base rel->use + @\n"
"    THEN\n"
";\n"
"\n"
": STACK.DEPTH ( stack -- depth )\n"
"    ..@ st_depth\n"
";\n"
"\n"
": STACK.DUMP ( stack -- , dump stack )\n"
"    dup stack.depth 0\n"
"    ?DO dup ..@ st_base rel->use i cell* + @ .\n"
"    LOOP drop cr\n"
";\n"
"\n"
"\\ Testing\n"
"false [IF]\n"
"4 constant ST_MAX\n"
"CREATE ST-DATA st_max cell* allot\n"
"STACK.HEADER ST1\n"
": ST.TEST1\n"
"    st-data st_max st1 stack.setup\n"
";\n"
"\n"
": ST.TEST2\n"
"    st.test1\n"
"    123 st1 stack.push\n"
"    876 st1 stack.push\n"
"    st1 stack.dump\n"
"    st1 stack.pop dup . 876 - abort\" ST.TEST2 failed!\"\n"
"    st1 stack.pop dup . 123 - abort\" ST.TEST2 failed!\"\n"
";\n"
"[THEN]\n";

const char* stacks_fth = (const char*) temp_binary_data_67;

//================== startup.fth ==================
static const unsigned char temp_binary_data_68[] =
"\\ Set startup vector for HMSL\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\n"
"ANEW TASK-STARTUP\n"
"\n"
": HMSL.INIT.ASK  ( -- , Ask if user wants to HMSL.INIT )\n"
"    hmsl.copyright\n"
"    .\" Do you want to initialize HMSL? (probably Yes)\" Y/N cr\n"
"    IF hmsl.init\n"
"    ELSE ob.init\n"
"    THEN\n"
";\n"
"\n"
": AUTO.INIT  ( -- , called automatically at startup )\n"
"    auto.init\n"
"    hmsl.init.ask\n"
";\n";

const char* startup_fth = (const char*) temp_binary_data_68;

//================== stock_morphs.fth ==================
static const unsigned char temp_binary_data_69[] =
"\\ Define a set of stock MORPHS to be used.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\\n"
"\\ MOD: PLB 6/1/87 Add JOBs\n"
"\\ MOD: PLB 1/26/88 Add INIT: of INS-MIDI-5 thru 8\n"
"\n"
"ANEW TASK-STOCK_MORPHS\n"
"\n"
"\\ Declare some shapes to use.\n"
"OB.SHAPE SHAPE-1\n"
"OB.SHAPE SHAPE-2\n"
"OB.SHAPE SHAPE-3\n"
"OB.SHAPE SHAPE-4\n"
"OB.SHAPE SHAPE-5\n"
"OB.SHAPE SHAPE-6\n"
"OB.SHAPE SHAPE-7\n"
"OB.SHAPE SHAPE-8\n"
"\n"
"\\ Declare shape players.\n"
"OB.PLAYER PLAYER-1\n"
"OB.PLAYER PLAYER-2\n"
"OB.PLAYER PLAYER-3\n"
"OB.PLAYER PLAYER-4\n"
"OB.PLAYER PLAYER-5\n"
"OB.PLAYER PLAYER-6\n"
"OB.PLAYER PLAYER-7\n"
"OB.PLAYER PLAYER-8\n"
"\n"
"exists? ob.midi.instrument [IF]\n"
"  OB.MIDI.INSTRUMENT INS-MIDI-1\n"
"  OB.MIDI.INSTRUMENT INS-MIDI-2\n"
"  OB.MIDI.INSTRUMENT INS-MIDI-3\n"
"  OB.MIDI.INSTRUMENT INS-MIDI-4\n"
"  OB.MIDI.INSTRUMENT INS-MIDI-5\n"
"  OB.MIDI.INSTRUMENT INS-MIDI-6\n"
"  OB.MIDI.INSTRUMENT INS-MIDI-7\n"
"  OB.MIDI.INSTRUMENT INS-MIDI-8\n"
"[THEN]\n"
"\n"
": STOCK.INIT.SPI  ( -- , Initialize Shapes, Players, Instr)\n"
"       init: shape-1\n"
"       init: shape-2\n"
"       init: shape-3\n"
"       init: shape-4\n"
"       init: shape-5\n"
"       init: shape-6\n"
"       init: shape-7\n"
"       init: shape-8\n"
"\n"
"       init: player-1\n"
"       init: player-2\n"
"       init: player-3\n"
"       init: player-4\n"
"       init: player-5\n"
"       init: player-6\n"
"       init: player-7\n"
"       init: player-8\n"
"\\\n"
"\\ Set default instruments in some players.\n"
"[ exists? ob.midi.instrument [IF] ]\n"
"       init: ins-midi-1\n"
"       init: ins-midi-2\n"
"       init: ins-midi-3\n"
"       init: ins-midi-4\n"
"       init: ins-midi-5\n"
"       init: ins-midi-6\n"
"       init: ins-midi-7\n"
"       init: ins-midi-8\n"
"       ins-midi-1 put.instrument: player-1\n"
"       ins-midi-2 put.instrument: player-2\n"
"       ins-midi-3 put.instrument: player-3\n"
"       ins-midi-4 put.instrument: player-4\n"
"[ [THEN] ]\n"
";\n"
"\n"
"\\ Declare sequential and parallel collections.\n"
"OB.COLLECTION COLL-S-1\n"
"OB.COLLECTION COLL-S-2\n"
"OB.COLLECTION COLL-S-3\n"
"OB.COLLECTION COLL-S-4\n"
"\n"
"OB.COLLECTION COLL-P-1\n"
"OB.COLLECTION COLL-P-2\n"
"OB.COLLECTION COLL-P-3\n"
"OB.COLLECTION COLL-P-4\n"
"\n"
"OB.STRUCTURE STRUCT-1\n"
"\n"
"\\ Declare some productions.\n"
"OB.PRODUCTION PRODUCTION-1\n"
"OB.PRODUCTION PRODUCTION-2\n"
"OB.PRODUCTION PRODUCTION-3\n"
"OB.PRODUCTION PRODUCTION-4\n"
"\n"
"OB.JOB JOB-1\n"
"OB.JOB JOB-2\n"
"OB.JOB JOB-3\n"
"OB.JOB JOB-4\n"
"\n"
"CREATE IF-STOCK-INIT 0 ,\n"
"\n"
": STOCK.INIT    ( -- , Initialize stock objects. )\n"
"\\ Players and streams need INIT: on MAC for proper CFAs\n"
"    if-stock-init @ 0=\n"
"    IF    \" STOCK.INIT\" debug.type\n"
"       stock.init.spi\n"
"\\\n"
"       init: coll-s-1\n"
"       act.sequential: coll-s-1\n"
"       init: coll-s-2\n"
"       act.sequential: coll-s-2\n"
"       init: coll-s-3\n"
"       act.sequential: coll-s-3\n"
"       init: coll-s-4\n"
"       act.sequential: coll-s-4\n"
"       init: coll-p-1\n"
"       init: coll-p-2\n"
"       init: coll-p-3\n"
"       init: coll-p-4\n"
"       init: struct-1\n"
"\\\n"
"       init: production-1\n"
"       init: production-2\n"
"       init: production-3\n"
"       init: production-4\n"
"\\\n"
"       init: job-1\n"
"       init: job-2\n"
"       init: job-3\n"
"       init: job-4\n"
"\\\n"
"       true if-stock-init !\n"
"    THEN\n"
";\n"
"\n"
": SYS.INIT sys.init stock.init ;\n"
"\n"
"\\ END\n";

const char* stock_morphs_fth = (const char*) temp_binary_data_69;

//================== structure.fth ==================
static const unsigned char temp_binary_data_70[] =
"\n"
"\\ STRUCTURES differs from a COLLECTION in that they have a\n"
"\\ square grid of tendencies.\n"
"\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\n"
"\\ 00001 PLB 5/21/92 Removed from file H:COLLECTION\n"
"\n"
"ANEW TASK-STRUCTURE\n"
"\n"
"METHOD GET.TENDENCY:    METHOD PUT.TENDENCY:\n"
"METHOD FILL.TENDENCIES: METHOD GET.TGRID:\n"
"METHOD SUM.ROW:\n"
"METHOD SCAN.ROW:\n"
"METHOD CHAIN:  \n"
"METHOD CHOOSE:  \n"
"METHOD GET.LAST:\n"
"METHOD PUT.LAST:\n"
"\n"
": STR.BHV.MARKOV ( structure -- index 1 | 0 )\n"
"    choose: [] dup 0<\n"
"    IF drop 0  ( row was all zeroes! )\n"
"    ELSE 1\n"
"    THEN\n"
";\n"
"\n"
":CLASS OB.STRUCTURE <SUPER OB.COLLECTION\n"
"    ob.shape IV-ST-TENDENCIES  ( Tendency array )\n"
"    iv.long  IV-ST-LAST\n"
"\n"
":M GET.LAST: ( -- lastchoice , return last one chosen )\n"
"    iv-st-last\n"
";M\n"
":M PUT.LAST: ( lastchoice -- , set starting point for chain )\n"
"    0 max iv=> iv-st-last\n"
";M\n"
"\n"
":M GET.TENDENCY: ( s t -- T[s->t] )\n"
"    ed.at: iv-st-tendencies\n"
";M\n"
"\n"
":M PUT.TENDENCY: ( T[s->t] s t --  )\n"
"    ed.to: iv-st-tendencies\n"
";M\n"
"\n"
":M FILL.TENDENCIES: ( value -- , set all tendencies to value )\n"
"     fill: iv-st-tendencies\n"
";M\n"
"\n"
":M GET.TGRID: ( -- tendencies-elmnts-array )\n"
"    iv-st-tendencies\n"
";M\n"
"\n"
":M SUM.ROW:  ( elmnt# -- sum , sum of tendencies times weights )\n"
"    0 dimension: iv-st-tendencies 0\n"
"    ?DO over i ed.at: iv-st-tendencies\n"
"        i at: self get.weight: [] * +  ( -- elmnt# sum )\n"
"    LOOP nip\n"
";M\n"
"\n"
":M SCAN.ROW:  { val elmnt# | choice -- t  , look for bucket }\n"
"    -1 -> choice\n"
"    0 dimension: iv-st-tendencies 0\n"
"    ?DO  elmnt# i ed.at: iv-st-tendencies\n"
"        i at: self get.weight: [] * +  ( -- elmnt# sum )\n"
"        dup val  >\n"
"        IF i -> choice leave\n"
"        THEN\n"
"    LOOP drop\n"
"    choice\n"
";M\n"
"\n"
":M CHAIN:  ( elmnt# -- choice , calculate weighted probablility )\n"
"    dup sum.row: self\n"
"    choose\n"
"    swap scan.row: self\n"
"    dup put.last: self\n"
";M\n"
"\n"
":M CHOOSE: ( -- choice , next based on last one )\n"
"    iv-st-last chain: self\n"
";M\n"
"\n"
":M NEW: ( #morphs -- , allocate room )\n"
"    dup new: super\n"
"    dup dup dup new: iv-st-tendencies ( square space )\n"
"\\ These limits will only affect editing operations.\n"
"    0 ?DO 0 100 i put.dim.limits: iv-st-tendencies\n"
"    LOOP\n"
"\\\n"
"    set.many: iv-st-tendencies\n"
"    10 fill.tendencies: self\n"
"    0 iv=> iv-st-last\n"
"    iv-behave-cfa 0=\n"
"    IF  .\" Behavior set to Markov, start at 0.\" cr\n"
"        'c str.bhv.markov put.behavior: self\n"
"    THEN\n"
";M\n"
"\n"
":M FREE: ( -- )\n"
"    free: super\n"
"    free: iv-st-tendencies\n"
";M\n"
"    \n"
":M PRINT: ( -- )\n"
"    print: super\n"
"    ?pause\n"
"    .\" Tendencies array ----------\" cr\n"
"    print: iv-st-tendencies\n"
";M\n"
"\n"
":M EXTEND:  ( #morphs -- , extend number of morphs allowed)\n"
"    extend: super\n"
"    max.elements: self dup new: iv-st-tendencies\n"
"    . \" EXTEND: STRUCTURE\" \" Clears tendency grid!\"\n"
"    er_warning ob.report.error\n"
";M\n"
"\n"
":M CLASS.NAME: ( -- $NAME )\n"
"    \" OB.STRUCTURE\"\n"
";M\n"
"\n"
";CLASS\n"
"\n"
": OB.TSTRUCTURE ( -- , fake old class )\n"
"    .\" OB.TSTRUCTURE is now OB.STRUCTURE !\" cr\n"
"    .\" BEHAVIORS are different too!\" cr\n"
"    ob.structure\n"
";\n"
"\n"
"if-testing @ [IF]\n"
"ob.collection col1\n"
"ob.collection col2\n"
"ob.collection col3\n"
"ob.collection col4\n"
"ob.structure st1\n"
": COL.TEST1\n"
"    0 col1 col2 col3 0stuff: col4\n"
"    print: col4\n"
";\n"
"\n"
": COL.TERM\n"
"    free: col4\n"
"    free: st1\n"
";\n"
": ST.INIT\n"
"    0 col1 col2 col3 col4 0stuff: st1\n"
";\n"
"\n"
": ST.TEST\n"
"    BEGIN choose: st1 . cr\n"
"        ?terminal\n"
"    UNTIL\n"
";\n"
"\n"
"if.forgotten col.term\n"
"[THEN]\n"
"\n"
"\n";

const char* structure_fth = (const char*) temp_binary_data_70;

//================== stubs.fth ==================
static const unsigned char temp_binary_data_71[] =
"\\ Words needed to compile HMSL on pForth\n"
"\\\n"
"\\ History:\n"
"\\ 050106 - unstub some MIDI and clock commands\n"
"\\ 060108 - change behavior of DO to match F83 style\n"
"\n"
"ANEW TASK-STUBS\n"
"\n"
"variable host-debug\n"
"host-debug on\n"
"\n"
": hostStartClock() ( -- )\n"
"    host-debug @ IF .\" hostStartClock() is a noop\" cr THEN\n"
";\n"
": hostStopClock() ( -- )\n"
"    host-debug @ IF .\" hostStopClock() is a noop\" cr THEN\n"
";\n"
"\n"
"\n"
"\\ init and term chain starts here -----------------------\n"
"\n"
"exists? SYS.INIT not [if] \n"
"    : SYS.INIT hostInit() drop ;\n"
"    : SYS.TERM hostTerm() ;\n"
"    : SYS.RESET ;\n"
"[THEN]\n"
"\n";

const char* stubs_fth = (const char*) temp_binary_data_71;

//================== test_actions.fth ==================
static const unsigned char temp_binary_data_72[] =
"\\ Define some stock actions\n"
"\\ author: Polansky\n"
"\\ MOD: PLB 4/15/87 Added INIT: of each action for Mac\n"
"\n"
"ANEW TASK-TEST_ACTIONS\n"
"\n"
"ob.action act-1\t\tob.action act-9\n"
"ob.action act-2\t\tob.action act-10\n"
"ob.action act-3\t\tob.action act-11\n"
"ob.action act-4\t\tob.action act-12\n"
"ob.action act-5\t\tob.action act-13\n"
"ob.action act-6\t\tob.action act-14\n"
"ob.action act-7\t\tob.action act-15\n"
"ob.action act-8\t\tob.action act-16\n"
"\n"
"ob.action act-null\n"
"\n"
": INIT.STOCK.ACTIONS  ( -- , Sets CFAs for Mac )\n"
"    init: act-1    init: act-2\n"
"    init: act-3    init: act-4\n"
"    init: act-5    init: act-6\n"
"    init: act-7    init: act-8\n"
"    init: act-9    init: act-10\n"
"    init: act-11    init: act-12\n"
"    init: act-13    init: act-14\n"
"    init: act-15    init: act-16\n"
"\\ initialize ACT-NULL, very important...\n"
"    init: act-null\n"
";\n"
"\n"
"\n";

const char* test_actions_fth = (const char*) temp_binary_data_72;

//================== test_events.fth ==================
static const unsigned char temp_binary_data_73[] =
"\\ Test event generation\n"
"\\ Author: rnm & Phil Burk\n"
"\n"
"ANEW TASK-TEST_EVENTS\n"
"\n"
"WindowTemplate testWindow\n"
"\n"
": build.window\n"
"    \" A Test HMSL Window\" testWindow ..! wt_Title\n"
"    100 testWindow .. wt_Rect ..! rect_top\n"
"    100 testWindow .. wt_Rect ..! rect_left\n"
"    600 testWindow .. wt_Rect ..! rect_bottom\n"
"    700 testWindow .. wt_Rect ..! rect_right\n"
";\n"
"\n"
": TEV.INIT\n"
"\\ hostInit()\n"
"    build.window\n"
"    testWindow gr.openwindow gr-curwindow !\n"
";\n"
"\n"
": TEV.TERM\n"
"    gr.closecurw\n"
";\n"
"\n"
": TEV.HANDLE.EVENT { event | ifquit -- ifquit , Process one event from event queue. }\n"
"    false -> ifquit\n"
"    event\n"
"    CASE\n"
"        EV_NULL OF\n"
"\\            .\" EV_NULL\" cr\n"
"        ENDOF\n"
"\n"
"        EV_MOUSE_DOWN OF \n"
"            .\" mouse DOWN at \" gr.getxy swap . . cr\n"
"        ENDOF\n"
"\n"
"        EV_MOUSE_UP OF\n"
"            .\" mouse UP at \" gr.getxy swap . . cr\n"
"        ENDOF\n"
"\n"
"        EV_MOUSE_MOVE OF\n"
"            .\" mouse MOVE at \" gr.getxy swap . . cr\n"
"        ENDOF\n"
"\n"
"        EV_REFRESH OF\n"
"            .\" EV_REFRESH\" cr\n"
"        ENDOF\n"
"\n"
"        EV_KEY OF\n"
"            .\" EV_KEY \" ev.get.key dup . emit cr\n"
"        ENDOF\n"
"\n"
"        EV_CLOSE_WINDOW OF\n"
"            true -> ifquit\n"
"        ENDOF\n"
"    ENDCASE\n"
"    ifquit\n"
";\n"
"\n"
": TEV  ( -- )\n"
"    BEGIN\n"
"        ev.get.event ( get one event )\n"
"        tev.handle.event\n"
"        ?terminal OR\n"
"    UNTIL\n"
";\n"
"\n"
"if.forgotten tev.term\n";

const char* test_events_fth = (const char*) temp_binary_data_73;

//================== test_graphics.fth ==================
static const unsigned char temp_binary_data_74[] =
"\\ Test basic portable graphics code\n"
"\\ Author: rnm & Phil Burk\n"
"\n"
"ANEW TASK-TEST_GRAPHICS\n"
"\n"
"WindowTemplate testWindow\n"
"\n"
": build.window\n"
"    \" A Test HMSL Window\" testWindow ..! wt_Title\n"
"    100 testWindow .. wt_Rect ..! rect_top\n"
"    100 testWindow .. wt_Rect ..! rect_left\n"
"    600 testWindow .. wt_Rect ..! rect_bottom\n"
"    700 testWindow .. wt_Rect ..! rect_right\n"
";\n"
"\n"
": TGR.INIT\n"
"\\ hostInit()\n"
"    build.window\n"
"    testWindow gr.openwindow gr-curwindow !\n"
";\n"
"\n"
": TGR.TERM\n"
"    gr.closecurw\n"
";\n"
"\n"
"if.forgotten tgr.term\n"
"\n"
"16 constant NUM_COLORS\n"
"\n"
": random.rects\n"
"    1000 0 DO\n"
"        NUM_COLORS choose dup . cr gr.color!\n"
"        4 0 DO 100 choose LOOP\n"
"        .s cr\n"
"        gr.rect\n"
"    LOOP\n"
";\n"
"\n"
": TGR.SHOW.COLORS { x0 y0 numColors -- }\n"
"    numColors 0 do\n"
"        i . cr\n"
"        i gr.color!\n"
"        i 10 * x0 +\n"
"        y0\n"
"        over 10 +\n"
"        y0 90 +\n"
"        gr.rect\n"
"    loop\n"
";\n"
"\n"
"\n"
": TGR.CHECK.XOR { x0 y0 x1 y1 -- }\n"
"    gr_insert_mode gr.mode!\n"
"    x0 y0 10 + \n"
"    x1 y1 10 - gr.rect\n"
"    \n"
"    gr_xor_mode gr.mode!\n"
"    x0 10 +  y0\n"
"    x1 10 -  y1 gr.rect\n"
"    \n"
"    x0 20 +  y0 20 +\n"
"    x1 20 -  y1 20 - gr.rect\n"
"    \n"
"    gr_insert_mode gr.mode!\n"
";\n"
"\n"
": TGR.CROSS.COLORS { x0 y0 numColors xorColor -- }\n"
"    x0 20 + y0 numColors tgr.show.colors\n"
"    xorColor gr.color!\n"
"    gr_xor_mode gr.mode!\n"
"    x0 y0 20 +\n"
"    over 200 + over 30 + gr.rect\n"
";\n"
"\n"
": TGR.RECT.LINES  { x0 y0 x1 y1 -- }\n"
"    x0 y0 gr.move\n"
"    x1 y0 gr.draw\n"
"    x1 y1 gr.draw\n"
"    x0 y1 gr.draw\n"
"    x0 y0 gr.draw\n"
";\n"
"\n"
": TGR.NESTED  { x0 y0 x1 y1 -- }\n"
"    gr_insert_mode gr.mode!\n"
"    1 gr.color!\n"
"    x0 y0 x1 y1 tgr.rect.lines\n"
"    5 gr.color!\n"
"    x0 1+ y0 1+ x1 1- y1 1- gr.rect\n"
"    2 gr.color!\n"
"    x0 2+ y0 2+ x1 2- y1 2- gr.rect\n"
";\n"
"\n"
": TGR.TEXT.PLACE  { x0 y0 -- }\n"
"    1 gr.color!\n"
"    x0 y0 10 - gr.move\n"
"    x0 20 - y0 20 - gr.draw\n"
"    x0 y0 gr.draw\n"
"    \" hey\" gr.text\n"
"    x0 100 + y0 100 + gr.draw\n"
";\n"
"\n"
": TGR\n"
"    gr.clear\n"
"    20 20 8 0 tgr.cross.colors\n"
"    20 120 8 1 tgr.cross.colors\n"
"    320 20 8 2 tgr.cross.colors\n"
"    320 120 8 3 tgr.cross.colors\n"
"\\\n"
"    100 250 300 350 tgr.nested\n"
"    \n"
"    350 250 tgr.text.place\n"
";\n";

const char* test_graphics_fth = (const char*) temp_binary_data_74;

//================== test_ode.fth ==================
static const unsigned char temp_binary_data_75[] =
"\\ @(#) test_ode.fth 96/06/11 1.1\n"
"\\ Test ODE\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1995 Phil Burk\n"
"\n"
"ANEW TASK-TEST_ODE\n"
"\n"
"\\ create a simple object\n"
"object obj1\n"
"\n"
"' obj1 >body  address: obj1 - abort\" address: obj1 doesn't return body\"\n"
"12             space: obj1   - abort\" space: obj1 doesn't return 12\"\n"
"\n"
".\" Class of obj1 should be 'object' = \" .class: obj1\n"
"\n"
"dump: obj1\n"
"\n"
"\\ create an integer object\n"
"\n"
"ob.int  int1\n"
"876 constant val_1\n"
"778899 constant val_2\n"
"val_1 put: int1\n"
"val_1    get: int1  - abort\" get: int1 doesn't return proper value\"\n"
"\n"
"\\ check late binding\n"
"val_2 put: int1\n"
"val_2    int1 get: []  - abort\" int1 get: [] doesn't return proper value\"\n"
"\n"
"\n"
"\\ check compile time late binding\n"
": tode1\n"
"    val_1 put: int1\n"
"    val_1    int1 get: []\n"
"    - abort\" compiled get: int1 doesn't return proper value\"\n"
";\n"
"tode1\n"
"\\ check compile time late binding\n"
": tode2\n"
"    val_2 put: int1\n"
"    val_2    int1 get: []\n"
"    - abort\" compiled int1 get: [] doesn't return proper value\"\n"
";\n"
"tode2\n"
"\n";

const char* test_ode_fth = (const char*) temp_binary_data_75;

//================== test_ode_locals.fth ==================
static const unsigned char temp_binary_data_76[] =
"\\ Test ODE with local variables.\n"
"\n"
"ANEW TASK-TEST_ODE_LOCALS\n"
"\n"
"METHOD  TEST.SUM:\n"
"\n"
":CLASS  OB.TEST.LOCALS  <SUPER  OBJECT\n"
"    \n"
"    iv.long   tl-data\n"
"    \n"
":M   TEST.SUM:  {  lv1  lv2  |  sum   --  }\n"
"    >newline\n"
"    .\" lv1 = \" lv1 . cr\n"
"    .\" lv2 = \" lv2 . cr\n"
"    lv1 lv2  + -> sum\n"
"    .\" sum = \" sum . cr\n"
"    sum iv=> tl-data\n"
";M\n"
"\n"
"\n"
":M PRINT:\n"
"    .\" tl-data = \" tl-data . cr\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\n"
"ob.test.locals   tl-1\n"
"\n"
": test.method.locs  ( --- )\n"
"    4  5  test.sum: tl-1\n"
"    print: tl-1\n"
";\n"
"\n"
": (test.loc.binding)  { lv1 lv2  tlobj  --  }\n"
"    cr\n"
"    .\" Old style late binding ---\" cr\n"
"    lv1 lv2 tlobj   test.sum: []\n"
"    tlobj print: []\n"
"    .\" Local binding ---\" cr\n"
"    lv1 lv2  test.sum: tlobj\n"
"    print: tlobj\n"
";\n"
"\n"
": test.loc.binding  ( -- )\n"
"    6 7 tl-1  (test.loc.binding)\n"
";\n"
"\n";

const char* test_ode_locals_fth = (const char*) temp_binary_data_76;

//================== time.fth ==================
static const unsigned char temp_binary_data_77[] =
"\\ Device independant TIME handling.\n"
"\\ These words are vectored to allow a composer to change the notion\n"
"\\ of time in HMSL.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.\n"
"\\ All Rights Reserved\n"
"\\\n"
"\\ MOD: PLB 10/14/87 Added calls to HARD.TIME.INIT and TERM\n"
"\\ MOD: PLB 11/16/89 Add RATE->MICS/BEAT\n"
"\\ MOD: PLB 11/17/89  Big changes.\n"
"\\        Removed TIME-BASE  HARD.TIME@ SOFT.TIME@ .\n"
"\\        TIME@ TIME! and TIME+! are now deferred!!\n"
"\\        Default is ahead.time , time-advance set to zero.\n"
"\\ MOD: PLB 2/9/90 Added VTIME.SAVE stuff from SES\n"
"\\ MOD: PLB 3/18/90 Add DELAY\n"
"\\ MOD: PLB 4/13/90 Change AO.REPEAT to SELF.CLOCK\n"
"\\ MOD: PLB 6/7/90 Fixed Stack for delay.\n"
"\\ MOD: PLB 1/2/91 Changed DELAY , no abort, BUMPS vtime with MAX\n"
"\\ MOD: PLB 2/7/91 Set defaults for TIME@ TIME! and TIME+!\n"
"\\ MOD: PLB 4/9/91 Set default for TIME@ to FALSE\n"
"\\ MOD: PLB 7/1/91 Comment out SYS.INIT so that MIDI can INIT when ready.\n"
"\\ MOD: PLB 2/18/92 Add SYS.TASK\n"
"\n"
"ANEW TASK-TIME\n"
"\n"
"defer TIME@\n"
"' false is time@\n"
"defer TIME!\n"
"' drop is time!\n"
"defer TIME+!\n"
"' drop is time+!\n"
"\n"
": TIME+1  ( -- , used by software clocks )\n"
"    1 time+!\n"
";\n"
"\n"
"\\ This word is used to decide if it's time for an event.\n"
"\\ It compares the time on the stack to the current time.\n"
"max-inline @ 12 max-inline !\n"
": TIME> ( time1 time2 -- flag , use circular number system )\n"
"    - 0> both\n"
";\n"
": TIME< ( time1 time2 -- flag )\n"
"    - 0< both\n"
";\n"
"max-inline !\n"
"\n"
": DOITNOW? ( atime -- flag , true if time is now or past)\n"
"     dup time-virtual !\n"
"     time@ time> not  ( careful with changing this word, subtle )\n"
";\n"
"\n"
": VTIME@ ( -- virtual_time )\n"
"    time-virtual @\n"
";\n"
"\n"
": VTIME! ( virtual_time -- )\n"
"    time-virtual !\n"
";\n"
"\n"
": VTIME+! ( N -- )\n"
"    time-virtual +!\n"
";\n"
"\n"
": AHEAD.TIME@ ( -- time , give time ahead of RTC )\n"
"      rtc.time@ time-advance @ +\n"
";\n"
"\n"
": AHEAD.TIME! ( time -- , set ahead time )\n"
"      time-advance @ - 0 max rtc.time!\n"
";\n"
"\n"
": ANOW  ( -- , set virtual time to be advance time )\n"
"    time@ vtime!\n"
";\n"
"\n"
": RNOW ( -- , set virtual time to be real time )\n"
"    rtc.time@ vtime!\n"
";\n"
"\n"
"\\ Reserve for self incrementing clock.\n"
"defer SELF.CLOCK ( function to call each cycle of HMSL scheduler)\n"
"\n"
": USE.SELF.TIMER  ( -- , advance time as HMSL scans )\n"
"    rtc.stop\n"
"    'c time+1 is self.clock\n"
";\n"
"\n"
": USE.HARDWARE.TIMER ( -- , Use HARDWARE timer )\n"
"    rtc.start\n"
"    'c noop is self.clock\n"
";\n"
"\n"
": USE.SOFTWARE.TIMER ( -- , Use SOFTWARE timer )\n"
"    rtc.stop\n"
"    'c noop is self.clock\n"
";\n"
"\n"
": 0TIME  ( -- zero out timer variables )\n"
"    0 rtc.time!\n"
"    0 time-virtual !\n"
";\n"
"\n"
"32 constant VTIME_SMAX\n"
"CREATE VTIME-DATA vtime_smax cell* allot\n"
"\n"
"stack.header vtime-stack\n"
"\n"
": VTIME.PUSH  ( vtime -- , push onto time stack )\n"
"    vtime-stack stack.push\n"
";\n"
": VTIME.POP ( -- vtime )\n"
"    vtime-stack stack.pop\n"
";\n"
"\n"
": VTIME.SAVE  ( -- , save current virtual time , PUSH)\n"
"    vtime@ vtime.push\n"
";\n"
": VTIME.RESTORE ( -- , restore from stack , POP)\n"
"    vtime.pop vtime!\n"
";\n"
"\n"
": VTIME.COPY ( -- , copy from vtime stack , COPY)\n"
"    vtime-stack stack.copy vtime!\n"
";\n"
": VTIME.DROP ( -- , drop from vtime stack )\n"
"    vtime-stack stack.drop\n"
";\n"
"\n"
": TIME.INIT ( -- , initialize vectors )\n"
"    \" TIME.INIT\" debug.type\n"
"    0 time-current !\n"
"    rtc.init\n"
"    'c ahead.time! is time!\n"
"    'c ahead.time@ is time@\n"
"    'c rtc.time+!  is time+!\n"
"    'c noop is self.clock\n"
"    rtc.rate@ time-advance !\n"
"    rtc.rate@ 2* 3 / ticks/beat !\n"
"    anow\n"
"    vtime-data vtime_smax vtime-stack stack.setup\n"
";\n"
"\n"
": TIME.TERM  ( -- )\n"
"    \" TIME.TERM\" debug.type\n"
"    rtc.term\n"
";\n"
"\n"
": SYS.INIT sys.init time.init ;\n"
": SYS.TERM time.term sys.term ;\n"
"\n"
": WATCH ( -- )\n"
"    BEGIN\n"
"        time@ . cr\n"
"        ?terminal\n"
"    UNTIL\n"
";\n"
"\n"
": RATE->MICS/BEAT  ( ticks/second -- microseconds/beat )\n"
"    >r ticks/beat @ 1000000 r> */\n"
";\n"
"\n"
": DELAY  ( ticks -- , delay N ticks and advance VTIME )\n"
"\\ force VTIME to be N past now\n"
"    dup vtime@ rtc.time@ max + vtime!\n"
"    time@ +\n"
"    BEGIN dup time@ time<\n"
"    UNTIL drop\n"
";\n"
"\n"
"\n"
": ?DELAY  { ticks | flag -- flag , delay N ticks and advance VTIME }\n"
"\\ force VTIME to be N past now\n"
"    ticks vtime@ rtc.time@ max + vtime!\n"
"    ticks time@ +\n"
"    BEGIN dup time@ time<\n"
"        ?terminal dup -> flag\n"
"        OR\n"
"    UNTIL\n"
"    drop\n"
"    flag\n"
";\n"
"\n"
": SYS.TASK sys.task self.clock ;\n"
"\n";

const char* time_fth = (const char*) temp_binary_data_77;

//================== top.fth ==================
static const unsigned char temp_binary_data_78[] =
"\\ Host Dependant code for HMSL on Macintosh running H4th\n"
"\\\n"
"\\ Copyright 1987 - Phil Burk, Larry Polansky, David Rosenboom\n"
"\\ All Rights Reserved\n"
"\n"
"ANEW TASK-TOP\n"
"\n"
"\\ Open the HMSL window for graphics I/O\n"
"\n"
": HMSL.REFRESH ( -- , Refresh display )\n"
"    cg-current-screen @ ?dup\n"
"    IF draw: []\n"
"    THEN\n"
";\n"
"\n"
": HMSL.OPEN ( -- , open graphics window )\n"
"    hmsl-window @ 0=\n"
"    IF  gr.openhmsl\n"
"\\   ELSE .\" HMSL Window already open!\" cr\n"
"    THEN\n"
"\\   hmsl-window @ SelectWindow()\n"
";\n"
"\n"
": HMSL.CLOSE ( -- , close graphics window )\n"
"    hmsl-window @\n"
"    IF  cg-current-screen @ ?dup\n"
"        IF undraw: []\n"
"        THEN\n"
"        gr.closehmsl\n"
"    THEN\n"
"    menus.undraw\n"
";\n"
"\n"
": HMSL.1ST.DRAW ( -- , draw initial screen )\n"
"\\ On Mac, screen will get drawn when update event occurs!!!\n"
"\\ Before this it used to double draw.\n"
"    default-screen @ cg-current-screen !\n"
"    hmsl.refresh\n"
";\n"
"\n"
"if.forgotten hmsl.close\n";

const char* top_fth = (const char*) temp_binary_data_78;

//================== translators.fth ==================
static const unsigned char temp_binary_data_79[] =
"\\ Translators are used for converting from one numeric system to another.\n"
"\\ Examples might be converting a generic note index to a midi value in \n"
"\\ the key of D minor.  This would be a key translator. A scale translator\n"
"\\ would take a note index and return a pitch or period value for an\n"
"\\ instrument for a given tuning.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986 - David Rosenboom, Larry Polansky, Phil Burk.\n"
"\\\n"
"\\ MOD: PLB 10/21/86 Convert to new IV.LONG\n"
"\\ MOD: PLB 3/6/87 Changed starting offset for keys to 0.\n"
"\\ MOD: PLB 5/24/87 Add TRANSLATE function for custom translators.\n"
"\\ MOD: PLB 5/28/87 Add PRINT:\n"
"\\ MOD: PLB 10/30/90 Use Floored division in TRANSLATE: for rems>0\n"
"\n"
"ANEW TASK-TRANSLATORS\n"
"\n"
"\\ Declare methods.\n"
"METHOD TRANSLATE:\n"
"METHOD DETRANSLATE:\n"
"METHOD PUT.MODULUS:\n"
"METHOD GET.MODULUS:\n"
"METHOD PUT.TRANSLATE.FUNCTION:\n"
"METHOD GET.TRANSLATE.FUNCTION:\n"
"\n"
"\\ Definition of terms:\n"
"\\ TRANSLATE = Convert from an input value to an output value.\n"
"\\ DETRANSLATE = Perform the inverse function of the translate.\n"
"\\ OFFSET = value added to output before being returned.\n"
"\\ MODULUS = The length of the repeating pattern in the output.\n"
"\\    For western scales this might be 12 for 12 notes per octave.\n"
"\\ SIZE = Number of entries in the translation table, 7 for a minor scale.\n"
"\n"
"\\ The formula for translation may vary with the subclass of translator.\n"
"\\ Essentially they divide the input by the size,\n"
"\\ multiply the result by the modulus,\n"
"\\ and do a table lookup with the remainder of the division.\n"
"\\ Those two are then added.\n"
"\n"
"[NEED] FL/MOD\n"
": FL/MOD  ( n d -- rem quo )\n"
"    dup>r /mod over 0<\n"
"    IF 1- swap r@ + swap\n"
"    THEN\n"
"    rdrop\n"
";\n"
"[THEN]\n"
"[NEED] FL/\n"
": FL/ ( n d -- quo )\n"
"    fl/mod nip\n"
";\n"
"[THEN]\n"
"\n"
"\n"
":CLASS OB.TRANSLATOR <SUPER OB.ARRAY\n"
"    IV.LONG IV-TR-OFFSET\n"
"    IV.LONG IV-TR-MODULUS\n"
"    IV.LONG IV-TR-FUNCTION    ( Custom function for translation. )\n"
"\n"
":M INIT:\n"
"    init: super\n"
"    0 iv=> iv-tr-offset\n"
"    12 iv=> iv-tr-modulus\n"
"    0 iv=> iv-tr-function\n"
";M\n"
"\n"
":M PUT.OFFSET: ( offset -- , store value to add at end )\n"
"    iv=> iv-tr-offset\n"
";M\n"
":M GET.OFFSET: ( -- offset , fetch value to add at end )\n"
"    iv-tr-offset \n"
";M\n"
"\n"
":M PUT.MODULUS: ( modulus -- , store repeat length )\n"
"    iv=> iv-tr-modulus\n"
";M\n"
":M GET.MODULUS: ( -- modulus , fetch repeat length )\n"
"    iv-tr-modulus \n"
";M\n"
"\n"
":M PUT.TRANSLATE.FUNCTION: ( cfa -- , set custom translator )\n"
"( The custom translate function must have this stack diagram: )\n"
"( index translator -- value )\n"
"    iv=> iv-tr-function\n"
";M\n"
"\n"
":M GET.TRANSLATE.FUNCTION: ( -- cfa , get custom translator )\n"
"    iv-tr-function\n"
";M\n"
"\n"
":M TRANSLATE:  ( index -- value , translate index to a value )\n"
"    iv-tr-function ?dup\n"
"    IF  self swap -1 exec.stack? \\ should ( index trobj -- value )\n"
"    ELSE\n"
"        size: self fl/mod  ( r d )\n"
"        iv-tr-modulus *\n"
"        swap at.self +\n"
"        iv-tr-offset +\n"
"    THEN\n"
";M\n"
"\n"
":M DETRANSLATE: ( value -- [index] flag , reverse translate if valid output)\n"
"    get.offset: self -\n"
"    get.modulus: self /mod ( r d )\n"
"    size: self *\n"
"    swap indexof: self\n"
"    IF + true\n"
"    ELSE drop false\n"
"    THEN\n"
";M\n"
"\n"
":M PRINT: ( -- )\n"
"    print: super\n"
"    .\"  Offset   = \" iv-tr-offset . cr\n"
"    .\"  Modulus  = \" iv-tr-modulus . cr\n"
"    .\"  Function = \" iv-tr-function ?dup\n"
"    IF cfa->nfa id.\n"
"    ELSE 0 .\n"
"    THEN cr\n"
";M\n"
"\n"
";CLASS\n"
"\n"
"\\ There will be some predefined translators for certain keys.\n"
"OB.TRANSLATOR TR-CURRENT-KEY\n"
"\n"
"\\ This is too wierd and is considered obsolete.\n"
": TR.SET.KEY ( key_offset VN-1 VN-2 ... V0 N -- , Set key to use those values. )\n"
"    dup  new: tr-current-key\n"
"    stuff: tr-current-key\n"
"    put.offset: tr-current-key\n"
";\n"
"\n"
"\\ To set a key, enter something like:   TR_KEY_G# TR.MAJOR.KEY\n"
": MAJOR_SCALE  ( -- 0 2 4 5 7 9 11 )\n"
"    0 2 4 5 7 9 11\n"
";\n"
": HARMONIC_MINOR_SCALE ( -- 0 2 3 5 7 8 11 )\n"
"    0 2 3 5 7 8 11\n"
";\n"
": PENTATONIC_SCALE ( -- 0 2 4 5 7 9 11 )\n"
"    0 2 4 7 9\n"
";\n"
": HUNGARIAN_MINOR_SCALE ( -- 0 2 3 6 7 8 11 )\n"
"    0 2 3 6 7 8 11\n"
";\n"
": RUMANIAN_MINOR_SCALE ( -- 0 2 3 6 7 9 10 )\n"
"    0 2 3 6 7 9 10\n"
";\n"
"\n"
": TR.MAJOR.KEY  ( key_offset -- , set current key to major key )\n"
"    put.offset: tr-current-key\n"
"    stuff{ major_scale }stuff: tr-current-key\n"
";\n"
": TR.HARMONIC.MINOR  ( key_offset -- , set current key to minor key )\n"
"    put.offset: tr-current-key\n"
"    stuff{ harmonic_minor_scale }stuff: tr-current-key\n"
";\n"
"\n"
"\n"
"0  dup constant TR_KEY_C\n"
"1+ dup constant TR_KEY_C#\n"
"1+ dup constant TR_KEY_D\n"
"1+ dup constant TR_KEY_D#\n"
"1+ dup constant TR_KEY_E\n"
"1+ dup constant TR_KEY_F\n"
"1+ dup constant TR_KEY_F#\n"
"1+ dup constant TR_KEY_G\n"
"1+ dup constant TR_KEY_G#\n"
"1+ dup constant TR_KEY_A\n"
"1+ dup constant TR_KEY_A#\n"
"1+     constant TR_KEY_B\n"
"\n"
": TR.INDEX->KEY ( note_index -- note_in_key , )\n"
"    translate: tr-current-key\n"
";\n"
"\n"
"\\ Simple commands for playing notes in a specific key.\n"
": TR.MIDI.ON  ( index velocity -- , translate and turn note on )\n"
"    swap tr.index->key 36 +  ( offset to good midi start )\n"
"    swap midi.noteon\n"
";\n"
"\n"
": TR.MIDI.OFF  ( index velocity -- , translate and turn note off )\n"
"    swap tr.index->key 36 +\n"
"    swap midi.noteoff\n"
";\n"
"\n"
": TR.INIT ( -- , Initialize translators )\n"
"    tr_key_d tr.harmonic.minor\n"
";\n"
"\n"
": SYS.INIT sys.init tr.init ;\n"
": SYS.TERM free: tr-current-key sys.term ;\n";

const char* translators_fth = (const char*) temp_binary_data_79;

//================== utils.fth ==================
static const unsigned char temp_binary_data_80[] =
"\\ @(#) utils.fth 96/06/11 1.1\n"
"\\ General Utilities to support JForth & HMSL\n"
"\\ These utilities are useful words which are not likely to be\n"
"\\ supported by a typical Forth.  Words which some Forths support\n"
"\\ but some not, should be defined in XXX_BASE.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1986\n"
"\\\n"
"\\ MOD: PLB 11/9/86 Add SERVICE.TASKS/16\n"
"\\ MOD: PLB 3/2/87 Use abort\" in stack.check.\n"
"\\ MOD: PLB 4/29/87 Remove include? , change V: to VARIABLE\n"
"\\ MOD: PLB 9/3/87 Add DEBUG.TYPE\n"
"\\ MOD: PLB 5/17/91 Merged with ho:more_utils\n"
"\n"
"ANEW TASK-UTILS\n"
"\n"
"VARIABLE IF-DEBUG   ( debug trace flag )\n"
"VARIABLE IF-TESTING ( flag for loading test code )\n"
"\n"
": DEBUG.TYPE ( $string -- , type if debugging )\n"
"    if-debug @\n"
"    IF >newline count type space\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": ?MORE   ( count -- flag , pause every 20, true if \"Q\")\n"
"    20 mod 0=     dup\n"
"    IF drop\n"
"       .\" Q to quit, <CR> to continue ----\" CR\n"
"       KEY ascii q =\n"
"    THEN\n"
";\n"
"\n"
"\n"
"\\ Stack depth checking , useful for catching leftovers --------\n"
"VARIABLE STACK-HOLD\n"
": STACK.MARK  ( -- , record depth of stack )\n"
"    depth stack-hold !\n"
";\n"
": STACK.CHECK  ( -- , check to make sure stack hasn't been damaged )\n"
"    depth stack-hold @ = NOT\n"
"    IF  .\" Old stack depth = \" stack-hold @ .\n"
"        .s\n"
"        true abort\" STACK.CHECK - Change in stack depth!\"\n"
"    THEN\n"
";\n"
"\n"
"\n"
": $EQUAL  ( $string1 $string2 -- true_if_= , case insens. )\n"
"    >r count\n"
"    r> count 2 pick =\n"
"    IF text=?\n"
"    ELSE\n"
"        2drop drop false\n"
"    THEN\n"
";\n"
"\n"
"\n"
"hex\n"
": NFA.MOVE ( nfa addr -- , copy name field to address and fix like string )\n"
"    >r count 1f and ( n+1 c ,  remove immediate bit )\n"
"    dup r@ c! ( set length at pad )\n"
"    r> 1+ rot rot 0 ( a+1 n+1 c 0 )\n"
"    ?DO\n"
"        2dup c@ 7f and  ( remove flags from characters )\n"
"        swap c!\n"
"        1+ swap 1+ swap ( advance )\n"
"    LOOP 2drop\n"
";\n"
"\n"
": NFA->$ ( nfa -- $string , copy to pad )\n"
"    pad nfa.move pad\n"
";\n"
"decimal\n"
"\n"
"\\ Assistance for debugging.\n"
": BREAK ( -- , dump stack and allow abort )\n"
"    .s cr .\" BREAK - Enter A to abort\" cr\n"
"    key toupper ascii A =\n"
"    IF abort THEN\n"
";\n"
"\n"
": BREAK\" ( xxxx\" -- , give message and break )\n"
"    [compile] .\"\n"
"    compile break\n"
"; immediate\n"
"\n"
"\\ ?terminal that only happens so often to avoid slowing down system\n"
"V: ?term-count\n"
": ?TERMINAL/64  ( -- key? , true if key pressed, sometimes )\n"
"    ?term-count @ dup\n"
"    1+ 63 AND ?term-count !\n"
"    0= IF ?terminal\n"
"    ELSE false\n"
"    THEN\n"
";\n"
": ?TERMINAL/8  ( -- key? , true if key pressed, sometimes )\n"
"    ?term-count @ dup\n"
"    1+ 7 AND ?term-count !\n"
"    0= IF ?terminal\n"
"    ELSE false\n"
"    THEN\n"
";\n"
"\n"
"\\ Range checking and clipping tools.\n"
": INRANGE? ( n lo hi -- flag , Is LO <= N <= HI ? )\n"
"    2 pick <\n"
"    IF 2drop false\n"
"    ELSE >=\n"
"    THEN\n"
";\n"
"\n"
": CLIPTO ( n lo hi -- nclipped , clip N to range )\n"
"    >r max r> min\n"
";\n"
"\n"
": BAD.CHAR? ( CHAR -- FLAG , true if non printing)\n"
"    32 126 inrange? not\n"
";\n"
"\n"
": SAFE.EMIT ( char -- , emit if safe or '.' )\n"
"    dup bad.char?\n"
"    IF drop ascii . emit\n"
"    ELSE emit\n"
"    THEN\n"
";\n"
"\n"
": BAD.STR? ( addr count -- , scan string for bad chars)\n"
"    0\n"
"    ?DO  dup i + c@ bad.char?\n"
"        IF  cr dup i + dup h. c@ h.\n"
"        THEN\n"
"    LOOP drop\n"
";\n"
"\n"
": Y/N  ( -- , ask for key )\n"
"    BEGIN\n"
"        .\" (y/n) \" key dup emit tolower\n"
"        dup [char] y = over [char] n = or 0=\n"
"    WHILE drop cr\n"
"    REPEAT [char] y =\n"
";\n"
"\n"
": Y/N/Q  ( -- true_if_y , ask for key , abort on 'Q')\n"
"    BEGIN\n"
"        .\" (y/n/q) \" key dup emit tolower\n"
"        dup [char] q =\n"
"        IF cr abort\n"
"        THEN\n"
"        dup [char] y = over [char] n = or 0=\n"
"    WHILE drop cr\n"
"    REPEAT [char] y =\n"
";\n"
"\n";

const char* utils_fth = (const char*) temp_binary_data_80;

//================== clone.fth ==================
static const unsigned char temp_binary_data_81[] =
"\\ @(#) clone.fth 97/12/10 1.1\n"
"\\ Clone for PForth\n"
"\\\n"
"\\ Create the smallest dictionary required to run an application.\n"
"\\\n"
"\\ Clone decompiles the Forth dictionary starting with the top\n"
"\\ word in the program.  It then moves all referenced secondaries\n"
"\\ into a new dictionary.\n"
"\\\n"
"\\ This work was inspired by the CLONE feature that Mike Haas wrote\n"
"\\ for JForth.  Mike's CLONE disassembled 68000 machine code then\n"
"\\ reassembled it which is much more difficult.\n"
"\\\n"
"\\ Copyright Phil Burk & 3DO 1994\n"
"\\\n"
"\\ O- trap custom 'C' calls\n"
"\\ O- investigate ALITERAL, XLITERAL, use XLITERAL in [']\n"
"\n"
"anew task-clone.fth\n"
"decimal\n"
"\n"
"\\ move to 'C'\n"
": PRIMITIVE? ( xt -- flag , true if primitive )\n"
"    ['] FIRST_COLON <\n"
";\n"
"\n"
": 'SELF ( -- xt , return xt of word being compiled )\n"
"    ?comp\n"
"    latest name>\n"
"    [compile] literal\n"
"; immediate\n"
"\n"
"\n"
":struct CL.REFERENCE\n"
"    long  clr_OriginalXT    \\ original XT of word\n"
"    long  clr_NewXT         \\ corresponding XT in cloned dictionary\n"
"    long  clr_TotalSize     \\ size including data in body\n"
";struct\n"
"\n"
"variable CL-INITIAL-REFS \\ initial number of refs to allocate\n"
"100 cl-initial-refs !\n"
"variable CL-REF-LEVEL    \\ level of threading while scanning\n"
"variable CL-NUM-REFS     \\ number of secondaries referenced\n"
"variable CL-MAX-REFS     \\ max number of secondaries allocated\n"
"variable CL-LEVEL-MAX    \\ max level reached while scanning\n"
"variable CL-LEVEL-ABORT  \\ max level before aborting\n"
"10 cl-level-abort !\n"
"variable CL-REFERENCES   \\ pointer to cl.reference array\n"
"variable CL-TRACE        \\ print debug stuff if true\n"
"\n"
"\\ Cloned dictionary builds in allocated memory but XTs are relative\n"
"\\ to normal code-base, if CL-TEST-MODE true.\n"
"variable CL-TEST-MODE\n"
"\n"
"variable CL-INITIAL-DICT \\ initial size of dict to allocate\n"
"20 1024 * cl-initial-dict !\n"
"variable CL-DICT-SIZE    \\ size of allocated cloned dictionary\n"
"variable CL-DICT-BASE    \\ pointer to virtual base of cloned dictionary\n"
"variable CL-DICT-ALLOC   \\ pointer to allocated dictionary memory\n"
"variable CL-DICT-PTR     \\ rel pointer index into cloned dictionary\n"
"0 cl-dict-base !\n"
"\n"
"\n"
": CL.INDENT ( -- )\n"
"    cl-ref-level @ 2* 2* spaces\n"
";\n"
": CL.DUMP.NAME ( xt -- )\n"
"    cl.indent\n"
"    >name id. cr\n"
";\n"
"\n"
": CL.DICT[] ( relptr -- addr )\n"
"    cl-dict-base @ +\n"
";\n"
"\n"
": CL,  ( cell -- , comma into clone dictionary )\n"
"    cl-dict-ptr @ cl.dict[] !\n"
"    cell cl-dict-ptr +!\n"
";\n"
"\n"
"\n"
": CL.FREE.DICT ( -- , free dictionary we built into )\n"
"    cl-dict-alloc @ ?dup\n"
"    IF\n"
"        free dup ?error\n"
"        0 cl-dict-alloc !\n"
"    THEN\n"
";\n"
"\n"
": CL.FREE.REFS ( -- , free dictionary we built into )\n"
"    cl-references @ ?dup\n"
"    IF\n"
"        free dup ?error\n"
"        0 cl-references !\n"
"    THEN\n"
";\n"
"\n"
": CL.ALLOC.REFS ( --  , allocate references to track )\n"
"    cl-initial-refs @  \\ initial number of references\n"
"    dup cl-max-refs ! \\ maximum allowed\n"
"    sizeof() cl.reference *\n"
"    allocate dup ?error\n"
"    cl-references !\n"
";\n"
"\n"
": CL.RESIZE.REFS ( -- , allocate references to track )\n"
"    cl-max-refs @   \\ current number of references allocated\n"
"    5 * 4 / dup cl-max-refs ! \\ new maximum allowed\n"
"\\ cl.indent .\" Resize # references to \" dup . cr\n"
"    sizeof() cl.reference *\n"
"    cl-references @ swap resize dup ?error\n"
"    cl-references !\n"
";\n"
"\n"
"\n"
": CL.ALLOC.DICT ( -- , allocate dictionary to build into )\n"
"    cl-initial-dict @  \\ initial dictionary size\n"
"    dup cl-dict-size !\n"
"    allocate dup ?error\n"
"    cl-dict-alloc !\n"
"\\\n"
"\\ kludge dictionary if testing\n"
"    cl-test-mode @\n"
"    IF\n"
"        cl-dict-alloc @ code-base @ - cl-dict-ptr +!\n"
"        code-base @ cl-dict-base !\n"
"    ELSE\n"
"        cl-dict-alloc @  cl-dict-base !\n"
"    THEN\n"
"    .\" CL.ALLOC.DICT\" cr\n"
"    .\"   cl-dict-alloc = $\" cl-dict-alloc @ .hex cr\n"
"    .\"   cl-dict-base  = $\" cl-dict-base @ .hex cr\n"
"    .\"   cl-dict-ptr   = $\" cl-dict-ptr @ .hex cr\n"
";\n"
"\n"
": CODEADDR>DATASIZE { code-addr -- datasize }\n"
"\\ Determine size of any literal data following execution token.\n"
"\\ Examples are text following (.\"), or branch offsets.\n"
"    code-addr @\n"
"    CASE\n"
"    ['] (literal) OF cell ENDOF   \\ a number\n"
"    ['] 0branch   OF cell ENDOF   \\ branch offset\n"
"    ['] branch    OF cell ENDOF\n"
"    ['] (do)      OF    0 ENDOF\n"
"    ['] (?do)     OF cell ENDOF\n"
"    ['] (loop)    OF cell ENDOF\n"
"    ['] (+loop)   OF cell ENDOF\n"
"    ['] (.\")      OF code-addr cell+ c@ 1+ ENDOF  \\ text\n"
"    ['] (s\")      OF code-addr cell+ c@ 1+ ENDOF\n"
"    ['] (c\")      OF code-addr cell+ c@ 1+ ENDOF\n"
"    0 swap\n"
"    ENDCASE\n"
";\n"
"\n"
": XT>SIZE  ( xt -- wordsize , including code and data )\n"
"    dup >code\n"
"    swap >name\n"
"    dup latest =\n"
"    IF\n"
"        drop here\n"
"    ELSE\n"
"        dup c@ 1+ + aligned 8 + \\ get next name\n"
"        name> >code \\ where is next word\n"
"    THEN\n"
"    swap -\n"
";\n"
"\n"
"\\ ------------------------------------------------------------------\n"
": CL.TRAVERSE.SECONDARY { code-addr ca-process | xt dsize --  }\n"
"\\ scan secondary and pass each code-address to ca-process\n"
"\\ CA-PROCESS ( code-addr -- , required stack action for vector )\n"
"    1 cl-ref-level +!\n"
"    cl-ref-level @ cl-level-abort @ > abort\" Clone exceeded CL-ABORT-LEVEL\"\n"
"    BEGIN\n"
"        code-addr @ -> xt\n"
"\\ cl.indent .\" CL.TRAVERSE.SECONDARY - code-addr = $\" code-addr .hex .\" , xt = $\" xt .hex cr\n"
"        code-addr codeaddr>datasize -> dsize      \\ any data after this?\n"
"        code-addr ca-process execute              \\ process it\n"
"        code-addr cell+ dsize + aligned -> code-addr  \\ skip past data\n"
"\\ !!! Bummer! EXIT called in middle of secondary will cause early stop.\n"
"        xt  ['] EXIT  =                           \\ stop when we get to EXIT\n"
"    UNTIL\n"
"    -1 cl-ref-level +!\n"
";\n"
"\n"
"\\ ------------------------------------------------------------------\n"
"\n"
": CL.DUMP.XT ( xt -- )\n"
"    cl-trace @\n"
"    IF\n"
"        dup primitive?\n"
"        IF   .\" PRI:  \"\n"
"        ELSE .\" SEC:  \"\n"
"        THEN\n"
"        cl.dump.name\n"
"    ELSE\n"
"        drop\n"
"    THEN\n"
";\n"
"\n"
"\\ ------------------------------------------------------------------\n"
": CL.REF[] ( index -- clref )\n"
"    sizeof() cl.reference *\n"
"    cl-references @ +\n"
";\n"
"\n"
": CL.DUMP.REFS ( -- , print references )\n"
"    cl-num-refs @ 0\n"
"    DO\n"
"        i 3 .r .\"  : \"\n"
"        i cl.ref[]\n"
"        dup s@ clr_OriginalXT >name id. .\"  => \"\n"
"        dup s@ clr_NewXT .\n"
"        .\" , size = \"\n"
"        dup s@ clr_TotalSize . cr\n"
"        drop \\ clref\n"
"    loop\n"
";\n"
"\n"
": CL.XT>REF_INDEX { xt | indx flag -- index flag , true if found }\n"
"    BEGIN\n"
"\\ cl.indent .\" CL.XT>REF_INDEX - indx = \" indx . cr\n"
"        indx cl-num-refs @ >=\n"
"        IF\n"
"            true\n"
"        ELSE\n"
"            indx cl.ref[] s@ clr_OriginalXT\n"
"\\ cl.indent .\" CL.XT>REF_INDEX - clr_OriginalXT = \" dup . cr\n"
"            xt  =\n"
"            IF\n"
"                true\n"
"                dup -> flag\n"
"            ELSE\n"
"                false\n"
"                indx 1+ -> indx\n"
"            THEN\n"
"        THEN\n"
"    UNTIL\n"
"    indx flag\n"
"\\ cl.indent .\" CL.XT>REF_INDEX - \" xt >name id. space  indx . flag . cr\n"
";\n"
"\n"
": CL.ADD.REF  { xt | clref -- , add referenced secondary to list }\n"
"    cl-references @ 0= abort\" CL.ADD.REF - References not allocated!\"\n"
"\\\n"
"\\ do we need to allocate more room?\n"
"    cl-num-refs @ cl-max-refs @ >=\n"
"    IF\n"
"        cl.resize.refs\n"
"    THEN\n"
"\\\n"
"    cl-num-refs @ cl.ref[] -> clref    \\ index into array\n"
"    xt clref s! clr_OriginalXT\n"
"    0 clref s! clr_NewXT\n"
"    xt xt>size clref s! clr_TotalSize\n"
"\\\n"
"    1 cl-num-refs +!\n"
";\n"
"\n"
"\\ ------------------------------------------------------------------\n"
"\n"
"\\ called by cl.traverse.secondary to compile each piece of secondary\n"
": CL.RECOMPILE.SECONDARY { code-addr | xt clref dsize -- ,  }\n"
"\\ recompile to new location\n"
"\\ cl.indent .\" CL.RECOMPILE.SECONDARY - enter - \" .s cr\n"
"    code-addr @ -> xt\n"
"\\ cl.indent .\" CL.RECOMPILE.SECONDARY - xt = $\" dup .hex dup >name id. cr\n"
"    xt cl.dump.xt\n"
"    xt primitive?\n"
"    IF\n"
"        xt cl,\n"
"    ELSE\n"
"        xt CL.XT>REF_INDEX\n"
"        IF\n"
"            cl.ref[] -> clref\n"
"            clref s@ clr_NewXT\n"
"            dup 0= abort\" CL.RECOMPILE.SECONDARY - unresolved NewXT\"\n"
"            cl,\n"
"        ELSE\n"
"            cl.indent .\" CL.RECOMPILE.SECONDARY - xt not in ref table!\" cr\n"
"            abort\n"
"        THEN\n"
"    THEN\n"
"\\\n"
"\\ transfer any literal data\n"
"    code-addr codeaddr>datasize -> dsize\n"
"    dsize 0>\n"
"    IF\n"
"\\ cl.indent .\" CL.RECOMPILE.SECONDARY - copy inline data of size\" dsize . cr\n"
"        code-addr cell+  cl-dict-ptr @ cl.dict[]  dsize  move\n"
"        cl-dict-ptr @ dsize + aligned cl-dict-ptr !\n"
"    THEN\n"
"\\ cl.indent .\" CL.RECOMPILE.SECONDARY - leave - \" .s cr\n"
";\n"
"\n"
": CL.RECOMPILE.REF { indx | clref codesize datasize -- }\n"
"\\ all references have been resolved so recompile new secondary\n"
"    depth >r\n"
"    indx cl.ref[] -> clref\n"
"    cl-trace @\n"
"    IF\n"
"        cl.indent\n"
"        clref s@ clr_OriginalXT >name id. .\"  recompiled at $\"\n"
"        cl-dict-ptr @ .hex cr    \\ new address\n"
"    THEN\n"
"    cl-dict-ptr @  clref s! clr_NewXT\n"
"\\\n"
"\\ traverse this secondary and compile into new dictionary\n"
"    clref s@ clr_OriginalXT\n"
"    >code ['] cl.recompile.secondary cl.traverse.secondary\n"
"\\\n"
"\\ determine whether there is any data following definition\n"
"    cl-dict-ptr @\n"
"    clref s@ clr_NewXT - -> codesize \\ size of cloned code\n"
"    clref s@ clr_TotalSize \\ total bytes\n"
"    codesize - -> datasize\n"
"    cl-trace @\n"
"    IF\n"
"        cl.indent\n"
"        .\" Move data: data size = \" datasize . .\" codesize = \" codesize . cr\n"
"    THEN\n"
"\\\n"
"\\ copy any data that followed definition\n"
"    datasize 0>\n"
"    IF\n"
"        clref s@ clr_OriginalXT >code codesize +\n"
"        clref s@ clr_NewXT cl-dict-base @ + codesize +\n"
"        datasize move\n"
"        datasize cl-dict-ptr +!  \\ allot space in clone dictionary\n"
"    THEN\n"
"\n"
"    depth r> - abort\" Stack depth change in CL.RECOMPILE.REF\"\n"
";\n"
"\n"
"\\ ------------------------------------------------------------------\n"
": CL.SCAN.SECONDARY ( code-addr -- , scan word and add referenced secondaries to list )\n"
"    depth 1- >r\n"
"\\ cl.indent .\" CL.SCAN.SECONDARY - enter - \" .s cr\n"
"    cl-ref-level @ cl-level-max @  MAX cl-level-max !\n"
"    @ ( get xt )\n"
"\\ cl.indent .\" CL.SCAN.SECONDARY - xt = \" dup . dup >name id. cr\n"
"    dup cl.dump.xt\n"
"    dup primitive?\n"
"    IF\n"
"        drop\n"
"\\ cl.indent .\" CL.SCAN.SECONDARY - found primitive.\" cr\n"
"    ELSE\n"
"        dup CL.XT>REF_INDEX\n"
"        IF\n"
"            drop \\ indx   \\ already referenced once so ignore\n"
"            drop \\ xt\n"
"        ELSE\n"
"            >r \\ indx\n"
"            dup cl.add.ref\n"
"            >code 'self cl.traverse.secondary   \\ use 'self for recursion!\n"
"            r> cl.recompile.ref    \\ now that all refs resolved, recompile\n"
"        THEN\n"
"    THEN\n"
"\\ cl.indent .\" CL.SCAN.SECONDARY - leave - \" .s cr\n"
"    depth r> - abort\" Stack depth change in CL.SCAN.SECONDARY\"\n"
";\n"
"\n"
": CL.CLONE.XT ( xt -- , scan top word and add referenced secondaries to list )\n"
"    dup primitive? abort\" Cannot CLONE a PRIMITIVE word!\"\n"
"    0 cl-ref-level !\n"
"    0 cl-level-max !\n"
"    0 cl-num-refs !\n"
"    dup cl.add.ref     \\ word being cloned is top of ref list\n"
"    >code ['] cl.scan.secondary cl.traverse.secondary\n"
"    0 cl.recompile.ref\n"
";\n"
"\n"
"\\ ------------------------------------------------------------------\n"
": CL.XT>NEW_XT ( xt -- xt' , convert normal xt to xt in cloned dict )\n"
"    cl.xt>ref_index 0= abort\" not in cloned dictionary!\"\n"
"    cl.ref[] s@ clr_NewXT\n"
";\n"
": CL.XT>NEW_ADDR ( xt -- addr , addr in cloned dict )\n"
"    cl.xt>New_XT\n"
"    cl-dict-base @ +\n"
";\n"
"\n"
": CL.REPORT ( -- )\n"
"    .\" Clone scan went \" cl-level-max @ . .\" levels deep.\" cr\n"
"    .\" Clone scanned \" cl-num-refs @ . .\" secondaries.\" cr\n"
"    .\" New dictionary size =  \" cl-dict-ptr @ cl-dict-base @ - . cr\n"
";\n"
"\n"
"\n"
"\\ ------------------------------------------------------------------\n"
": CL.TERM ( -- , cleanup )\n"
"    cl.free.refs\n"
"    cl.free.dict\n"
";\n"
"\n"
": CL.INIT ( -- )\n"
"    cl.term\n"
"    0 cl-dict-size !\n"
"    ['] first_colon cl-dict-ptr !\n"
"    cl.alloc.dict\n"
"    cl.alloc.refs\n"
";\n"
"\n"
": 'CLONE ( xt -- , clone dictionary from this word )\n"
"    cl.init\n"
"    cl.clone.xt\n"
"    cl.report\n"
"    cl.dump.refs\n"
"    cl-test-mode @\n"
"    IF .\" WARNING - CL-TEST-MODE on so we can't save cloned image.\" cr\n"
"    THEN\n"
";\n"
"\n"
": SAVE-CLONE  ( <filename> -- )\n"
"    bl word\n"
"    .\" Save cloned image in \" dup count type\n"
"    drop .\" SAVE-CLONE unimplemented!\" \\ %Q\n"
";\n"
"\n"
": CLONE ( <name> -- )\n"
"    ' 'clone\n"
";\n"
"\n"
"if.forgotten cl.term\n"
"\n"
"\\ ---------------------------------- TESTS --------------------\n"
"\n"
"\n"
": TEST.CLONE ( -- )\n"
"    cl-test-mode @ not abort\" CL-TEST-MODE not on!\"\n"
"    0 cl.ref[] s@ clr_NewXT  execute\n"
";\n"
"\n"
"\n"
": TEST.CLONE.REAL ( -- )\n"
"    cl-test-mode @ abort\" CL-TEST-MODE on!\"\n"
"    code-base @\n"
"    0 cl.ref[] s@ clr_NewXT  \\ get cloned execution token\n"
"    cl-dict-base @ code-base !\n"
"\\ WARNING - code-base munged, only execute primitives or cloned code\n"
"    execute\n"
"    code-base !   \\ restore code base for normal\n"
";\n"
"\n"
"\n"
": TCL1\n"
"    34 dup +\n"
";\n"
"\n"
": TCL2\n"
"    .\" Hello \" tcl1  . cr\n"
";\n"
"\n"
": TCL3\n"
"    4 0\n"
"    DO\n"
"        tcl2\n"
"        i . cr\n"
"        i 100 + . cr\n"
"    LOOP\n"
";\n"
"\n"
"create VAR1 567 ,\n"
": TCL4\n"
"    345 var1 !\n"
"    .\" VAR1 = \" var1 @ . cr\n"
"    var1 @ 345 -\n"
"    IF\n"
"        .\" TCL4 failed!\" cr\n"
"    ELSE\n"
"        .\" TCL4 succeded! Yay!\" cr\n"
"    THEN\n"
";\n"
"\n"
"\\ do deferred words get cloned!\n"
"defer tcl.vector\n"
"\n"
": TCL.DOIT .\" Hello Fred!\" cr ;\n"
"' tcl.doit is tcl.vector\n"
"\n"
": TCL.DEFER\n"
"    12 . cr\n"
"    tcl.vector\n"
"    999 dup + . cr\n"
";\n"
"\n"
"trace-stack on\n"
"cl-test-mode on\n"
"\n";

const char* clone_fth = (const char*) temp_binary_data_81;

//================== dump_struct.fth ==================
static const unsigned char temp_binary_data_82[] =
"\\ @(#) dump_struct.fth 97/12/10 1.1\n"
"\\ Dump contents of structure showing values and member names.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1987 Phil Burk\n"
"\\ All Rights Reserved.\n"
"\\\n"
"\\ MOD: PLB 9/4/88 Print size too.\n"
"\\ MOD: PLB 9/9/88 Print U/S , add ADST\n"
"\\ MOD: PLB 12/6/90 Modified to work with H4th\n"
"\\ 941109 PLB Converted to pforth.  Added RP detection.\n"
"\\ 090609 PLB Convert >rel to use->rel and ..! to s!\n"
"\n"
"include? task-member.fth member.fth\n"
"include? task-c_struct c_struct.fth\n"
"\n"
"ANEW TASK-DUMP_STRUCT\n"
"\n"
": EMIT-TO-COLUMN ( char col -- )\n"
"    out @ - 0 max 80 min 0\n"
"    DO  dup emit\n"
"    LOOP drop\n"
";\n"
"\n"
"VARIABLE SN-FENCE\n"
": STACK.NFAS  ( fencenfa topnfa -- 0 nfa0 nfa1 ... )\n"
"\\ Fill stack with nfas of words until fence hit.\n"
"    >r sn-fence !\n"
"    0 r>  ( set terminator )\n"
"    BEGIN ( -- 0 n0 n1 ... top )\n"
"      dup sn-fence @ >\n"
"    WHILE\n"
"\\      dup n>link @   \\ JForth\n"
"       dup prevname   \\ HForth\n"
"    REPEAT\n"
"    drop\n"
";\n"
"\n"
": DST.DUMP.TYPE  ( +-size -- , dump data type, 941109)\n"
"    dup abs 4 =\n"
"    IF\n"
"        0<\n"
"        IF .\" RP\"\n"
"        ELSE .\" U4\"\n"
"        THEN\n"
"    ELSE\n"
"        dup 0<\n"
"            IF ascii U\n"
"            ELSE ascii S\n"
"            THEN emit abs 1 .r\n"
"    THEN\n"
";\n"
"\n"
": DUMP.MEMBER ( addr member-pfa -- , dump member of structure)\n"
"    ob.stats  ( -- addr offset size )\n"
"    >r + r> ( -- addr' size )\n"
"    dup ABS 4 >  ( -- addr' size flag )\n"
"    IF   cr 2dup swap . . ABS dump\n"
"    ELSE tuck @bytes 10 .r ( -- size )\n"
"        3 spaces dst.dump.type\n"
"    THEN\n"
";\n"
"\n"
"VARIABLE DS-ADDR\n"
": DUMP.STRUCT ( addr-data addr-structure -- )\n"
"    >newline swap >r  ( -- as , save addr-data for dumping )\n"
"\\    dup cell+ @ over +  \\ JForth\n"
"    dup code> >name swap cell+ @ over +   \\ HForth\n"
"    stack.nfas   ( fill stack with nfas of members )\n"
"    BEGIN\n"
"        dup\n"
"    WHILE   ( continue until non-zero )\n"
"        dup name> >body r@ swap dump.member\n"
"        bl 18 emit-to-column id. cr\n"
"        ?pause\n"
"    REPEAT drop rdrop\n"
";\n"
"\n"
": DST ( addr <name> -- , dump contents of structure )\n"
"    ob.findit\n"
"    state @\n"
"    IF [compile] literal compile dump.struct\n"
"    ELSE dump.struct\n"
"    THEN\n"
"; immediate\n"
"\n"
": ADST ( absolute_address -- , dump structure )\n"
"    use->rel [compile] dst     \\ mod 090609\n"
"; immediate\n"
"\n"
"\\ For Testing Purposes\n"
"false [IF]\n"
":STRUCT GOO\n"
"    LONG DATAPTR\n"
"    SHORT GOO_WIDTH\n"
"    USHORT GOO_HEIGHT\n"
";STRUCT\n"
"\n"
":STRUCT FOO\n"
"    LONG ALONG1\n"
"    STRUCT GOO AGOO\n"
"    SHORT ASHORT1\n"
"    BYTE ABYTE\n"
"    BYTE ABYTE2\n"
";STRUCT\n"
"\n"
"FOO AFOO\n"
": AFOO.INIT\n"
"    $ 12345678 afoo s! along1\n"
"    $ -665 afoo s! ashort1\n"
"    $ 21 afoo s! abyte\n"
"    $ 43 afoo s! abyte2\n"
"    -234 afoo .. agoo s! goo_height\n"
";\n"
"afoo.init\n"
"\n"
": TDS ( afoo -- )\n"
"    dst foo\n"
";\n"
"\n"
"[THEN]\n"
"\n";

const char* dump_struct_fth = (const char*) temp_binary_data_82;

//================== load_file.fth ==================
static const unsigned char temp_binary_data_83[] =
"\\ Load a file into an allocated memory image.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 3DO 1995\n"
"\n"
"anew task-load_file.fth\n"
"\n"
": $LOAD.FILE { $filename | fid numbytes numread err data -- data-addr 0 | 0 err }\n"
"    0 -> data\n"
"\\ open file\n"
"    $filename count r/o open-file -> err -> fid\n"
"    err\n"
"    IF\n"
"        .\" $LOAD.FILE - Could not open input file!\" cr\n"
"    ELSE\n"
"\\ determine size of file\n"
"        fid file-size -> err -> numbytes\n"
"        err\n"
"        IF\n"
"             .\" $LOAD.FILE - File size failed!\" cr\n"
"        ELSE\n"
"            .\" File size = \" numbytes . cr\n"
"\\ allocate memory for sample, when done free memory using FREE\n"
"            numbytes allocate -> err -> data\n"
"            err\n"
"            IF\n"
"                .\" $LOAD.FILE - Memory allocation failed!\" cr\n"
"            ELSE\n"
"\\ read data\n"
"                data numbytes fid read-file -> err\n"
"                .\" Read \" . .\" bytes from file \" $filename count type cr\n"
"            THEN\n"
"        THEN\n"
"        fid close-file drop\n"
"    THEN\n"
"    data err\n"
";\n"
"\n"
"\\ Example:   c\" myfile\" $load.file   abort\" Oops!\"   free .\n";

const char* load_file_fth = (const char*) temp_binary_data_83;

//================== make_all256.fth ==================
static const unsigned char temp_binary_data_84[] =
"\\ @(#) make_all256.fth 97/12/10 1.1\n"
"\\ Make a file with all possible 256 bytes in random order.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1987 Phil Burk\n"
"\\ All Rights Reserved.\n"
"\n"
"ANEW TASK-MAKE_ALL256\n"
"\n"
"variable RAND8-SEED\n"
"19 rand8-seed !\n"
": RANDOM8 ( -- r8 , generate random bytes, repeat every 256 )\n"
"    RAND8-SEED @\n"
"    77 * 55 +\n"
"    $ FF and\n"
"    dup RAND8-SEED !\n"
";\n"
"\n"
"create rand8-pad 256 allot\n"
": make.256.data\n"
"    256 0\n"
"    DO\n"
"        random8 rand8-pad i + c!\n"
"    LOOP\n"
";\n"
"\n"
": SHUFFLE.DATA { num | ind1 ind2 -- }\n"
"    num 0\n"
"    DO\n"
"        256 choose -> ind1\n"
"        256 choose -> ind2\n"
"        ind1 rand8-pad + c@\n"
"        ind2 rand8-pad + c@\n"
"        ind1 rand8-pad + c!\n"
"        ind2 rand8-pad + c!\n"
"    LOOP\n"
";\n"
"\n"
": WRITE.256.FILE   { | fid -- }\n"
"    p\" all256.raw\" count r/w create-file\n"
"    IF\n"
"        drop .\" Could not create file.\" cr\n"
"    ELSE\n"
"        -> fid\n"
"        fid . cr\n"
"        rand8-pad 256 fid write-file abort\" write failed!\"\n"
"        fid close-file drop\n"
"    THEN\n"
";\n"
"\n"
": MAKE.256.FILE\n"
"    make.256.data\n"
"    1000 shuffle.data\n"
"    write.256.file\n"
";\n"
"\n"
"MAKE.256.FILE\n";

const char* make_all256_fth = (const char*) temp_binary_data_84;

//================== ansilocs.fth ==================
static const unsigned char temp_binary_data_85[] =
"\\ @(#) ansilocs.fth 98/01/26 1.3\n"
"\\ local variable support words\n"
"\\ These support the ANSI standard (LOCAL) and TO words.\n"
"\\\n"
"\\ They are built from the following low level primitives written in 'C':\n"
"\\    (local@) ( i+1 -- n , fetch from ith local variable )\n"
"\\    (local!) ( n i+1 -- , store to ith local variable )\n"
"\\    (local.entry) ( num -- , allocate stack frame for num local variables )\n"
"\\    (local.exit)  ( -- , free local variable stack frame )\n"
"\\    local-compiler ( -- addr , variable containing CFA of locals compiler )\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\\\n"
"\\ 10/27/99 Fixed  : foo { -- } 55 ; was entering local frame but not exiting.\n"
"\n"
"anew task-ansilocs.fth\n"
"\n"
"private{\n"
"\n"
"decimal\n"
"16 constant LV_MAX_VARS    \\ maximum number of local variables\n"
"31 constant LV_MAX_CHARS   \\ maximum number of letters in name\n"
"\n"
"lv_max_vars lv_max_chars $array LV-NAMES\n"
"variable LV-#NAMES   \\ number of names currently defined\n"
"\n"
"\\ Search name table for match\n"
": LV.MATCH ( $string -- index true | $string false )\n"
"    0 swap\n"
"    lv-#names @ 0\n"
"    ?DO  i lv-names\n"
"        over $=\n"
"        IF  2drop true i LEAVE\n"
"        THEN\n"
"    LOOP swap\n"
";\n"
"\n"
": LV.COMPILE.FETCH  ( index -- )\n"
"    1+  \\ adjust for optimised (local@), LocalsPtr points above vars\n"
"    CASE\n"
"    1 OF compile (1_local@) ENDOF\n"
"    2 OF compile (2_local@) ENDOF\n"
"    3 OF compile (3_local@) ENDOF\n"
"    4 OF compile (4_local@) ENDOF\n"
"    5 OF compile (5_local@) ENDOF\n"
"    6 OF compile (6_local@) ENDOF\n"
"    7 OF compile (7_local@) ENDOF\n"
"    8 OF compile (8_local@) ENDOF\n"
"    dup [compile] literal compile (local@)\n"
"    ENDCASE\n"
";\n"
"\n"
": LV.COMPILE.STORE  ( index -- )\n"
"    1+  \\ adjust for optimised (local!), LocalsPtr points above vars\n"
"    CASE\n"
"    1 OF compile (1_local!) ENDOF\n"
"    2 OF compile (2_local!) ENDOF\n"
"    3 OF compile (3_local!) ENDOF\n"
"    4 OF compile (4_local!) ENDOF\n"
"    5 OF compile (5_local!) ENDOF\n"
"    6 OF compile (6_local!) ENDOF\n"
"    7 OF compile (7_local!) ENDOF\n"
"    8 OF compile (8_local!) ENDOF\n"
"    dup [compile] literal compile (local!)\n"
"    ENDCASE\n"
";\n"
"\n"
": LV.COMPILE.LOCAL  ( $name -- handled? , check for matching locals name )\n"
"\\ .\" LV.COMPILER.LOCAL name = \" dup count type cr\n"
"    lv.match\n"
"    IF ( index )\n"
"        lv.compile.fetch\n"
"        true\n"
"    ELSE\n"
"        drop false\n"
"    THEN\n"
";\n"
"\n"
": LV.CLEANUP ( -- , restore stack frame on exit from colon def )\n"
"    lv-#names @\n"
"    IF\n"
"        compile (local.exit)\n"
"    THEN\n"
";\n"
": LV.FINISH ( -- , restore stack frame on exit from colon def )\n"
"    lv.cleanup\n"
"    lv-#names off\n"
"    local-compiler off\n"
";\n"
"\n"
": LV.SETUP ( -- )\n"
"    0 lv-#names !\n"
";\n"
"\n"
": LV.TERM\n"
"    .\" Locals turned off\" cr\n"
"    lv-#names off\n"
"    local-compiler off\n"
";\n"
"\n"
"if.forgotten lv.term\n"
"\n"
"}private\n"
"\n"
": (LOCAL)  ( adr len -- , ANSI local primitive )\n"
"    dup\n"
"    IF\n"
"        lv-#names @ lv_max_vars >= abort\" Too many local variables!\"\n"
"        lv-#names @  lv-names place\n"
"\\ Warn programmer if local variable matches an existing dictionary name.\n"
"        lv-#names @  lv-names find nip\n"
"        IF\n"
"            .\" (LOCAL) - Note: \"\n"
"            lv-#names @  lv-names count type\n"
"            .\"  redefined as a local variable in \"\n"
"            latest id. cr\n"
"        THEN\n"
"        1 lv-#names +!\n"
"    ELSE\n"
"\\ Last local. Finish building local stack frame.\n"
"        2drop\n"
"        lv-#names @ dup 0=  \\ fixed 10/27/99, Thanks to John Providenza\n"
"        IF\n"
"            drop .\" (LOCAL) - Warning: no locals defined!\" cr\n"
"        ELSE\n"
"            [compile] literal   compile (local.entry)\n"
"            ['] lv.compile.local local-compiler !\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
"\n"
": VALUE\n"
"    CREATE ( n <name> )\n"
"        ,\n"
"        immediate\n"
"    DOES>\n"
"        state @\n"
"        IF\n"
"            [compile] aliteral\n"
"            compile @\n"
"        ELSE\n"
"            @\n"
"        THEN\n"
";\n"
"\n"
": TO  ( val <name> -- )\n"
"    bl word\n"
"    lv.match\n"
"    IF  ( -- index )\n"
"        lv.compile.store\n"
"    ELSE\n"
"        find\n"
"        1 = 0= abort\" TO or -> before non-local or non-value\"\n"
"        >body  \\ point to data\n"
"        state @\n"
"        IF  \\ compiling  ( -- pfa )\n"
"            [compile] aliteral\n"
"            compile !\n"
"        ELSE \\ executing  ( -- val pfa )\n"
"            !\n"
"        THEN\n"
"    THEN\n"
"; immediate\n"
"\n"
": ->  ( -- )  [compile] to  ; immediate\n"
"\n"
": +->  ( val <name> -- )\n"
"    bl word\n"
"    lv.match\n"
"    IF  ( -- index )\n"
"        1+  \\ adjust for optimised (local!), LocalsPtr points above vars\n"
"        [compile] literal compile (local+!)\n"
"    ELSE\n"
"        find\n"
"        1 = 0= abort\" +-> before non-local or non-value\"\n"
"        >body  \\ point to data\n"
"        state @\n"
"        IF  \\ compiling  ( -- pfa )\n"
"            [compile] aliteral\n"
"            compile +!\n"
"        ELSE \\ executing  ( -- val pfa )\n"
"            +!\n"
"        THEN\n"
"    THEN\n"
"; immediate\n"
"\n"
": :      lv.setup   : ;\n"
": ;      lv.finish  [compile] ;      ; immediate\n"
": exit   lv.cleanup  compile exit   ; immediate\n"
": does>  lv.finish  [compile] does>  ; immediate\n"
"\n"
"privatize\n";

const char* ansilocs_fth = (const char*) temp_binary_data_85;

//================== bench.fth ==================
static const unsigned char temp_binary_data_86[] =
"\\ @(#) bench.fth 97/12/10 1.1\n"
"\\ Benchmark Forth\n"
"\\ by Phil Burk\n"
"\\ 11/17/95\n"
"\\\n"
"\\ pForthV9 on Indy, compiled with gcc\n"
"\\  bench1  took 15 seconds\n"
"\\  bench2  took 16 seconds\n"
"\\  bench3  took 17 seconds\n"
"\\  bench4  took 17 seconds\n"
"\\  bench5  took 19 seconds\n"
"\\  sieve   took  4 seconds\n"
"\\\n"
"\\ Darren Gibbs reports that on an SGI Octane loaded with multiple users:\n"
"\\  bench1  took 2.8sec\n"
"\\  bench2  took 2.7\n"
"\\  bench3  took 2.9\n"
"\\  bench4  took 2.1\n"
"\\  bench 5 took 2.5\n"
"\\  seive   took .6\n"
"\\\n"
"\\ HForth on Mac Quadra 800, 68040\n"
"\\  bench1  took 1.73 seconds\n"
"\\  bench2  took 6.48 seconds\n"
"\\  bench3  took 2.65 seconds\n"
"\\  bench4  took 2.50 seconds\n"
"\\  bench5  took 1.91 seconds\n"
"\\  sieve   took 0.45 seconds\n"
"\\\n"
"\\ pForthV9 on Mac Quadra 800\n"
"\\  bench1  took 40 seconds\n"
"\\  bench2  took 43 seconds\n"
"\\  bench3  took 43 seconds\n"
"\\  bench4  took 44 seconds\n"
"\\  bench5  took 42 seconds\n"
"\\  sieve   took 20 seconds\n"
"\\\n"
"\\ pForthV9 on PB5300, 100 MHz PPC 603 based Mac Powerbook\n"
"\\  bench1  took 8.6 seconds\n"
"\\  bench2  took 9.0 seconds\n"
"\\  bench3  took 9.7 seconds\n"
"\\  bench4  took 8.8 seconds\n"
"\\  bench5  took 10.3 seconds\n"
"\\  sieve   took 2.3 seconds\n"
"\\\n"
"\\ HForth on PB5300\n"
"\\  bench1  took 1.1 seconds\n"
"\\  bench2  took 3.6 seconds\n"
"\\  bench3  took 1.7 seconds\n"
"\\  bench4  took 1.2 seconds\n"
"\\  bench5  took 1.3 seconds\n"
"\\  sieve   took 0.2 seconds\n"
"\n"
"anew task-bench.fth\n"
"\n"
"decimal\n"
"\n"
"\\ benchmark primitives\n"
"create #do 2000000   ,\n"
"\n"
": t1           #do @ 0      do                     loop ;\n"
": t2  23 45    #do @ 0      do  swap               loop   2drop ;\n"
": t3  23       #do @ 0      do  dup drop           loop drop ;\n"
": t4  23 45    #do @ 0      do  over drop          loop 2drop ;\n"
": t5           #do @ 0      do  23 45 + drop       loop ;\n"
": t6  23       #do @ 0      do  >r r>              loop drop ;\n"
": t7  23 45 67 #do @ 0      do  rot                loop 2drop drop ;\n"
": t8           #do @ 0      do  23 2* drop         loop  ;\n"
": t9           #do @ 10 / 0 do  23 5 /mod 2drop    loop ;\n"
": t10     #do  #do @ 0      do  dup @ drop         loop drop ;\n"
"\n"
": foo ( noop ) ;\n"
": t11          #do @ 0      do  foo                loop ;\n"
"\n"
"\\ more complex benchmarks -----------------------\n"
"\n"
"\\ BENCH1 - sum data ---------------------------------------\n"
"create data1 23 , 45 , 67 , 89 , 111 , 222 , 333 , 444 ,\n"
": sum.cells ( addr num -- sum )\n"
"    0 swap \\ sum\n"
"    0 DO\n"
"        over \\ get address\n"
"        i cells + @ +\n"
"    LOOP\n"
"    swap drop\n"
";\n"
"\n"
": bench1 ( -- )\n"
"    200000 0\n"
"    DO\n"
"        data1 8 sum.cells drop\n"
"    LOOP\n"
";\n"
"\n"
"\\ BENCH2 - recursive factorial --------------------------\n"
": factorial ( n -- n! )\n"
"    dup 1 >\n"
"    IF\n"
"        dup 1- recurse *\n"
"    ELSE\n"
"        drop 1\n"
"    THEN\n"
";\n"
"\n"
": bench2 ( -- )\n"
"    200000 0\n"
"    DO\n"
"        10 factorial drop\n"
"    LOOP\n"
";\n"
"\n"
"\\ BENCH3 - DEFER ----------------------------------\n"
"defer calc.answer\n"
": answer ( n -- m )\n"
"    dup +\n"
"    $ a5a5 xor\n"
"    1000 max\n"
";\n"
"' answer is calc.answer\n"
": bench3\n"
"    1500000 0\n"
"    DO\n"
"        i calc.answer drop\n"
"    LOOP\n"
";\n"
"\n"
"\\ BENCH4 - locals ---------------------------------\n"
": use.locals { x1 x2 | aa bb -- result }\n"
"    x1 2* -> aa\n"
"    x2 2/ -> bb\n"
"    x1 aa *\n"
"    x2 bb * +\n"
";\n"
"\n"
": bench4\n"
"    400000 0\n"
"    DO\n"
"        234 567 use.locals drop\n"
"    LOOP\n"
";\n"
"\n"
"\\ BENCH5 - string compare -------------------------------\n"
": match.strings { $s1 $s2 | adr1 len1 adr2 len2 -- flag }\n"
"    $s1 count -> len1 -> adr1\n"
"    $s2 count -> len2 -> adr2\n"
"    len1 len2 -\n"
"    IF\n"
"        FALSE\n"
"    ELSE\n"
"        TRUE\n"
"        len1 0\n"
"        DO\n"
"            adr1 i + c@\n"
"            adr2 i + c@ -\n"
"            IF\n"
"                drop FALSE\n"
"                leave\n"
"            THEN\n"
"        LOOP\n"
"    THEN\n"
";\n"
"\n"
": bench5 ( -- )\n"
"    60000 0\n"
"    DO\n"
"        \" This is a string. X foo\"\n"
"        \" This is a string. Y foo\" match.strings drop\n"
"    LOOP\n"
";\n"
"\n"
"\\ SIEVE OF ERATOSTHENES from BYTE magazine -----------------------\n"
"\n"
"DECIMAL 8190 CONSTANT TSIZE\n"
"\n"
"VARIABLE FLAGS TSIZE ALLOT\n"
"\n"
": <SIEVE>  ( --- #primes )  FLAGS TSIZE 1 FILL\n"
" 0  TSIZE 0\n"
" DO   ( n )  I FLAGS + C@\n"
"      IF    I  DUP +  3 +   DUP I +  (  I2*+3 I3*+3 )\n"
"           BEGIN  DUP TSIZE <  ( same flag )\n"
"           WHILE  0 OVER FLAGS + C! (  i' i'' )   OVER +\n"
"           REPEAT 2DROP  1+\n"
"      THEN\n"
" LOOP       ;\n"
"\n"
": SIEVE  .\" 10 iterations \" CR  0   10 0\n"
"  DO     <SIEVE> swap drop\n"
"  LOOP   . .\" primes \" CR ;\n"
"\n"
": SIEVE50  .\" 50 iterations \" CR  0   50 0\n"
"  DO     <SIEVE> swap drop\n"
"  LOOP   . .\" primes \" CR ;\n"
"\n"
"\\ 10 iterations\n"
"\\ 21.5 sec  Amiga Multi-Forth  Indirect Threaded\n"
"\\ 8.82 sec  Amiga 1000 running JForth\n"
"\\ ~5 sec  SGI Indy running pForthV9\n";

const char* bench_fth = (const char*) temp_binary_data_86;

//================== c_struct.fth ==================
static const unsigned char temp_binary_data_87[] =
"\\ @(#) c_struct.fth 98/01/26 1.2\n"
"\\ STRUCTUREs are for interfacing with 'C' programs.\n"
"\\ Structures are created using :STRUCT and ;STRUCT\n"
"\\\n"
"\\ This file must be loaded before loading any .J files.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\\\n"
"\\ MOD: PLB 1/16/87 Use abort\" instead of er.report\n"
"\\      MDH 4/14/87 Added sign-extend words to ..@\n"
"\\ MOD: PLB 9/1/87 Add pointer to last member for debug.\n"
"\\ MOD: MDH 4/30/88 Use fast addressing for ..@ and ..!\n"
"\\ MOD: PLB/MDH 9/30/88 Fixed offsets for 16@+long and 8@+long\n"
"\\        fixed OB.COMPILE.+@/! for 0 offset\n"
"\\ MOD: PLB 1/11/89 Added EVEN-UP in case of last member BYTE\n"
"\\ MOD: RDG 9/19/90 Added floating point member support\n"
"\\ MOD: PLB 12/21/90 Optimized ..@ and ..!\n"
"\\ 00001 PLB 11/20/91 Make structures IMMEDIATE with ALITERAL for speed\n"
"\\           Don't need MOVEQ.L  #0,D0 for 16@+WORD and 8@+WORD\n"
"\\ 00002 PLB 8/3/92 Added S@ and S!, and support for RPTR\n"
"\\ 951112 PLB Added FS@ and FS!\n"
"\\ This version for the pForth system.\n"
"\n"
"ANEW TASK-C_STRUCT\n"
"\n"
"decimal\n"
"\\ STRUCT ======================================================\n"
": <:STRUCT> ( pfa -- , run time action for a structure)\n"
"    [COMPILE] CREATE\n"
"        @ even-up here swap dup ( -- here # # )\n"
"        allot  ( make room for ivars )\n"
"        0 fill  ( initialize to zero )\n"
"\\       immediate \\ 00001\n"
"\\   DOES> [compile] aliteral \\ 00001\n"
";\n"
"\n"
"\\ Contents of a structure definition.\n"
"\\    CELL 0 = size of instantiated structures\n"
"\\    CELL 1 = #bytes to last member name in dictionary.\n"
"\\             this is relative so it will work with structure\n"
"\\             relocation schemes like MODULE\n"
"\n"
": :STRUCT (  -- , Create a 'C' structure )\n"
"\\ Check pairs\n"
"   ob-state @\n"
"   warning\" :STRUCT - Previous :STRUCT or :CLASS unfinished!\"\n"
"   ob_def_struct ob-state !     ( set pair flags )\n"
"\\\n"
"\\ Create new struct defining word.\n"
"  CREATE\n"
"      here ob-current-class !  ( set current )\n"
"      0 ,        ( initial ivar offset )\n"
"      0 ,        ( location for #byte to last )\n"
"   DOES>  <:STRUCT>\n"
";\n"
"\n"
": ;STRUCT ( -- , terminate structure )\n"
"   ob-state @ ob_def_struct = NOT\n"
"   abort\" ;STRUCT - Missing :STRUCT above!\"\n"
"   false ob-state !\n"
"\n"
"\\ Point to last member.\n"
"   latest ob-current-class @ body> >name -  ( byte difference of NFAs )\n"
"   ob-current-class @ cell+ !\n"
"\\\n"
"\\ Even up byte offset in case last member was BYTE.\n"
"   ob-current-class @ dup @ even-up swap !\n"
";\n"
"\n"
"\\ Member reference words.\n"
": ..   ( object <member> -- member_address , calc addr of member )\n"
"    ob.stats? drop state @\n"
"    IF   ?dup\n"
"         IF   [compile] literal compile +\n"
"         THEN\n"
"    ELSE +\n"
"    THEN\n"
"; immediate\n"
"\n"
"\n"
": (S+C!)  ( val addr offset -- )  + c! ;\n"
": (S+W!)  ( val addr  offset -- )  + w! ;\n"
": (S+!)  ( val addr offset -- )  + ! ;\n"
": (S+REL!)  ( ptr addr offset -- )  + >r if.use->rel r> ! ;\n"
"\n"
": compile+!bytes ( offset size -- )\n"
"    \\ .\" compile+!bytes ( \" over . dup . .\" )\" cr\n"
"    swap [compile] literal   \\ compile offset into word\n"
"    CASE\n"
"    cell OF compile (s+!)  ENDOF\n"
"    2 OF compile (s+w!)      ENDOF\n"
"    1 OF compile (s+c!)      ENDOF\n"
"    -cell OF compile (s+rel!)   ENDOF \\ 00002\n"
"    -2 OF compile (s+w!)     ENDOF\n"
"    -1 OF compile (s+c!)     ENDOF\n"
"    true abort\" s! - illegal size!\"\n"
"    ENDCASE\n"
";\n"
"\n"
": !BYTES ( value address size -- )\n"
"    CASE\n"
"    cell OF ! ENDOF\n"
"    -cell OF ( aptr addr )  swap if.use->rel swap ! ENDOF \\ 00002\n"
"    ABS\n"
"       2 OF w! ENDOF\n"
"       1 OF c! ENDOF\n"
"       true abort\" s! - illegal size!\"\n"
"    ENDCASE\n"
";\n"
"\n"
"\\ These provide ways of setting and reading members values\n"
"\\ without knowing their size in bytes.\n"
": (S!) ( offset size -- , compile proper fetch )\n"
"    state @\n"
"    IF  compile+!bytes\n"
"    ELSE ( -- value addr off size )\n"
"        >r + r> !bytes\n"
"    THEN\n"
";\n"
": S! ( value object <member> -- , store value in member )\n"
"    ob.stats?\n"
"    (s!)\n"
"; immediate\n"
"\n"
": @BYTES ( addr +/-size -- value )\n"
"    CASE\n"
"    cell OF @  ENDOF\n"
"       2 OF w@      ENDOF\n"
"       1 OF c@      ENDOF\n"
"      -cell OF @ if.rel->use      ENDOF \\ 00002\n"
"      -2 OF w@ w->s     ENDOF\n"
"      -1 OF c@ b->s     ENDOF\n"
"       true abort\" s@ - illegal size!\"\n"
"    ENDCASE\n"
";\n"
"\n"
": (S+UC@)  ( addr offset -- val )  + c@ ;\n"
": (S+UW@)  ( addr offset -- val )  + w@ ;\n"
": (S+@)  ( addr offset -- val )  + @ ;\n"
": (S+REL@)  ( addr offset -- val )  + @ if.rel->use ;\n"
": (S+C@)  ( addr offset -- val )  + c@ b->s ;\n"
": (S+W@)  ( addr offset -- val )  + w@ w->s ;\n"
"\n"
": compile+@bytes ( offset size -- )\n"
"    \\ .\" compile+@bytes ( \" over . dup . .\" )\" cr\n"
"    swap [compile] literal   \\ compile offset into word\n"
"    CASE\n"
"    cell OF compile (s+@)  ENDOF\n"
"    2 OF compile (s+uw@)      ENDOF\n"
"    1 OF compile (s+uc@)      ENDOF\n"
"    -cell OF compile (s+rel@)      ENDOF \\ 00002\n"
"    -2 OF compile (s+w@)     ENDOF\n"
"    -1 OF compile (s+c@)     ENDOF\n"
"    true abort\" s@ - illegal size!\"\n"
"    ENDCASE\n"
";\n"
"\n"
": (S@) ( offset size -- , compile proper fetch )\n"
"    state @\n"
"    IF compile+@bytes\n"
"    ELSE >r + r> @bytes\n"
"    THEN\n"
";\n"
"\n"
": S@ ( object <member> -- value , fetch value from member )\n"
"    ob.stats?\n"
"    (s@)\n"
"; immediate\n"
"\n"
"exists? F* [IF]\n"
"\\ 951112 Floating Point support\n"
": FLPT  ( <name> -- , declare space for a floating point value. )\n"
"     1 floats bytes\n"
";\n"
": (S+F!)  ( val addr offset -- )  + f! ;\n"
": (S+F@)  ( addr offset -- val )  + f@ ;\n"
"\n"
": FS! ( value object <member> -- , fetch value from member )\n"
"    ob.stats?\n"
"    1 floats <> abort\" FS@ with non-float!\"\n"
"    state @\n"
"    IF\n"
"        [compile] literal\n"
"        compile (s+f!)\n"
"    ELSE (s+f!)\n"
"    THEN\n"
"; immediate\n"
": FS@ ( object <member> -- value , fetch value from member )\n"
"    ob.stats?\n"
"    1 floats <> abort\" FS@ with non-float!\"\n"
"    state @\n"
"    IF\n"
"        [compile] literal\n"
"        compile (s+f@)\n"
"    ELSE (s+f@)\n"
"    THEN\n"
"; immediate\n"
"[THEN]\n"
"\n"
"0 [IF]\n"
":struct mapper\n"
"    long map_l1\n"
"    long map_l2\n"
"    short map_s1\n"
"    ushort map_s2\n"
"    byte map_b1\n"
"    ubyte map_b2\n"
"    aptr map_a1\n"
"    rptr map_r1\n"
"    flpt map_f1\n"
";struct\n"
"mapper map1\n"
"\n"
".\" compiling TT\" cr\n"
": TT\n"
"    123456 map1 s! map_l1\n"
"    map1 s@ map_l1 123456 - abort\" map_l1 failed!\"\n"
"    987654 map1 s! map_l2\n"
"    map1 s@ map_l2 987654 - abort\" map_l2 failed!\"\n"
"\n"
"    -500 map1 s! map_s1\n"
"    map1 s@ map_s1 dup . cr -500 - abort\" map_s1 failed!\"\n"
"    -500 map1 s! map_s2\n"
"    map1 s@ map_s2 -500 $ FFFF and - abort\" map_s2 failed!\"\n"
"\n"
"    -89 map1 s! map_b1\n"
"    map1 s@ map_b1 -89 - abort\" map_s1 failed!\"\n"
"    here map1 s! map_r1\n"
"    map1 s@ map_r1 here - abort\" map_r1 failed!\"\n"
"    -89 map1 s! map_b2\n"
"    map1 s@ map_b2 -89 $ FF and - abort\" map_s2 failed!\"\n"
"    23.45 map1 fs! map_f1\n"
"    map1 fs@ map_f1 f. .\" =?= 23.45\" cr\n"
";\n"
".\" Testing c_struct.fth\" cr\n"
"TT\n"
"[THEN]\n";

const char* c_struct_fth = (const char*) temp_binary_data_87;

//================== case.fth ==================
static const unsigned char temp_binary_data_88[] =
"\\ @(#) case.fth 98/01/26 1.2\n"
"\\ CASE Statement\n"
"\\\n"
"\\ This definition is based upon Wil Baden's assertion that\n"
"\\ >MARK >RESOLVE ?BRANCH etc. are not needed if one has IF ELSE THEN etc.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\\\n"
"\\ MOD: PLB 6/24/91 Check for missing ENDOF\n"
"\\ MOD: PLB 8/7/91 Add ?OF and RANGEOF\n"
"\\ MOD: PLB 11/2/99 Fixed nesting of CASE. Needed to save of-depth on stack as well as case-depth.\n"
"\n"
"anew TASK-CASE\n"
"\n"
"variable CASE-DEPTH\n"
"variable OF-DEPTH\n"
"\n"
": CASE  ( n -- , start case statement ) ( -c- case-depth )\n"
"    ?comp\n"
"    of-depth @   0 of-depth !   \\ 11/2/99\n"
"    case-depth @ 0 case-depth !  ( allow nesting )\n"
"; IMMEDIATE\n"
"\n"
": ?OF  ( n flag -- | n , doit if true ) ( -c- addr )\n"
"    [compile] IF\n"
"    compile drop\n"
"    1 case-depth +!\n"
"    1 of-depth +!\n"
"; IMMEDIATE\n"
"\n"
": OF  ( n t -- | n , doit if match ) ( -c- addr )\n"
"    ?comp\n"
"    compile over compile =\n"
"    [compile] ?OF\n"
"; IMMEDIATE\n"
"\n"
": (RANGEOF?)  ( n lo hi -- | n  flag )\n"
"    >r over ( n lo n ) <=\n"
"    IF\n"
"        dup r> ( n n hi ) <=\n"
"    ELSE\n"
"        rdrop false\n"
"    THEN\n"
";\n"
"\n"
": RANGEOF  ( n lo hi -- | n , doit if within ) ( -c- addr )\n"
"    compile (rangeof?)\n"
"    [compile] ?OF\n"
"; IMMEDIATE\n"
"\n"
": ENDOF  ( -- ) ( addr -c- addr' )\n"
"    [compile] ELSE\n"
"    -1 of-depth +!\n"
"; IMMEDIATE\n"
"\n"
": ENDCASE ( n -- )  ( old-case-depth addr' addr' ?\?? -- )\n"
"    of-depth @\n"
"    IF >newline .\" Missing ENDOF in CASE!\" cr abort\n"
"    THEN\n"
"\\\n"
"    compile drop\n"
"    case-depth @ 0\n"
"    ?DO [compile] THEN\n"
"    LOOP\n"
"    case-depth !\n"
"    of-depth !\n"
"; IMMEDIATE\n"
"\n";

const char* case_fth = (const char*) temp_binary_data_88;

//================== condcomp.fth ==================
static const unsigned char temp_binary_data_89[] =
"\\ @(#) condcomp.fth 98/01/26 1.2\n"
"\\ Conditional Compilation support\n"
"\\\n"
"\\ Words: STRINGS= [IF] [ELSE] [THEN] EXISTS?\n"
"\\\n"
"\\ Lifted from X3J14 dpANS-6 document.\n"
"\n"
"anew task-condcomp.fth\n"
"\n"
": [ELSE]  ( -- )\n"
"    1\n"
"    BEGIN                                 \\ level\n"
"      BEGIN\n"
"        BL WORD                           \\ level $word\n"
"        COUNT  DUP                        \\ level adr len len\n"
"      WHILE                               \\ level adr len\n"
"        2DUP  S\" [IF]\"  COMPARE 0=\n"
"        IF                                \\ level adr len\n"
"          2DROP 1+                        \\ level'\n"
"        ELSE                              \\ level adr len\n"
"          2DUP  S\" [ELSE]\"\n"
"          COMPARE 0=                      \\ level adr len flag\n"
"          IF                              \\ level adr len\n"
"             2DROP 1- DUP IF 1+ THEN      \\ level'\n"
"          ELSE                            \\ level adr len\n"
"            S\" [THEN]\"  COMPARE 0=\n"
"            IF\n"
"              1-                          \\ level'\n"
"            THEN\n"
"          THEN\n"
"        THEN\n"
"        ?DUP 0=  IF EXIT THEN             \\ level'\n"
"      REPEAT  2DROP                       \\ level\n"
"    REFILL 0= UNTIL                       \\ level\n"
"    DROP\n"
";  IMMEDIATE\n"
"\n"
": [IF]  ( flag -- )\n"
"    0=\n"
"    IF POSTPONE [ELSE]\n"
"    THEN\n"
";  IMMEDIATE\n"
"\n"
": [THEN]  ( -- )\n"
";  IMMEDIATE\n"
"\n"
": EXISTS? ( <name> -- flag , true if defined )\n"
"    bl word find\n"
"    swap drop\n"
"; immediate\n";

const char* condcomp_fth = (const char*) temp_binary_data_89;

//================== coretest.fth ==================
static const unsigned char temp_binary_data_90[] =
"\\ From: John Hayes S1I\n"
"\\ Subject: core.fr\n"
"\\ Date: Mon, 27 Nov 95 13:10\n"
"\n"
"\\ (C) 1995 JOHNS HOPKINS UNIVERSITY / APPLIED PHYSICS LABORATORY\n"
"\\ MAY BE DISTRIBUTED FREELY AS LONG AS THIS COPYRIGHT NOTICE REMAINS.\n"
"\\ VERSION 1.2\n"
"\\ THIS PROGRAM TESTS THE CORE WORDS OF AN ANS FORTH SYSTEM.\n"
"\\ THE PROGRAM ASSUMES A TWO'S COMPLEMENT IMPLEMENTATION WHERE\n"
"\\ THE RANGE OF SIGNED NUMBERS IS -2^(N-1) ... 2^(N-1)-1 AND\n"
"\\ THE RANGE OF UNSIGNED NUMBERS IS 0 ... 2^(N)-1.\n"
"\\ I HAVEN'T FIGURED OUT HOW TO TEST KEY, QUIT, ABORT, OR ABORT\"...\n"
"\\ I ALSO HAVEN'T THOUGHT OF A WAY TO TEST ENVIRONMENT?...\n"
"\n"
"\\ Load test tools - Phil Burk\n"
"include? testing tester.fth\n"
"\n"
"TESTING CORE WORDS\n"
"HEX\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING BASIC ASSUMPTIONS\n"
"\n"
"{ -> }                  \\ START WITH CLEAN SLATE\n"
"( TEST IF ANY BITS ARE SET; ANSWER IN BASE 1 )\n"
"{ : BITSSET? IF 0 0 ELSE 0 THEN ; -> }\n"
"{  0 BITSSET? -> 0 }        ( ZERO IS ALL BITS CLEAR )\n"
"{  1 BITSSET? -> 0 0 }      ( OTHER NUMBER HAVE AT LEAST ONE BIT )\n"
"{ -1 BITSSET? -> 0 0 }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING BOOLEANS: INVERT AND OR XOR\n"
"\n"
"{ 0 0 AND -> 0 }\n"
"{ 0 1 AND -> 0 }\n"
"{ 1 0 AND -> 0 }\n"
"{ 1 1 AND -> 1 }\n"
"\n"
"{ 0 INVERT 1 AND -> 1 }\n"
"{ 1 INVERT 1 AND -> 0 }\n"
"\n"
"0    CONSTANT 0S\n"
"0 INVERT CONSTANT 1S\n"
"\n"
"{ 0S INVERT -> 1S }\n"
"{ 1S INVERT -> 0S }\n"
"\n"
"{ 0S 0S AND -> 0S }\n"
"{ 0S 1S AND -> 0S }\n"
"{ 1S 0S AND -> 0S }\n"
"{ 1S 1S AND -> 1S }\n"
"\n"
"{ 0S 0S OR -> 0S }\n"
"{ 0S 1S OR -> 1S }\n"
"{ 1S 0S OR -> 1S }\n"
"{ 1S 1S OR -> 1S }\n"
"\n"
"{ 0S 0S XOR -> 0S }\n"
"{ 0S 1S XOR -> 1S }\n"
"{ 1S 0S XOR -> 1S }\n"
"{ 1S 1S XOR -> 0S }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING 2* 2/ LSHIFT RSHIFT\n"
"\n"
"( WE TRUST 1S, INVERT, AND BITSSET?; WE WILL CONFIRM RSHIFT LATER )\n"
"1S 1 RSHIFT INVERT CONSTANT MSB\n"
"{ MSB BITSSET? -> 0 0 }\n"
"\n"
"{ 0S 2* -> 0S }\n"
"{ 1 2* -> 2 }\n"
"{ 4000 2* -> 8000 }\n"
"{ 1S 2* 1 XOR -> 1S }\n"
"{ MSB 2* -> 0S }\n"
"\n"
"{ 0S 2/ -> 0S }\n"
"{ 1 2/ -> 0 }\n"
"{ 4000 2/ -> 2000 }\n"
"{ 1S 2/ -> 1S }             \\ MSB PROPOGATED\n"
"{ 1S 1 XOR 2/ -> 1S }\n"
"{ MSB 2/ MSB AND -> MSB }\n"
"\n"
"{ 1 0 LSHIFT -> 1 }\n"
"{ 1 1 LSHIFT -> 2 }\n"
"{ 1 2 LSHIFT -> 4 }\n"
"{ 1 F LSHIFT -> 8000 }          \\ BIGGEST GUARANTEED SHIFT\n"
"{ 1S 1 LSHIFT 1 XOR -> 1S }\n"
"{ MSB 1 LSHIFT -> 0 }\n"
"\n"
"{ 1 0 RSHIFT -> 1 }\n"
"{ 1 1 RSHIFT -> 0 }\n"
"{ 2 1 RSHIFT -> 1 }\n"
"{ 4 2 RSHIFT -> 1 }\n"
"{ 8000 F RSHIFT -> 1 }          \\ BIGGEST\n"
"{ MSB 1 RSHIFT MSB AND -> 0 }       \\ RSHIFT ZERO FILLS MSBS\n"
"{ MSB 1 RSHIFT 2* -> MSB }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING COMPARISONS: 0= = 0< < > U< MIN MAX\n"
"0 INVERT            CONSTANT MAX-UINT\n"
"0 INVERT 1 RSHIFT       CONSTANT MAX-INT\n"
"0 INVERT 1 RSHIFT INVERT    CONSTANT MIN-INT\n"
"0 INVERT 1 RSHIFT       CONSTANT MID-UINT\n"
"0 INVERT 1 RSHIFT INVERT    CONSTANT MID-UINT+1\n"
"\n"
"0S CONSTANT <FALSE>\n"
"1S CONSTANT <TRUE>\n"
"\n"
"{ 0 0= -> <TRUE> }\n"
"{ 1 0= -> <FALSE> }\n"
"{ 2 0= -> <FALSE> }\n"
"{ -1 0= -> <FALSE> }\n"
"{ MAX-UINT 0= -> <FALSE> }\n"
"{ MIN-INT 0= -> <FALSE> }\n"
"{ MAX-INT 0= -> <FALSE> }\n"
"\n"
"{ 0 0 = -> <TRUE> }\n"
"{ 1 1 = -> <TRUE> }\n"
"{ -1 -1 = -> <TRUE> }\n"
"{ 1 0 = -> <FALSE> }\n"
"{ -1 0 = -> <FALSE> }\n"
"{ 0 1 = -> <FALSE> }\n"
"{ 0 -1 = -> <FALSE> }\n"
"\n"
"{ 0 0< -> <FALSE> }\n"
"{ -1 0< -> <TRUE> }\n"
"{ MIN-INT 0< -> <TRUE> }\n"
"{ 1 0< -> <FALSE> }\n"
"{ MAX-INT 0< -> <FALSE> }\n"
"\n"
"{ 0 1 < -> <TRUE> }\n"
"{ 1 2 < -> <TRUE> }\n"
"{ -1 0 < -> <TRUE> }\n"
"{ -1 1 < -> <TRUE> }\n"
"{ MIN-INT 0 < -> <TRUE> }\n"
"{ MIN-INT MAX-INT < -> <TRUE> }\n"
"{ 0 MAX-INT < -> <TRUE> }\n"
"{ 0 0 < -> <FALSE> }\n"
"{ 1 1 < -> <FALSE> }\n"
"{ 1 0 < -> <FALSE> }\n"
"{ 2 1 < -> <FALSE> }\n"
"{ 0 -1 < -> <FALSE> }\n"
"{ 1 -1 < -> <FALSE> }\n"
"{ 0 MIN-INT < -> <FALSE> }\n"
"{ MAX-INT MIN-INT < -> <FALSE> }\n"
"{ MAX-INT 0 < -> <FALSE> }\n"
"\n"
"{ 0 1 > -> <FALSE> }\n"
"{ 1 2 > -> <FALSE> }\n"
"{ -1 0 > -> <FALSE> }\n"
"{ -1 1 > -> <FALSE> }\n"
"{ MIN-INT 0 > -> <FALSE> }\n"
"{ MIN-INT MAX-INT > -> <FALSE> }\n"
"{ 0 MAX-INT > -> <FALSE> }\n"
"{ 0 0 > -> <FALSE> }\n"
"{ 1 1 > -> <FALSE> }\n"
"{ 1 0 > -> <TRUE> }\n"
"{ 2 1 > -> <TRUE> }\n"
"{ 0 -1 > -> <TRUE> }\n"
"{ 1 -1 > -> <TRUE> }\n"
"{ 0 MIN-INT > -> <TRUE> }\n"
"{ MAX-INT MIN-INT > -> <TRUE> }\n"
"{ MAX-INT 0 > -> <TRUE> }\n"
"\n"
"{ 0 1 U< -> <TRUE> }\n"
"{ 1 2 U< -> <TRUE> }\n"
"{ 0 MID-UINT U< -> <TRUE> }\n"
"{ 0 MAX-UINT U< -> <TRUE> }\n"
"{ MID-UINT MAX-UINT U< -> <TRUE> }\n"
"{ 0 0 U< -> <FALSE> }\n"
"{ 1 1 U< -> <FALSE> }\n"
"{ 1 0 U< -> <FALSE> }\n"
"{ 2 1 U< -> <FALSE> }\n"
"{ MID-UINT 0 U< -> <FALSE> }\n"
"{ MAX-UINT 0 U< -> <FALSE> }\n"
"{ MAX-UINT MID-UINT U< -> <FALSE> }\n"
"\n"
"{ 0 1 MIN -> 0 }\n"
"{ 1 2 MIN -> 1 }\n"
"{ -1 0 MIN -> -1 }\n"
"{ -1 1 MIN -> -1 }\n"
"{ MIN-INT 0 MIN -> MIN-INT }\n"
"{ MIN-INT MAX-INT MIN -> MIN-INT }\n"
"{ 0 MAX-INT MIN -> 0 }\n"
"{ 0 0 MIN -> 0 }\n"
"{ 1 1 MIN -> 1 }\n"
"{ 1 0 MIN -> 0 }\n"
"{ 2 1 MIN -> 1 }\n"
"{ 0 -1 MIN -> -1 }\n"
"{ 1 -1 MIN -> -1 }\n"
"{ 0 MIN-INT MIN -> MIN-INT }\n"
"{ MAX-INT MIN-INT MIN -> MIN-INT }\n"
"{ MAX-INT 0 MIN -> 0 }\n"
"\n"
"{ 0 1 MAX -> 1 }\n"
"{ 1 2 MAX -> 2 }\n"
"{ -1 0 MAX -> 0 }\n"
"{ -1 1 MAX -> 1 }\n"
"{ MIN-INT 0 MAX -> 0 }\n"
"{ MIN-INT MAX-INT MAX -> MAX-INT }\n"
"{ 0 MAX-INT MAX -> MAX-INT }\n"
"{ 0 0 MAX -> 0 }\n"
"{ 1 1 MAX -> 1 }\n"
"{ 1 0 MAX -> 1 }\n"
"{ 2 1 MAX -> 2 }\n"
"{ 0 -1 MAX -> 0 }\n"
"{ 1 -1 MAX -> 1 }\n"
"{ 0 MIN-INT MAX -> 0 }\n"
"{ MAX-INT MIN-INT MAX -> MAX-INT }\n"
"{ MAX-INT 0 MAX -> MAX-INT }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING STACK OPS: 2DROP 2DUP 2OVER 2SWAP ?DUP DEPTH DROP DUP OVER ROT SWAP\n"
"\n"
"{ 1 2 2DROP -> }\n"
"{ 1 2 2DUP -> 1 2 1 2 }\n"
"{ 1 2 3 4 2OVER -> 1 2 3 4 1 2 }\n"
"{ 1 2 3 4 2SWAP -> 3 4 1 2 }\n"
"{ 0 ?DUP -> 0 }\n"
"{ 1 ?DUP -> 1 1 }\n"
"{ -1 ?DUP -> -1 -1 }\n"
"{ DEPTH -> 0 }\n"
"{ 0 DEPTH -> 0 1 }\n"
"{ 0 1 DEPTH -> 0 1 2 }\n"
"{ 0 DROP -> }\n"
"{ 1 2 DROP -> 1 }\n"
"{ 1 DUP -> 1 1 }\n"
"{ 1 2 OVER -> 1 2 1 }\n"
"{ 1 2 3 ROT -> 2 3 1 }\n"
"{ 1 2 SWAP -> 2 1 }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING >R R> R@\n"
"\n"
"{ : GR1 >R R> ; -> }\n"
"{ : GR2 >R R@ R> DROP ; -> }\n"
"{ 123 GR1 -> 123 }\n"
"{ 123 GR2 -> 123 }\n"
"{ 1S GR1 -> 1S }   ( RETURN STACK HOLDS CELLS )\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING ADD/SUBTRACT: + - 1+ 1- ABS NEGATE\n"
"\n"
"{ 0 5 + -> 5 }\n"
"{ 5 0 + -> 5 }\n"
"{ 0 -5 + -> -5 }\n"
"{ -5 0 + -> -5 }\n"
"{ 1 2 + -> 3 }\n"
"{ 1 -2 + -> -1 }\n"
"{ -1 2 + -> 1 }\n"
"{ -1 -2 + -> -3 }\n"
"{ -1 1 + -> 0 }\n"
"{ MID-UINT 1 + -> MID-UINT+1 }\n"
"\n"
"{ 0 5 - -> -5 }\n"
"{ 5 0 - -> 5 }\n"
"{ 0 -5 - -> 5 }\n"
"{ -5 0 - -> -5 }\n"
"{ 1 2 - -> -1 }\n"
"{ 1 -2 - -> 3 }\n"
"{ -1 2 - -> -3 }\n"
"{ -1 -2 - -> 1 }\n"
"{ 0 1 - -> -1 }\n"
"{ MID-UINT+1 1 - -> MID-UINT }\n"
"\n"
"{ 0 1+ -> 1 }\n"
"{ -1 1+ -> 0 }\n"
"{ 1 1+ -> 2 }\n"
"{ MID-UINT 1+ -> MID-UINT+1 }\n"
"\n"
"{ 2 1- -> 1 }\n"
"{ 1 1- -> 0 }\n"
"{ 0 1- -> -1 }\n"
"{ MID-UINT+1 1- -> MID-UINT }\n"
"\n"
"{ 0 NEGATE -> 0 }\n"
"{ 1 NEGATE -> -1 }\n"
"{ -1 NEGATE -> 1 }\n"
"{ 2 NEGATE -> -2 }\n"
"{ -2 NEGATE -> 2 }\n"
"\n"
"{ 0 ABS -> 0 }\n"
"{ 1 ABS -> 1 }\n"
"{ -1 ABS -> 1 }\n"
"{ MIN-INT ABS -> MID-UINT+1 }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING MULTIPLY: S>D * M* UM*\n"
"\n"
"{ 0 S>D -> 0 0 }\n"
"{ 1 S>D -> 1 0 }\n"
"{ 2 S>D -> 2 0 }\n"
"{ -1 S>D -> -1 -1 }\n"
"{ -2 S>D -> -2 -1 }\n"
"{ MIN-INT S>D -> MIN-INT -1 }\n"
"{ MAX-INT S>D -> MAX-INT 0 }\n"
"\n"
"{ 0 0 M* -> 0 S>D }\n"
"{ 0 1 M* -> 0 S>D }\n"
"{ 1 0 M* -> 0 S>D }\n"
"{ 1 2 M* -> 2 S>D }\n"
"{ 2 1 M* -> 2 S>D }\n"
"{ 3 3 M* -> 9 S>D }\n"
"{ -3 3 M* -> -9 S>D }\n"
"{ 3 -3 M* -> -9 S>D }\n"
"{ -3 -3 M* -> 9 S>D }\n"
"{ 0 MIN-INT M* -> 0 S>D }\n"
"{ 1 MIN-INT M* -> MIN-INT S>D }\n"
"{ 2 MIN-INT M* -> 0 1S }\n"
"{ 0 MAX-INT M* -> 0 S>D }\n"
"{ 1 MAX-INT M* -> MAX-INT S>D }\n"
"{ 2 MAX-INT M* -> MAX-INT 1 LSHIFT 0 }\n"
"{ MIN-INT MIN-INT M* -> 0 MSB 1 RSHIFT }\n"
"{ MAX-INT MIN-INT M* -> MSB MSB 2/ }\n"
"{ MAX-INT MAX-INT M* -> 1 MSB 2/ INVERT }\n"
"\n"
"{ 0 0 * -> 0 }              \\ TEST IDENTITIES\n"
"{ 0 1 * -> 0 }\n"
"{ 1 0 * -> 0 }\n"
"{ 1 2 * -> 2 }\n"
"{ 2 1 * -> 2 }\n"
"{ 3 3 * -> 9 }\n"
"{ -3 3 * -> -9 }\n"
"{ 3 -3 * -> -9 }\n"
"{ -3 -3 * -> 9 }\n"
"\n"
"{ MID-UINT+1 1 RSHIFT 2 * -> MID-UINT+1 }\n"
"{ MID-UINT+1 2 RSHIFT 4 * -> MID-UINT+1 }\n"
"{ MID-UINT+1 1 RSHIFT MID-UINT+1 OR 2 * -> MID-UINT+1 }\n"
"\n"
"{ 0 0 UM* -> 0 0 }\n"
"{ 0 1 UM* -> 0 0 }\n"
"{ 1 0 UM* -> 0 0 }\n"
"{ 1 2 UM* -> 2 0 }\n"
"{ 2 1 UM* -> 2 0 }\n"
"{ 3 3 UM* -> 9 0 }\n"
"\n"
"{ MID-UINT+1 1 RSHIFT 2 UM* -> MID-UINT+1 0 }\n"
"{ MID-UINT+1 2 UM* -> 0 1 }\n"
"{ MID-UINT+1 4 UM* -> 0 2 }\n"
"{ 1S 2 UM* -> 1S 1 LSHIFT 1 }\n"
"{ MAX-UINT MAX-UINT UM* -> 1 1 INVERT }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING DIVIDE: FM/MOD SM/REM UM/MOD */ */MOD / /MOD MOD\n"
"\n"
"{ 0 S>D 1 FM/MOD -> 0 0 }\n"
"{ 1 S>D 1 FM/MOD -> 0 1 }\n"
"{ 2 S>D 1 FM/MOD -> 0 2 }\n"
"{ -1 S>D 1 FM/MOD -> 0 -1 }\n"
"{ -2 S>D 1 FM/MOD -> 0 -2 }\n"
"{ 0 S>D -1 FM/MOD -> 0 0 }\n"
"{ 1 S>D -1 FM/MOD -> 0 -1 }\n"
"{ 2 S>D -1 FM/MOD -> 0 -2 }\n"
"{ -1 S>D -1 FM/MOD -> 0 1 }\n"
"{ -2 S>D -1 FM/MOD -> 0 2 }\n"
"{ 2 S>D 2 FM/MOD -> 0 1 }\n"
"{ -1 S>D -1 FM/MOD -> 0 1 }\n"
"{ -2 S>D -2 FM/MOD -> 0 1 }\n"
"{  7 S>D  3 FM/MOD -> 1 2 }\n"
"{  7 S>D -3 FM/MOD -> -2 -3 }\n"
"{ -7 S>D  3 FM/MOD -> 2 -3 }\n"
"{ -7 S>D -3 FM/MOD -> -1 2 }\n"
"{ MAX-INT S>D 1 FM/MOD -> 0 MAX-INT }\n"
"{ MIN-INT S>D 1 FM/MOD -> 0 MIN-INT }\n"
"{ MAX-INT S>D MAX-INT FM/MOD -> 0 1 }\n"
"{ MIN-INT S>D MIN-INT FM/MOD -> 0 1 }\n"
"{ 1S 1 4 FM/MOD -> 3 MAX-INT }\n"
"{ 1 MIN-INT M* 1 FM/MOD -> 0 MIN-INT }\n"
"{ 1 MIN-INT M* MIN-INT FM/MOD -> 0 1 }\n"
"{ 2 MIN-INT M* 2 FM/MOD -> 0 MIN-INT }\n"
"{ 2 MIN-INT M* MIN-INT FM/MOD -> 0 2 }\n"
"{ 1 MAX-INT M* 1 FM/MOD -> 0 MAX-INT }\n"
"{ 1 MAX-INT M* MAX-INT FM/MOD -> 0 1 }\n"
"{ 2 MAX-INT M* 2 FM/MOD -> 0 MAX-INT }\n"
"{ 2 MAX-INT M* MAX-INT FM/MOD -> 0 2 }\n"
"{ MIN-INT MIN-INT M* MIN-INT FM/MOD -> 0 MIN-INT }\n"
"{ MIN-INT MAX-INT M* MIN-INT FM/MOD -> 0 MAX-INT }\n"
"{ MIN-INT MAX-INT M* MAX-INT FM/MOD -> 0 MIN-INT }\n"
"{ MAX-INT MAX-INT M* MAX-INT FM/MOD -> 0 MAX-INT }\n"
"\n"
"{ 0 S>D 1 SM/REM -> 0 0 }\n"
"{ 1 S>D 1 SM/REM -> 0 1 }\n"
"{ 2 S>D 1 SM/REM -> 0 2 }\n"
"{ -1 S>D 1 SM/REM -> 0 -1 }\n"
"{ -2 S>D 1 SM/REM -> 0 -2 }\n"
"{ 0 S>D -1 SM/REM -> 0 0 }\n"
"{ 1 S>D -1 SM/REM -> 0 -1 }\n"
"{ 2 S>D -1 SM/REM -> 0 -2 }\n"
"{ -1 S>D -1 SM/REM -> 0 1 }\n"
"{ -2 S>D -1 SM/REM -> 0 2 }\n"
"{ 2 S>D 2 SM/REM -> 0 1 }\n"
"{ -1 S>D -1 SM/REM -> 0 1 }\n"
"{ -2 S>D -2 SM/REM -> 0 1 }\n"
"{  7 S>D  3 SM/REM -> 1 2 }\n"
"{  7 S>D -3 SM/REM -> 1 -2 }\n"
"{ -7 S>D  3 SM/REM -> -1 -2 }\n"
"{ -7 S>D -3 SM/REM -> -1 2 }\n"
"{ MAX-INT S>D 1 SM/REM -> 0 MAX-INT }\n"
"{ MIN-INT S>D 1 SM/REM -> 0 MIN-INT }\n"
"{ MAX-INT S>D MAX-INT SM/REM -> 0 1 }\n"
"{ MIN-INT S>D MIN-INT SM/REM -> 0 1 }\n"
"{ 1S 1 4 SM/REM -> 3 MAX-INT }\n"
"{ 2 MIN-INT M* 2 SM/REM -> 0 MIN-INT }\n"
"{ 2 MIN-INT M* MIN-INT SM/REM -> 0 2 }\n"
"{ 2 MAX-INT M* 2 SM/REM -> 0 MAX-INT }\n"
"{ 2 MAX-INT M* MAX-INT SM/REM -> 0 2 }\n"
"{ MIN-INT MIN-INT M* MIN-INT SM/REM -> 0 MIN-INT }\n"
"{ MIN-INT MAX-INT M* MIN-INT SM/REM -> 0 MAX-INT }\n"
"{ MIN-INT MAX-INT M* MAX-INT SM/REM -> 0 MIN-INT }\n"
"{ MAX-INT MAX-INT M* MAX-INT SM/REM -> 0 MAX-INT }\n"
"\n"
"{ 0 0 1 UM/MOD -> 0 0 }\n"
"{ 1 0 1 UM/MOD -> 0 1 }\n"
"{ 1 0 2 UM/MOD -> 1 0 }\n"
"{ 3 0 2 UM/MOD -> 1 1 }\n"
"{ MAX-UINT 2 UM* 2 UM/MOD -> 0 MAX-UINT }\n"
"{ MAX-UINT 2 UM* MAX-UINT UM/MOD -> 0 2 }\n"
"{ MAX-UINT MAX-UINT UM* MAX-UINT UM/MOD -> 0 MAX-UINT }\n"
"\n"
": IFFLOORED\n"
"   [ -3 2 / -2 = INVERT ] LITERAL IF POSTPONE \\ THEN ;\n"
": IFSYM\n"
"   [ -3 2 / -1 = INVERT ] LITERAL IF POSTPONE \\ THEN ;\n"
"\n"
"\\ THE SYSTEM MIGHT DO EITHER FLOORED OR SYMMETRIC DIVISION.\n"
"\\ SINCE WE HAVE ALREADY TESTED M*, FM/MOD, AND SM/REM WE CAN USE THEM IN TEST.\n"
"IFFLOORED : T/MOD  >R S>D R> FM/MOD ;\n"
"IFFLOORED : T/     T/MOD SWAP DROP ;\n"
"IFFLOORED : TMOD   T/MOD DROP ;\n"
"IFFLOORED : T*/MOD >R M* R> FM/MOD ;\n"
"IFFLOORED : T*/    T*/MOD SWAP DROP ;\n"
"IFSYM     : T/MOD  >R S>D R> SM/REM ;\n"
"IFSYM     : T/     T/MOD SWAP DROP ;\n"
"IFSYM     : TMOD   T/MOD DROP ;\n"
"IFSYM     : T*/MOD >R M* R> SM/REM ;\n"
"IFSYM     : T*/    T*/MOD SWAP DROP ;\n"
"\n"
"{ 0 1 /MOD -> 0 1 T/MOD }\n"
"{ 1 1 /MOD -> 1 1 T/MOD }\n"
"{ 2 1 /MOD -> 2 1 T/MOD }\n"
"{ -1 1 /MOD -> -1 1 T/MOD }\n"
"{ -2 1 /MOD -> -2 1 T/MOD }\n"
"{ 0 -1 /MOD -> 0 -1 T/MOD }\n"
"{ 1 -1 /MOD -> 1 -1 T/MOD }\n"
"{ 2 -1 /MOD -> 2 -1 T/MOD }\n"
"{ -1 -1 /MOD -> -1 -1 T/MOD }\n"
"{ -2 -1 /MOD -> -2 -1 T/MOD }\n"
"{ 2 2 /MOD -> 2 2 T/MOD }\n"
"{ -1 -1 /MOD -> -1 -1 T/MOD }\n"
"{ -2 -2 /MOD -> -2 -2 T/MOD }\n"
"{ 7 3 /MOD -> 7 3 T/MOD }\n"
"{ 7 -3 /MOD -> 7 -3 T/MOD }\n"
"{ -7 3 /MOD -> -7 3 T/MOD }\n"
"{ -7 -3 /MOD -> -7 -3 T/MOD }\n"
"{ MAX-INT 1 /MOD -> MAX-INT 1 T/MOD }\n"
"{ MIN-INT 1 /MOD -> MIN-INT 1 T/MOD }\n"
"{ MAX-INT MAX-INT /MOD -> MAX-INT MAX-INT T/MOD }\n"
"{ MIN-INT MIN-INT /MOD -> MIN-INT MIN-INT T/MOD }\n"
"\n"
"{ 0 1 / -> 0 1 T/ }\n"
"{ 1 1 / -> 1 1 T/ }\n"
"{ 2 1 / -> 2 1 T/ }\n"
"{ -1 1 / -> -1 1 T/ }\n"
"{ -2 1 / -> -2 1 T/ }\n"
"{ 0 -1 / -> 0 -1 T/ }\n"
"{ 1 -1 / -> 1 -1 T/ }\n"
"{ 2 -1 / -> 2 -1 T/ }\n"
"{ -1 -1 / -> -1 -1 T/ }\n"
"{ -2 -1 / -> -2 -1 T/ }\n"
"{ 2 2 / -> 2 2 T/ }\n"
"{ -1 -1 / -> -1 -1 T/ }\n"
"{ -2 -2 / -> -2 -2 T/ }\n"
"{ 7 3 / -> 7 3 T/ }\n"
"{ 7 -3 / -> 7 -3 T/ }\n"
"{ -7 3 / -> -7 3 T/ }\n"
"{ -7 -3 / -> -7 -3 T/ }\n"
"{ MAX-INT 1 / -> MAX-INT 1 T/ }\n"
"{ MIN-INT 1 / -> MIN-INT 1 T/ }\n"
"{ MAX-INT MAX-INT / -> MAX-INT MAX-INT T/ }\n"
"{ MIN-INT MIN-INT / -> MIN-INT MIN-INT T/ }\n"
"\n"
"{ 0 1 MOD -> 0 1 TMOD }\n"
"{ 1 1 MOD -> 1 1 TMOD }\n"
"{ 2 1 MOD -> 2 1 TMOD }\n"
"{ -1 1 MOD -> -1 1 TMOD }\n"
"{ -2 1 MOD -> -2 1 TMOD }\n"
"{ 0 -1 MOD -> 0 -1 TMOD }\n"
"{ 1 -1 MOD -> 1 -1 TMOD }\n"
"{ 2 -1 MOD -> 2 -1 TMOD }\n"
"{ -1 -1 MOD -> -1 -1 TMOD }\n"
"{ -2 -1 MOD -> -2 -1 TMOD }\n"
"{ 2 2 MOD -> 2 2 TMOD }\n"
"{ -1 -1 MOD -> -1 -1 TMOD }\n"
"{ -2 -2 MOD -> -2 -2 TMOD }\n"
"{ 7 3 MOD -> 7 3 TMOD }\n"
"{ 7 -3 MOD -> 7 -3 TMOD }\n"
"{ -7 3 MOD -> -7 3 TMOD }\n"
"{ -7 -3 MOD -> -7 -3 TMOD }\n"
"{ MAX-INT 1 MOD -> MAX-INT 1 TMOD }\n"
"{ MIN-INT 1 MOD -> MIN-INT 1 TMOD }\n"
"{ MAX-INT MAX-INT MOD -> MAX-INT MAX-INT TMOD }\n"
"{ MIN-INT MIN-INT MOD -> MIN-INT MIN-INT TMOD }\n"
"\n"
"{ 0 2 1 */ -> 0 2 1 T*/ }\n"
"{ 1 2 1 */ -> 1 2 1 T*/ }\n"
"{ 2 2 1 */ -> 2 2 1 T*/ }\n"
"{ -1 2 1 */ -> -1 2 1 T*/ }\n"
"{ -2 2 1 */ -> -2 2 1 T*/ }\n"
"{ 0 2 -1 */ -> 0 2 -1 T*/ }\n"
"{ 1 2 -1 */ -> 1 2 -1 T*/ }\n"
"{ 2 2 -1 */ -> 2 2 -1 T*/ }\n"
"{ -1 2 -1 */ -> -1 2 -1 T*/ }\n"
"{ -2 2 -1 */ -> -2 2 -1 T*/ }\n"
"{ 2 2 2 */ -> 2 2 2 T*/ }\n"
"{ -1 2 -1 */ -> -1 2 -1 T*/ }\n"
"{ -2 2 -2 */ -> -2 2 -2 T*/ }\n"
"{ 7 2 3 */ -> 7 2 3 T*/ }\n"
"{ 7 2 -3 */ -> 7 2 -3 T*/ }\n"
"{ -7 2 3 */ -> -7 2 3 T*/ }\n"
"{ -7 2 -3 */ -> -7 2 -3 T*/ }\n"
"{ MAX-INT 2 MAX-INT */ -> MAX-INT 2 MAX-INT T*/ }\n"
"{ MIN-INT 2 MIN-INT */ -> MIN-INT 2 MIN-INT T*/ }\n"
"\n"
"{ 0 2 1 */MOD -> 0 2 1 T*/MOD }\n"
"{ 1 2 1 */MOD -> 1 2 1 T*/MOD }\n"
"{ 2 2 1 */MOD -> 2 2 1 T*/MOD }\n"
"{ -1 2 1 */MOD -> -1 2 1 T*/MOD }\n"
"{ -2 2 1 */MOD -> -2 2 1 T*/MOD }\n"
"{ 0 2 -1 */MOD -> 0 2 -1 T*/MOD }\n"
"{ 1 2 -1 */MOD -> 1 2 -1 T*/MOD }\n"
"{ 2 2 -1 */MOD -> 2 2 -1 T*/MOD }\n"
"{ -1 2 -1 */MOD -> -1 2 -1 T*/MOD }\n"
"{ -2 2 -1 */MOD -> -2 2 -1 T*/MOD }\n"
"{ 2 2 2 */MOD -> 2 2 2 T*/MOD }\n"
"{ -1 2 -1 */MOD -> -1 2 -1 T*/MOD }\n"
"{ -2 2 -2 */MOD -> -2 2 -2 T*/MOD }\n"
"{ 7 2 3 */MOD -> 7 2 3 T*/MOD }\n"
"{ 7 2 -3 */MOD -> 7 2 -3 T*/MOD }\n"
"{ -7 2 3 */MOD -> -7 2 3 T*/MOD }\n"
"{ -7 2 -3 */MOD -> -7 2 -3 T*/MOD }\n"
"{ MAX-INT 2 MAX-INT */MOD -> MAX-INT 2 MAX-INT T*/MOD }\n"
"{ MIN-INT 2 MIN-INT */MOD -> MIN-INT 2 MIN-INT T*/MOD }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING HERE , @ ! CELL+ CELLS C, C@ C! CHARS 2@ 2! ALIGN ALIGNED +! ALLOT\n"
"\n"
"HERE 1 ALLOT\n"
"HERE\n"
"CONSTANT 2NDA\n"
"CONSTANT 1STA\n"
"{ 1STA 2NDA U< -> <TRUE> }      \\ HERE MUST GROW WITH ALLOT\n"
"{ 1STA 1+ -> 2NDA }         \\ ... BY ONE ADDRESS UNIT\n"
"( MISSING TEST: NEGATIVE ALLOT )\n"
"\n"
"HERE 1 ,\n"
"HERE 2 ,\n"
"CONSTANT 2ND\n"
"CONSTANT 1ST\n"
"{ 1ST 2ND U< -> <TRUE> }            \\ HERE MUST GROW WITH ALLOT\n"
"{ 1ST CELL+ -> 2ND }            \\ ... BY ONE CELL\n"
"{ 1ST 1 CELLS + -> 2ND }\n"
"{ 1ST @ 2ND @ -> 1 2 }\n"
"{ 5 1ST ! -> }\n"
"{ 1ST @ 2ND @ -> 5 2 }\n"
"{ 6 2ND ! -> }\n"
"{ 1ST @ 2ND @ -> 5 6 }\n"
"{ 1ST 2@ -> 6 5 }\n"
"{ 2 1 1ST 2! -> }\n"
"{ 1ST 2@ -> 2 1 }\n"
"{ 1S 1ST !  1ST @ -> 1S }       \\ CAN STORE CELL-WIDE VALUE\n"
"\n"
"HERE 1 C,\n"
"HERE 2 C,\n"
"CONSTANT 2NDC\n"
"CONSTANT 1STC\n"
"{ 1STC 2NDC U< -> <TRUE> }      \\ HERE MUST GROW WITH ALLOT\n"
"{ 1STC CHAR+ -> 2NDC }          \\ ... BY ONE CHAR\n"
"{ 1STC 1 CHARS + -> 2NDC }\n"
"{ 1STC C@ 2NDC C@ -> 1 2 }\n"
"{ 3 1STC C! -> }\n"
"{ 1STC C@ 2NDC C@ -> 3 2 }\n"
"{ 4 2NDC C! -> }\n"
"{ 1STC C@ 2NDC C@ -> 3 4 }\n"
"\n"
"ALIGN 1 ALLOT HERE ALIGN HERE 3 CELLS ALLOT\n"
"CONSTANT A-ADDR  CONSTANT UA-ADDR\n"
"{ UA-ADDR ALIGNED -> A-ADDR }\n"
"{    1 A-ADDR C!  A-ADDR C@ ->    1 }\n"
"{ 1234 A-ADDR  !  A-ADDR  @ -> 1234 }\n"
"{ 123 456 A-ADDR 2!  A-ADDR 2@ -> 123 456 }\n"
"{ 2 A-ADDR CHAR+ C!  A-ADDR CHAR+ C@ -> 2 }\n"
"{ 3 A-ADDR CELL+ C!  A-ADDR CELL+ C@ -> 3 }\n"
"{ 1234 A-ADDR CELL+ !  A-ADDR CELL+ @ -> 1234 }\n"
"{ 123 456 A-ADDR CELL+ 2!  A-ADDR CELL+ 2@ -> 123 456 }\n"
"\n"
": BITS ( X -- U )\n"
"   0 SWAP BEGIN DUP WHILE DUP MSB AND IF >R 1+ R> THEN 2* REPEAT DROP ;\n"
"( CHARACTERS >= 1 AU, <= SIZE OF CELL, >= 8 BITS )\n"
"{ 1 CHARS 1 < -> <FALSE> }\n"
"{ 1 CHARS 1 CELLS > -> <FALSE> }\n"
"( TBD: HOW TO FIND NUMBER OF BITS? )\n"
"\n"
"( CELLS >= 1 AU, INTEGRAL MULTIPLE OF CHAR SIZE, >= 16 BITS )\n"
"{ 1 CELLS 1 < -> <FALSE> }\n"
"{ 1 CELLS 1 CHARS MOD -> 0 }\n"
"{ 1S BITS 10 < -> <FALSE> }\n"
"\n"
"{ 0 1ST ! -> }\n"
"{ 1 1ST +! -> }\n"
"{ 1ST @ -> 1 }\n"
"{ -1 1ST +! 1ST @ -> 0 }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING CHAR [CHAR] [ ] BL S\"\n"
"\n"
"{ BL -> 20 }\n"
"{ CHAR X -> 58 }\n"
"{ CHAR HELLO -> 48 }\n"
"{ : GC1 [CHAR] X ; -> }\n"
"{ : GC2 [CHAR] HELLO ; -> }\n"
"{ GC1 -> 58 }\n"
"{ GC2 -> 48 }\n"
"{ : GC3 [ GC1 ] LITERAL ; -> }\n"
"{ GC3 -> 58 }\n"
"{ : GC4 S\" XY\" ; -> }\n"
"{ GC4 SWAP DROP -> 2 }\n"
"{ GC4 DROP DUP C@ SWAP CHAR+ C@ -> 58 59 }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING ' ['] FIND EXECUTE IMMEDIATE COUNT LITERAL POSTPONE STATE\n"
"\n"
"{ : GT1 123 ; -> }\n"
"{ ' GT1 EXECUTE -> 123 }\n"
"{ : GT2 ['] GT1 ; IMMEDIATE -> }\n"
"{ GT2 EXECUTE -> 123 }\n"
"HERE 3 C, CHAR G C, CHAR T C, CHAR 1 C, CONSTANT GT1STRING\n"
"HERE 3 C, CHAR G C, CHAR T C, CHAR 2 C, CONSTANT GT2STRING\n"
"{ GT1STRING FIND -> ' GT1 -1 }\n"
"{ GT2STRING FIND -> ' GT2 1 }\n"
"( HOW TO SEARCH FOR NON-EXISTENT WORD? )\n"
"{ : GT3 GT2 LITERAL ; -> }\n"
"{ GT3 -> ' GT1 }\n"
"{ GT1STRING COUNT -> GT1STRING CHAR+ 3 }\n"
"\n"
"{ : GT4 POSTPONE GT1 ; IMMEDIATE -> }\n"
"{ : GT5 GT4 ; -> }\n"
"{ GT5 -> 123 }\n"
"{ : GT6 345 ; IMMEDIATE -> }\n"
"{ : GT7 POSTPONE GT6 ; -> }\n"
"{ GT7 -> 345 }\n"
"\n"
"{ : GT8 STATE @ ; IMMEDIATE -> }\n"
"{ GT8 -> 0 }\n"
"{ : GT9 GT8 LITERAL ; -> }\n"
"{ GT9 0= -> <FALSE> }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING IF ELSE THEN BEGIN WHILE REPEAT UNTIL RECURSE\n"
"\n"
"{ : GI1 IF 123 THEN ; -> }\n"
"{ : GI2 IF 123 ELSE 234 THEN ; -> }\n"
"{ 0 GI1 -> }\n"
"{ 1 GI1 -> 123 }\n"
"{ -1 GI1 -> 123 }\n"
"{ 0 GI2 -> 234 }\n"
"{ 1 GI2 -> 123 }\n"
"{ -1 GI1 -> 123 }\n"
"\n"
"{ : GI3 BEGIN DUP 5 < WHILE DUP 1+ REPEAT ; -> }\n"
"{ 0 GI3 -> 0 1 2 3 4 5 }\n"
"{ 4 GI3 -> 4 5 }\n"
"{ 5 GI3 -> 5 }\n"
"{ 6 GI3 -> 6 }\n"
"\n"
"{ : GI4 BEGIN DUP 1+ DUP 5 > UNTIL ; -> }\n"
"{ 3 GI4 -> 3 4 5 6 }\n"
"{ 5 GI4 -> 5 6 }\n"
"{ 6 GI4 -> 6 7 }\n"
"\n"
"{ : GI5 BEGIN DUP 2 > WHILE DUP 5 < WHILE DUP 1+ REPEAT 123 ELSE 345 THEN ; -> }\n"
"{ 1 GI5 -> 1 345 }\n"
"{ 2 GI5 -> 2 345 }\n"
"{ 3 GI5 -> 3 4 5 123 }\n"
"{ 4 GI5 -> 4 5 123 }\n"
"{ 5 GI5 -> 5 123 }\n"
"\n"
"{ : GI6 ( N -- 0,1,..N ) DUP IF DUP >R 1- RECURSE R> THEN ; -> }\n"
"{ 0 GI6 -> 0 }\n"
"{ 1 GI6 -> 0 1 }\n"
"{ 2 GI6 -> 0 1 2 }\n"
"{ 3 GI6 -> 0 1 2 3 }\n"
"{ 4 GI6 -> 0 1 2 3 4 }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING DO LOOP +LOOP I J UNLOOP LEAVE EXIT\n"
"\n"
"{ : GD1 DO I LOOP ; -> }\n"
"{ 4 1 GD1 -> 1 2 3 }\n"
"{ 2 -1 GD1 -> -1 0 1 }\n"
"{ MID-UINT+1 MID-UINT GD1 -> MID-UINT }\n"
"\n"
"{ : GD2 DO I -1 +LOOP ; -> }\n"
"{ 1 4 GD2 -> 4 3 2 1 }\n"
"{ -1 2 GD2 -> 2 1 0 -1 }\n"
"{ MID-UINT MID-UINT+1 GD2 -> MID-UINT+1 MID-UINT }\n"
"\n"
"{ : GD3 DO 1 0 DO J LOOP LOOP ; -> }\n"
"{ 4 1 GD3 -> 1 2 3 }\n"
"{ 2 -1 GD3 -> -1 0 1 }\n"
"{ MID-UINT+1 MID-UINT GD3 -> MID-UINT }\n"
"\n"
"{ : GD4 DO 1 0 DO J LOOP -1 +LOOP ; -> }\n"
"{ 1 4 GD4 -> 4 3 2 1 }\n"
"{ -1 2 GD4 -> 2 1 0 -1 }\n"
"{ MID-UINT MID-UINT+1 GD4 -> MID-UINT+1 MID-UINT }\n"
"\n"
"{ : GD5 123 SWAP 0 DO I 4 > IF DROP 234 LEAVE THEN LOOP ; -> }\n"
"{ 1 GD5 -> 123 }\n"
"{ 5 GD5 -> 123 }\n"
"{ 6 GD5 -> 234 }\n"
"\n"
"{ : GD6  ( PAT: {0 0},{0 0}{1 0}{1 1},{0 0}{1 0}{1 1}{2 0}{2 1}{2 2} )\n"
"   0 SWAP 0 DO\n"
"      I 1+ 0 DO I J + 3 = IF I UNLOOP I UNLOOP EXIT THEN 1+ LOOP\n"
"    LOOP ; -> }\n"
"{ 1 GD6 -> 1 }\n"
"{ 2 GD6 -> 3 }\n"
"{ 3 GD6 -> 4 1 2 }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING DEFINING WORDS: : ; CONSTANT VARIABLE CREATE DOES> >BODY\n"
"\n"
"{ 123 CONSTANT X123 -> }\n"
"{ X123 -> 123 }\n"
"{ : EQU CONSTANT ; -> }\n"
"{ X123 EQU Y123 -> }\n"
"{ Y123 -> 123 }\n"
"\n"
"{ VARIABLE V1 -> }\n"
"{ 123 V1 ! -> }\n"
"{ V1 @ -> 123 }\n"
"\n"
"{ : NOP : POSTPONE ; ; -> }\n"
"{ NOP NOP1 NOP NOP2 -> }\n"
"{ NOP1 -> }\n"
"{ NOP2 -> }\n"
"\n"
"{ : DOES1 DOES> @ 1 + ; -> }\n"
"{ : DOES2 DOES> @ 2 + ; -> }\n"
"{ CREATE CR1 -> }\n"
"{ CR1 -> HERE }\n"
"{ ' CR1 >BODY -> HERE }\n"
"{ 1 , -> }\n"
"{ CR1 @ -> 1 }\n"
"{ DOES1 -> }\n"
"{ CR1 -> 2 }\n"
"{ DOES2 -> }\n"
"{ CR1 -> 3 }\n"
"\n"
"{ : WEIRD: CREATE DOES> 1 + DOES> 2 + ; -> }\n"
"{ WEIRD: W1 -> }\n"
"{ ' W1 >BODY -> HERE }\n"
"{ W1 -> HERE 1 + }\n"
"{ W1 -> HERE 2 + }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING EVALUATE\n"
"\n"
": GE1 S\" 123\" ; IMMEDIATE\n"
": GE2 S\" 123 1+\" ; IMMEDIATE\n"
": GE3 S\" : GE4 345 ;\" ;\n"
": GE5 EVALUATE ; IMMEDIATE\n"
"\n"
"{ GE1 EVALUATE -> 123 }         ( TEST EVALUATE IN INTERP. STATE )\n"
"{ GE2 EVALUATE -> 124 }\n"
"{ GE3 EVALUATE -> }\n"
"{ GE4 -> 345 }\n"
"\n"
"{ : GE6 GE1 GE5 ; -> }          ( TEST EVALUATE IN COMPILE STATE )\n"
"{ GE6 -> 123 }\n"
"{ : GE7 GE2 GE5 ; -> }\n"
"{ GE7 -> 124 }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING SOURCE >IN WORD\n"
"\n"
": GS1 S\" SOURCE\" 2DUP EVALUATE\n"
"       >R SWAP >R = R> R> = ;\n"
"{ GS1 -> <TRUE> <TRUE> }\n"
"\n"
"VARIABLE SCANS\n"
": RESCAN?  -1 SCANS +! SCANS @ IF 0 >IN ! THEN ;\n"
"\n"
"{ 2 SCANS !\n"
"345 RESCAN?\n"
"-> 345 345 }\n"
"\n"
": GS2  5 SCANS ! S\" 123 RESCAN?\" EVALUATE ;\n"
"{ GS2 -> 123 123 123 123 123 }\n"
"\n"
": GS3 WORD COUNT SWAP C@ ;\n"
"{ BL GS3 HELLO -> 5 CHAR H }\n"
"{ CHAR \" GS3 GOODBYE\" -> 7 CHAR G }\n"
"{ BL GS3\n"
"DROP -> 0 }             \\ BLANK LINE RETURN ZERO-LENGTH STRING\n"
"\n"
": GS4 SOURCE >IN ! DROP ;\n"
"{ GS4 123 456\n"
"-> }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING <# # #S #> HOLD SIGN BASE >NUMBER HEX DECIMAL\n"
"\n"
": S=  \\ ( ADDR1 C1 ADDR2 C2 -- T/F ) COMPARE TWO STRINGS.\n"
"   >R SWAP R@ = IF          \\ MAKE SURE STRINGS HAVE SAME LENGTH\n"
"      R> ?DUP IF            \\ IF NON-EMPTY STRINGS\n"
"     0 DO\n"
"        OVER C@ OVER C@ - IF 2DROP <FALSE> UNLOOP EXIT THEN\n"
"        SWAP CHAR+ SWAP CHAR+\n"
"         LOOP\n"
"      THEN\n"
"      2DROP <TRUE>          \\ IF WE GET HERE, STRINGS MATCH\n"
"   ELSE\n"
"      R> DROP 2DROP <FALSE>     \\ LENGTHS MISMATCH\n"
"   THEN ;\n"
"\n"
": GP1  <# 41 HOLD 42 HOLD 0 0 #> S\" BA\" S= ;\n"
"{ GP1 -> <TRUE> }\n"
"\n"
": GP2  <# -1 SIGN 0 SIGN -1 SIGN 0 0 #> S\" --\" S= ;\n"
"{ GP2 -> <TRUE> }\n"
"\n"
": GP3  <# 1 0 # # #> S\" 01\" S= ;\n"
"{ GP3 -> <TRUE> }\n"
"\n"
": GP4  <# 1 0 #S #> S\" 1\" S= ;\n"
"{ GP4 -> <TRUE> }\n"
"\n"
"24 CONSTANT MAX-BASE            \\ BASE 2 .. 36\n"
": COUNT-BITS\n"
"   0 0 INVERT BEGIN DUP WHILE >R 1+ R> 2* REPEAT DROP ;\n"
"COUNT-BITS 2* CONSTANT #BITS-UD     \\ NUMBER OF BITS IN UD\n"
"\n"
": GP5\n"
"   BASE @ <TRUE>\n"
"   MAX-BASE 1+ 2 DO         \\ FOR EACH POSSIBLE BASE\n"
"      I BASE !              \\ TBD: ASSUMES BASE WORKS\n"
"      I 0 <# #S #> S\" 10\" S= AND\n"
"   LOOP\n"
"   SWAP BASE ! ;\n"
"{ GP5 -> <TRUE> }\n"
"\n"
": GP6\n"
"   BASE @ >R  2 BASE !\n"
"   MAX-UINT MAX-UINT <# #S #>       \\ MAXIMUM UD TO BINARY\n"
"   R> BASE !                \\ S: C-ADDR U\n"
"   DUP #BITS-UD = SWAP\n"
"   0 DO                 \\ S: C-ADDR FLAG\n"
"      OVER C@ [CHAR] 1 = AND        \\ ALL ONES\n"
"      >R CHAR+ R>\n"
"   LOOP SWAP DROP ;\n"
"{ GP6 -> <TRUE> }\n"
"\n"
": GP7\n"
"   BASE @ >R    MAX-BASE BASE !\n"
"   <TRUE>\n"
"   A 0 DO\n"
"      I 0 <# #S #>\n"
"      1 = SWAP C@ I 30 + = AND AND\n"
"   LOOP\n"
"   MAX-BASE A DO\n"
"      I 0 <# #S #>\n"
"      1 = SWAP C@ 41 I A - + = AND AND\n"
"   LOOP\n"
"   R> BASE ! ;\n"
"\n"
"{ GP7 -> <TRUE> }\n"
"\n"
"\\ >NUMBER TESTS\n"
"CREATE GN-BUF 0 C,\n"
": GN-STRING GN-BUF 1 ;\n"
": GN-CONSUMED   GN-BUF CHAR+ 0 ;\n"
": GN'       [CHAR] ' WORD CHAR+ C@ GN-BUF C!  GN-STRING ;\n"
"\n"
"{ 0 0 GN' 0' >NUMBER -> 0 0 GN-CONSUMED }\n"
"{ 0 0 GN' 1' >NUMBER -> 1 0 GN-CONSUMED }\n"
"{ 1 0 GN' 1' >NUMBER -> BASE @ 1+ 0 GN-CONSUMED }\n"
"{ 0 0 GN' -' >NUMBER -> 0 0 GN-STRING } \\ SHOULD FAIL TO CONVERT THESE\n"
"{ 0 0 GN' +' >NUMBER -> 0 0 GN-STRING }\n"
"{ 0 0 GN' .' >NUMBER -> 0 0 GN-STRING }\n"
"\n"
": >NUMBER-BASED\n"
"   BASE @ >R BASE ! >NUMBER R> BASE ! ;\n"
"\n"
"{ 0 0 GN' 2' 10 >NUMBER-BASED -> 2 0 GN-CONSUMED }\n"
"{ 0 0 GN' 2'  2 >NUMBER-BASED -> 0 0 GN-STRING }\n"
"{ 0 0 GN' F' 10 >NUMBER-BASED -> F 0 GN-CONSUMED }\n"
"{ 0 0 GN' G' 10 >NUMBER-BASED -> 0 0 GN-STRING }\n"
"{ 0 0 GN' G' MAX-BASE >NUMBER-BASED -> 10 0 GN-CONSUMED }\n"
"{ 0 0 GN' Z' MAX-BASE >NUMBER-BASED -> 23 0 GN-CONSUMED }\n"
"\n"
": GN1   \\ ( UD BASE -- UD' LEN ) UD SHOULD EQUAL UD' AND LEN SHOULD BE ZERO.\n"
"   BASE @ >R BASE !\n"
"   <# #S #>\n"
"   0 0 2SWAP >NUMBER SWAP DROP      \\ RETURN LENGTH ONLY\n"
"   R> BASE ! ;\n"
"{ 0 0 2 GN1 -> 0 0 0 }\n"
"{ MAX-UINT 0 2 GN1 -> MAX-UINT 0 0 }\n"
"{ MAX-UINT DUP 2 GN1 -> MAX-UINT DUP 0 }\n"
"{ 0 0 MAX-BASE GN1 -> 0 0 0 }\n"
"{ MAX-UINT 0 MAX-BASE GN1 -> MAX-UINT 0 0 }\n"
"{ MAX-UINT DUP MAX-BASE GN1 -> MAX-UINT DUP 0 }\n"
"\n"
": GN2   \\ ( -- 16 10 )\n"
"   BASE @ >R  HEX BASE @  DECIMAL BASE @  R> BASE ! ;\n"
"{ GN2 -> 10 A }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING FILL MOVE\n"
"\n"
"CREATE FBUF 00 C, 00 C, 00 C,\n"
"CREATE SBUF 12 C, 34 C, 56 C,\n"
": SEEBUF FBUF C@  FBUF CHAR+ C@  FBUF CHAR+ CHAR+ C@ ;\n"
"\n"
"{ FBUF 0 20 FILL -> }\n"
"{ SEEBUF -> 00 00 00 }\n"
"\n"
"{ FBUF 1 20 FILL -> }\n"
"{ SEEBUF -> 20 00 00 }\n"
"\n"
"{ FBUF 3 20 FILL -> }\n"
"{ SEEBUF -> 20 20 20 }\n"
"\n"
"{ FBUF FBUF 3 CHARS MOVE -> }       \\ BIZARRE SPECIAL CASE\n"
"{ SEEBUF -> 20 20 20 }\n"
"\n"
"{ SBUF FBUF 0 CHARS MOVE -> }\n"
"{ SEEBUF -> 20 20 20 }\n"
"\n"
"{ SBUF FBUF 1 CHARS MOVE -> }\n"
"{ SEEBUF -> 12 20 20 }\n"
"\n"
"{ SBUF FBUF 3 CHARS MOVE -> }\n"
"{ SEEBUF -> 12 34 56 }\n"
"\n"
"{ FBUF FBUF CHAR+ 2 CHARS MOVE -> }\n"
"{ SEEBUF -> 12 12 34 }\n"
"\n"
"{ FBUF CHAR+ FBUF 2 CHARS MOVE -> }\n"
"{ SEEBUF -> 12 34 34 }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING OUTPUT: . .\" CR EMIT SPACE SPACES TYPE U.\n"
"\n"
": OUTPUT-TEST\n"
"   .\" YOU SHOULD SEE THE STANDARD GRAPHIC CHARACTERS:\" CR\n"
"   41 BL DO I EMIT LOOP CR\n"
"   61 41 DO I EMIT LOOP CR\n"
"   7F 61 DO I EMIT LOOP CR\n"
"   .\" YOU SHOULD SEE 0-9 SEPARATED BY A SPACE:\" CR\n"
"   9 1+ 0 DO I . LOOP CR\n"
"   .\" YOU SHOULD SEE 0-9 (WITH NO SPACES):\" CR\n"
"   [CHAR] 9 1+ [CHAR] 0 DO I 0 SPACES EMIT LOOP CR\n"
"   .\" YOU SHOULD SEE A-G SEPARATED BY A SPACE:\" CR\n"
"   [CHAR] G 1+ [CHAR] A DO I EMIT SPACE LOOP CR\n"
"   .\" YOU SHOULD SEE 0-5 SEPARATED BY TWO SPACES:\" CR\n"
"   5 1+ 0 DO I [CHAR] 0 + EMIT 2 SPACES LOOP CR\n"
"   .\" YOU SHOULD SEE TWO SEPARATE LINES:\" CR\n"
"   S\" LINE 1\" TYPE CR S\" LINE 2\" TYPE CR\n"
"   .\" YOU SHOULD SEE THE NUMBER RANGES OF SIGNED AND UNSIGNED NUMBERS:\" CR\n"
"   .\"   SIGNED: \" MIN-INT . MAX-INT . CR\n"
"   .\" UNSIGNED: \" 0 U. MAX-UINT U. CR\n"
";\n"
"\n"
"{ OUTPUT-TEST -> }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING INPUT: ACCEPT\n"
"\n"
"CREATE ABUF 80 CHARS ALLOT\n"
"\n"
": ACCEPT-TEST\n"
"   CR .\" PLEASE TYPE UP TO 80 CHARACTERS:\" CR\n"
"   ABUF 80 ACCEPT\n"
"   CR .\" RECEIVED: \" [CHAR] \" EMIT\n"
"   ABUF SWAP TYPE [CHAR] \" EMIT CR\n"
";\n"
"\n"
"{ ACCEPT-TEST -> }\n"
"\n"
"\\ ------------------------------------------------------------------------\n"
"TESTING DICTIONARY SEARCH RULES\n"
"\n"
"{ : GDX   123 ; : GDX   GDX 234 ; -> }\n"
"\n"
"{ GDX -> 123 234 }\n"
"\n"
"\n";

const char* coretest_fth = (const char*) temp_binary_data_90;

//================== file.fth ==================
static const unsigned char temp_binary_data_91[] =
"\\ READ-LINE and WRITE-LINE\n"
"\\\n"
"\\ This code is part of pForth.\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\n"
"private{\n"
"\n"
"10 constant \\N\n"
"13 constant \\R\n"
"\n"
"\\ Unread one char from file FILEID.\n"
": UNREAD { fileid -- ior }\n"
"    fileid file-position          ( ud ior )\n"
"    ?dup\n"
"    IF   nip nip \\ IO error\n"
"    ELSE 1 s>d d- fileid reposition-file\n"
"    THEN\n"
";\n"
"\n"
"\\ Read the next available char from file FILEID and if it is a \\n then\n"
"\\ skip it; otherwise unread it.  IOR is non-zero if an error occured.\n"
"\\ C-ADDR is a buffer that can hold at least one char.\n"
": SKIP-\\N { c-addr fileid -- ior }\n"
"    c-addr 1 fileid read-file     ( u ior )\n"
"    ?dup\n"
"    IF \\ Read error?\n"
"        nip\n"
"    ELSE                          ( u )\n"
"        0=\n"
"        IF \\ End of file?\n"
"            0\n"
"        ELSE\n"
"            c-addr c@ \\n =        ( is-it-a-\\n? )\n"
"            IF   0\n"
"            ELSE fileid unread\n"
"            THEN\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
"\\ This is just s\\\" \\n\" but s\\\" isn't yet available.\n"
"create (LINE-TERMINATOR) \\n c,\n"
": LINE-TERMINATOR ( -- c-addr u ) (line-terminator) 1 ;\n"
"\n"
"\\ Standard throw code\n"
"\\ See: http://lars.nocrew.org/forth2012/exception.html#table:throw\n"
"-72 constant THROW_RENAME_FILE\n"
"\n"
"\\ Copy the string C-ADDR/U1 to C-ADDR2 and append a NUL.\n"
": PLACE-CSTR  ( c-addr1 u1 c-addr2 -- )\n"
"    2dup 2>r          ( c-addr1 u1 c-addr2 )  ( r: u1 c-addr2 )\n"
"    swap cmove        ( ) ( r: u1 c-addr2 )\n"
"    0 2r> + c!        ( )\n"
";\n"
"\n"
": MULTI-LINE-COMMENT ( \"comment<rparen>\" -- )\n"
"    BEGIN\n"
"        >in @ ')' parse         ( >in c-addr len )\n"
"        nip + >in @ =           ( delimiter-not-found? )\n"
"    WHILE                       ( )\n"
"        refill 0= IF EXIT THEN  ( )\n"
"    REPEAT\n"
";\n"
"\n"
"}private\n"
"\n"
"\\ This treats \\n, \\r\\n, and \\r as line terminator.  Reading is done\n"
"\\ one char at a time with READ-FILE hence READ-FILE should probably do\n"
"\\ some form of buffering for good efficiency.\n"
": READ-LINE ( c-addr u1 fileid -- u2 flag ior )\n"
"    { a u f }\n"
"    u 0 ?DO\n"
"        a i chars + 1 f read-file                                  ( u ior' )\n"
"        ?dup IF nip i false rot UNLOOP EXIT THEN \\ Read error?     ( u )\n"
"        0= IF i i 0<> 0 UNLOOP EXIT THEN         \\ End of file?    ( )\n"
"        a i chars + c@\n"
"        CASE\n"
"            \\n OF i true 0 UNLOOP EXIT ENDOF\n"
"            \\r OF\n"
"                \\ Detect \\r\\n\n"
"                a i chars + f skip-\\n                              ( ior )\n"
"                ?dup IF i false rot UNLOOP EXIT THEN \\ IO Error?   ( )\n"
"                i true 0 UNLOOP EXIT\n"
"\t    ENDOF\n"
"        ENDCASE\n"
"    LOOP\n"
"    \\ Line doesn't fit in buffer\n"
"    u true 0\n"
";\n"
"\n"
": WRITE-LINE ( c-addr u fileid -- ior )\n"
"    { f }\n"
"    f write-file                  ( ior )\n"
"    ?dup\n"
"    IF \\ IO error\n"
"    ELSE line-terminator f write-file\n"
"    THEN\n"
";\n"
"\n"
": RENAME-FILE ( c-addr1 u1 c-addr2 u2 -- ior )\n"
"    { a1 u1 a2 u2 | new }\n"
"    \\ Convert the file-names to C-strings by copying them after HERE.\n"
"    a1 u1 here place-cstr\n"
"    here u1 1+ chars + to new\n"
"    a2 u2 new place-cstr\n"
"    here new (rename-file) 0=\n"
"    IF 0\n"
"    ELSE throw_rename_file\n"
"    THEN\n"
";\n"
"\n"
"\\ A limit used to perform a sanity check on the size argument for\n"
"\\ RESIZE-FILE.\n"
"2variable RESIZE-FILE-LIMIT\n"
"10000000 0 resize-file-limit 2!  \\ 10MB is somewhat arbitrarily chosen\n"
"\n"
": RESIZE-FILE ( ud fileid -- ior )\n"
"    -rot 2dup resize-file-limit 2@ d>             ( fileid ud big? )\n"
"    IF\n"
"        .\" Argument (\" 0 d.r .\" ) is larger then RESIZE-FILE-LIMIT.\" cr\n"
"        .\" (You can increase RESIZE-FILE-LIMIT with 2!)\" cr\n"
"        abort\n"
"    ELSE\n"
"        rot (resize-file)\n"
"    THEN\n"
";\n"
"\n"
": (  ( \"comment<rparen>\"  -- )\n"
"    source-id\n"
"    CASE\n"
"        -1 OF postpone ( ENDOF\n"
"        0  OF postpone ( ENDOF\n"
"        \\ for input from files\n"
"        multi-line-comment\n"
"    ENDCASE\n"
"; immediate\n"
"\n"
"\\ We basically try to open the file in read-only mode.  That seems to\n"
"\\ be the best that we can do with ANSI C.  If we ever want to do\n"
"\\ something more sophisticated, like calling access(2), we must create\n"
"\\ a proper primitive.  (OTOH, portable programs can't assume much\n"
"\\ about FILE-STATUS and non-portable programs could create a custom\n"
"\\ function for access(2).)\n"
": FILE-STATUS ( c-addr u -- 0 ior )\n"
"    r/o bin open-file           ( fileid ior1 )\n"
"    ?dup\n"
"    IF   nip 0 swap             ( 0 ior1 )\n"
"    ELSE close-file 0 swap      ( 0 ior2 )\n"
"    THEN\n"
";\n"
"\n"
"privatize\n";

const char* file_fth = (const char*) temp_binary_data_91;

//================== filefind.fth ==================
static const unsigned char temp_binary_data_92[] =
"\\ @(#) filefind.fth 98/01/26 1.2\n"
"\\ FILE?  ( <name> -- , report which file this Forth word was defined in )\n"
"\\\n"
"\\ FILE? looks for ::::Filename and ;;;; in the dictionary\n"
"\\ that have been left by INCLUDE.  It figures out nested\n"
"\\ includes and reports each file that defines the word.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1992 Phil Burk\n"
"\\\n"
"\\ 00001 PLB 2/21/92 Handle words from kernel or keyboard.\n"
"\\       Support EACH.FILE?\n"
"\\ 961213 PLB Port to pForth.\n"
"\n"
"ANEW TASK-FILEFIND.FTH\n"
"\n"
": BE@ { addr | val -- val , fetch from unaligned address in BigEndian order }\n"
"    4 0\n"
"    DO\n"
"        addr i + c@\n"
"        val 8 lshift or -> val\n"
"    LOOP\n"
"    val\n"
";\n"
"\n"
": BE! { val addr -- , store to unaligned address in BigEndian order }\n"
"    4 0\n"
"    DO\n"
"        val 3 i - 8 * rshift\n"
"        addr i + c!\n"
"    LOOP\n"
";\n"
": BEW@ { addr -- , fetch word from unaligned address in BigEndian order }\n"
"    addr c@ 8 lshift\n"
"    addr 1+ c@ OR\n"
";\n"
"\n"
": BEW! { val addr -- , store word to unaligned address in BigEndian order }\n"
"    val 8 rshift addr c!\n"
"    val addr 1+ c!\n"
";\n"
"\n"
"\\ scan dictionary from NFA for filename\n"
": F?.SEARCH.NFA { nfa | dpth stoploop keyb nfa0 -- addr count }\n"
"    0 -> dpth\n"
"    0 -> stoploop\n"
"    0 -> keyb\n"
"    nfa -> nfa0\n"
"    BEGIN\n"
"        nfa prevname -> nfa\n"
"        nfa 0>\n"
"        IF\n"
"            nfa 1+ be@\n"
"            CASE\n"
"                $ 3a3a3a3a ( :::: )\n"
"                OF\n"
"                    dpth 0=\n"
"                    IF\n"
"                        nfa count 31 and\n"
"                        4 - swap 4 + swap\n"
"                        true -> stoploop\n"
"                    ELSE\n"
"                        -1 dpth + -> dpth\n"
"                    THEN\n"
"                ENDOF\n"
"                $ 3b3b3b3b ( ;;;; )\n"
"                OF\n"
"                        1 dpth + -> dpth\n"
"                        true -> keyb     \\ maybe from keyboard\n"
"                ENDOF\n"
"            ENDCASE\n"
"        ELSE\n"
"            true -> stoploop\n"
"            keyb\n"
"            IF\n"
"                \" keyboard\"\n"
"            ELSE\n"
"                \" 'C' kernel\"\n"
"            THEN\n"
"            count\n"
"        THEN\n"
"        stoploop\n"
"    UNTIL\n"
";\n"
"\n"
": FINDNFA.FROM { $name start_nfa -- nfa true | $word false }\n"
"    context @ >r\n"
"    start_nfa context !\n"
"    $name findnfa\n"
"    r> context !\n"
";\n"
"\n"
"\\ Search entire dictionary for all occurences of named word.\n"
": FILE? {  | $word nfa done? -- , take name from input }\n"
"    0 -> done?\n"
"    bl word -> $word\n"
"    $word findnfa\n"
"    IF  ( -- nfa )\n"
"        $word count type .\"  from:\" cr\n"
"        -> nfa\n"
"        BEGIN\n"
"            nfa f?.search.nfa ( addr cnt )\n"
"            nfa name> 12 .r   \\ print xt\n"
"            4 spaces type cr\n"
"            nfa prevname dup -> nfa\n"
"            0>\n"
"            IF\n"
"                $word nfa findnfa.from  \\ search from one behind found nfa\n"
"                swap -> nfa\n"
"                not\n"
"            ELSE\n"
"                true\n"
"            THEN\n"
"        UNTIL\n"
"    ELSE ( -- $word )\n"
"        count type .\"  not found!\" cr\n"
"    THEN\n"
";\n"
"\n";

const char* filefind_fth = (const char*) temp_binary_data_92;

//================== floats.fth ==================
static const unsigned char temp_binary_data_93[] =
"\\ @(#) floats.fth 98/02/26 1.4 17:51:40\n"
"\\ High Level Forth support for Floating Point\n"
"\\\n"
"\\ Author: Phil Burk and Darren Gibbs\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\\\n"
"\\ 19970702 PLB Drop 0.0 in REPRESENT to fix  0.0 F.\n"
"\\ 19980220 PLB Added FG. , fixed up large and small formatting\n"
"\\ 19980812 PLB Now don't drop 0.0 in REPRESENT to fix  0.0 F.  (!!!)\n"
"\\              Fixed F~ by using (F.EXACTLY)\n"
"\n"
"ANEW TASK-FLOATS.FTH\n"
"\n"
": FALIGNED  ( addr -- a-addr )\n"
"    1 floats 1- +\n"
"    1 floats /\n"
"    1 floats *\n"
";\n"
"\n"
": FALIGN    ( -- , align DP )\n"
"    dp @ faligned dp !\n"
";\n"
"\n"
"\\ account for size of create when aligning floats\n"
"here\n"
"create fp-create-size\n"
"fp-create-size swap - constant CREATE_SIZE\n"
"\n"
": FALIGN.CREATE  ( -- , align DP for float after CREATE )\n"
"    dp @\n"
"    CREATE_SIZE +\n"
"    faligned\n"
"    CREATE_SIZE -\n"
"    dp !\n"
";\n"
"\n"
": FCREATE  ( <name> -- , create with float aligned data )\n"
"    falign.create\n"
"    CREATE\n"
";\n"
"\n"
": FVARIABLE ( <name> -- ) ( F: -- )\n"
"    FCREATE 1 floats allot\n"
";\n"
"\n"
": FCONSTANT\n"
"    FCREATE here   1 floats allot   f!\n"
"    DOES> f@\n"
";\n"
"\n"
": F0SP ( -- ) ( F: ? -- )\n"
"    fdepth 0 max  0 ?DO fdrop LOOP\n"
";\n"
"\n"
"\\ Convert between single precision and floating point\n"
": S>F ( s -- ) ( F: -- r )\n"
"    s>d d>f\n"
";\n"
": F>S ( -- s ) ( F: r -- )\n"
"    f>d d>s\n"
";\n"
"\n"
": (F.EXACTLY) ( r1 r2 -f- flag , return true if encoded equally ) { | caddr1 caddr2 fsize fcells }\n"
"    1 floats -> fsize\n"
"    fsize cell 1- + cell 1- invert and  \\ round up to nearest multiple of stack size\n"
"    cell / -> fcells ( number of cells per float )\n"
"\\ make room on data stack for floats data\n"
"    fcells 0 ?DO 0 LOOP\n"
"    sp@ -> caddr1\n"
"    fcells 0 ?DO 0 LOOP\n"
"    sp@ -> caddr2\n"
"\\ compare bit representation\n"
"    caddr1 f!\n"
"    caddr2 f!\n"
"    caddr1 fsize caddr2 fsize compare 0=\n"
"    >r fcells 2* 0 ?DO drop LOOP r>  \\ drop float bits\n"
";\n"
"\n"
": F~ ( -0- flag ) ( r1 r2 r3 -f- )\n"
"    fdup F0<\n"
"    IF\n"
"        frot frot  ( -- r3 r1 r2 )\n"
"        fover fover ( -- r3 r1 r2 r1 r2 )\n"
"        f- fabs    ( -- r3 r1 r2 |r1-r2| )\n"
"        frot frot  ( -- r3  |r1-r2| r1 r2 )\n"
"        fabs fswap fabs f+ ( -- r3 |r1-r2|  |r1|+|r2| )\n"
"        frot fabs f* ( -- |r1-r2|  |r1|+|r2|*|r3| )\n"
"        f<\n"
"    ELSE\n"
"        fdup f0=\n"
"        IF\n"
"            fdrop\n"
"            (f.exactly)  \\ f- f0=  \\ 19980812 Used to cheat. Now actually compares bit patterns.\n"
"        ELSE\n"
"            frot frot  ( -- r3 r1 r2 )\n"
"            f- fabs    ( -- r3 |r1-r2| )\n"
"            fswap f<\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
"\\ FP Output --------------------------------------------------------\n"
"fvariable FVAR-REP  \\ scratch var for represent\n"
": REPRESENT { c-addr u | n flag1 flag2 --  n flag1 flag2 , FLOATING } ( F: r -- )\n"
"    TRUE -> flag2   \\ FIXME - need to check range\n"
"    fvar-rep f!\n"
"\\\n"
"    fvar-rep f@ f0<\n"
"    IF\n"
"        -1 -> flag1\n"
"        fvar-rep f@ fabs fvar-rep f!   \\ absolute value\n"
"    ELSE\n"
"        0 -> flag1\n"
"    THEN\n"
"\\\n"
"    fvar-rep f@ f0=\n"
"    IF\n"
"\\       fdrop \\ 19970702 \\ 19980812 Remove FDROP to fix \"0.0 F.\"\n"
"        c-addr u [char] 0 fill\n"
"        0 -> n\n"
"    ELSE\n"
"        fvar-rep f@\n"
"        flog\n"
"        fdup f0< not\n"
"        IF\n"
"            1 s>f f+ \\ round up exponent\n"
"        THEN\n"
"        f>s -> n\n"
"\\ .\" REP - n = \" n . cr\n"
"\\ normalize r to u digits\n"
"        fvar-rep f@\n"
"        10 s>f u n - s>f f** f*\n"
"        1 s>f 2 s>f f/ f+   \\ round result\n"
"\\\n"
"\\ convert float to double_int then convert to text\n"
"        f>d\n"
"\\ .\" REP - d = \" over . dup . cr\n"
"        <#  u 1- 0 ?DO # loop #s #>  \\ ( -- addr cnt )\n"
"\\ Adjust exponent if rounding caused number of digits to increase.\n"
"\\ For example from 9999 to 10000.\n"
"        u - +-> n\n"
"        c-addr u move\n"
"    THEN\n"
"\\\n"
"    n flag1 flag2\n"
";\n"
"\n"
"variable FP-PRECISION\n"
"\n"
"\\ Set maximum digits that are meaningful for the precision that we use.\n"
"1 FLOATS 4 / 7 * constant FP_PRECISION_MAX\n"
"\n"
": PRECISION ( -- u )\n"
"    fp-precision @\n"
";\n"
": SET-PRECISION ( u -- )\n"
"    fp_precision_max min\n"
"    fp-precision !\n"
";\n"
"7 set-precision\n"
"\n"
"32 constant FP_REPRESENT_SIZE\n"
"64 constant FP_OUTPUT_SIZE\n"
"\n"
"create FP-REPRESENT-PAD FP_REPRESENT_SIZE allot  \\ used with REPRESENT\n"
"create FP-OUTPUT-PAD FP_OUTPUT_SIZE allot     \\ used to assemble final output\n"
"variable FP-OUTPUT-PTR            \\ points into FP-OUTPUT-PAD\n"
"\n"
": FP.HOLD ( char -- , add char to output )\n"
"    fp-output-ptr @ fp-output-pad 64 + <\n"
"    IF\n"
"        fp-output-ptr @ tuck c!\n"
"        1+ fp-output-ptr !\n"
"    ELSE\n"
"        drop\n"
"    THEN\n"
";\n"
": FP.APPEND { addr cnt -- , add string to output }\n"
"    cnt 0 max   0\n"
"    ?DO\n"
"        addr i + c@ fp.hold\n"
"    LOOP\n"
";\n"
"\n"
": FP.STRIP.TRAILING.ZEROS ( -- , remove trailing zeros from fp output )\n"
"    BEGIN\n"
"        fp-output-ptr @ fp-output-pad u>\n"
"        fp-output-ptr @ 1- c@ [char] 0 =\n"
"        and\n"
"    WHILE\n"
"        -1 fp-output-ptr +!\n"
"    REPEAT\n"
";\n"
"\n"
": FP.APPEND.ZEROS ( numZeros -- )\n"
"    0 max   0\n"
"    ?DO [char] 0 fp.hold\n"
"    LOOP\n"
";\n"
"\n"
": FP.MOVE.DECIMAL   { n prec -- , append with decimal point shifted }\n"
"    fp-represent-pad n prec min fp.append\n"
"    n prec - fp.append.zeros\n"
"    [char] . fp.hold\n"
"    fp-represent-pad n +\n"
"    prec n - 0 max fp.append\n"
";\n"
"\n"
": (EXP.) ( n -- addr cnt , convert exponent to two digit value )\n"
"    dup abs 0\n"
"    <# # #s\n"
"    rot 0<\n"
"    IF [char] - HOLD\n"
"    ELSE [char] + hold\n"
"    THEN\n"
"    #>\n"
";\n"
"\n"
": FP.REPRESENT ( -- n flag1 flag2 ) ( r -f- )\n"
";\n"
"\n"
": (FS.)  ( -- addr cnt ) ( F: r -- , scientific notation )\n"
"    fp-output-pad fp-output-ptr !  \\ setup pointer\n"
"    fp-represent-pad   precision  represent\n"
"\\ .\" (FS.) - represent \" fp-represent-pad precision type cr\n"
"    ( -- n flag1 flag2 )\n"
"    IF\n"
"        IF [char] - fp.hold\n"
"        THEN\n"
"        1 precision fp.move.decimal\n"
"        [char] e fp.hold\n"
"        1- (exp.) fp.append \\ n\n"
"    ELSE\n"
"        2drop\n"
"        s\" <FP-OUT-OF-RANGE>\" fp.append\n"
"    THEN\n"
"    fp-output-pad fp-output-ptr @ over -\n"
";\n"
"\n"
": FS.  ( F: r -- , scientific notation )\n"
"    (fs.) type space\n"
";\n"
"\n"
": (FE.)  ( -- addr cnt ) ( F: r -- , engineering notation ) { | n n3 -- }\n"
"    fp-output-pad fp-output-ptr !  \\ setup pointer\n"
"    fp-represent-pad precision represent\n"
"    ( -- n flag1 flag2 )\n"
"    IF\n"
"        IF [char] - fp.hold\n"
"        THEN\n"
"\\ convert exponent to multiple of three\n"
"        -> n\n"
"        n 1- s>d 3 fm/mod \\ use floored divide\n"
"        3 * -> n3\n"
"        1+ precision fp.move.decimal \\ amount to move decimal point\n"
"        [char] e fp.hold\n"
"        n3 (exp.) fp.append \\ n\n"
"    ELSE\n"
"        2drop\n"
"        s\" <FP-OUT-OF-RANGE>\" fp.append\n"
"    THEN\n"
"    fp-output-pad fp-output-ptr @ over -\n"
";\n"
"\n"
": FE.  ( F: r -- , engineering notation )\n"
"    (FE.) type space\n"
";\n"
"\n"
": (FG.)  ( F: r -- , normal or scientific ) { | n n3 ndiff -- }\n"
"    fp-output-pad fp-output-ptr !  \\ setup pointer\n"
"    fp-represent-pad precision represent\n"
"    ( -- n flag1 flag2 )\n"
"    IF\n"
"        IF [char] - fp.hold\n"
"        THEN\n"
"\\ compare n with precision to see whether we do scientific display\n"
"        dup precision >\n"
"        over -3 < OR\n"
"        IF  \\ use exponential notation\n"
"            1 precision fp.move.decimal\n"
"            fp.strip.trailing.zeros\n"
"            [char] e fp.hold\n"
"            1- (exp.) fp.append \\ n\n"
"        ELSE\n"
"            dup 0>\n"
"            IF\n"
"\\ POSITIVE EXPONENT - place decimal point in middle\n"
"                precision fp.move.decimal\n"
"            ELSE\n"
"\\ NEGATIVE EXPONENT - use 0.000?\??\?\n"
"                s\" 0.\" fp.append\n"
"\\ output leading zeros\n"
"                negate fp.append.zeros\n"
"                fp-represent-pad precision fp.append\n"
"            THEN\n"
"            fp.strip.trailing.zeros\n"
"        THEN\n"
"    ELSE\n"
"        2drop\n"
"        s\" <FP-OUT-OF-RANGE>\" fp.append\n"
"    THEN\n"
"    fp-output-pad fp-output-ptr @ over -\n"
";\n"
"\n"
": FG.  ( F: r -- )\n"
"    (fg.) type space\n"
";\n"
"\n"
": (F.)  ( F: r -- , normal or scientific ) { | n n3 ndiff prec' -- }\n"
"    fp-output-pad fp-output-ptr !  \\ setup pointer\n"
"    fp-represent-pad  \\ place to put number\n"
"    fdup flog 1 s>f f+ f>s precision max\n"
"    fp_precision_max min dup -> prec'\n"
"    represent\n"
"    ( -- n flag1 flag2 )\n"
"    IF\n"
"\\ add '-' sign if negative\n"
"        IF [char] - fp.hold\n"
"        THEN\n"
"\\ compare n with precision to see whether we must do scientific display\n"
"        dup fp_precision_max >\n"
"        IF  \\ use exponential notation\n"
"            1 precision fp.move.decimal\n"
"            fp.strip.trailing.zeros\n"
"            [char] e fp.hold\n"
"            1- (exp.) fp.append \\ n\n"
"        ELSE\n"
"            dup 0>\n"
"            IF\n"
"    \\ POSITIVE EXPONENT - place decimal point in middle\n"
"                prec' fp.move.decimal\n"
"            ELSE\n"
"    \\ NEGATIVE EXPONENT - use 0.000?\??\?\n"
"                s\" 0.\" fp.append\n"
"    \\ output leading zeros\n"
"                dup negate precision min\n"
"                fp.append.zeros\n"
"                fp-represent-pad precision rot + fp.append\n"
"            THEN\n"
"        THEN\n"
"    ELSE\n"
"        2drop\n"
"        s\" <FP-OUT-OF-RANGE>\" fp.append\n"
"    THEN\n"
"    fp-output-pad fp-output-ptr @ over -\n"
";\n"
"\n"
": F.  ( F: r -- )\n"
"    (f.) type space\n"
";\n"
"\n"
": F.S  ( -- , print FP stack )\n"
"    .\" FP> \"\n"
"    fdepth 0>\n"
"    IF\n"
"        fdepth 0\n"
"        DO\n"
"            cr?\n"
"            fdepth i - 1-  \\ index of next float\n"
"            fpick f. cr?\n"
"        LOOP\n"
"    ELSE\n"
"        .\" empty\"\n"
"    THEN\n"
"    cr\n"
";\n"
"\n"
"\\ FP Input ----------------------------------------------------------\n"
"variable FP-REQUIRE-E   \\ must we put an E in FP numbers?\n"
"false fp-require-e !   \\ violate ANSI !!\n"
"\n"
": >FLOAT { c-addr u | dlo dhi u' fsign flag nshift -- flag }\n"
"    u 0= IF false exit THEN\n"
"    false -> flag\n"
"    0 -> nshift\n"
"\\\n"
"\\ check for minus sign\n"
"    c-addr c@ [char] - =     dup -> fsign\n"
"    c-addr c@ [char] + = OR\n"
"    IF   1 +-> c-addr   -1 +-> u   \\ skip char\n"
"    THEN\n"
"\\\n"
"\\ convert first set of digits\n"
"    0 0 c-addr u >number -> u' -> c-addr -> dhi -> dlo\n"
"    u' 0>\n"
"    IF\n"
"\\ convert optional second set of digits\n"
"        c-addr c@ [char] . =\n"
"        IF\n"
"            dlo dhi c-addr 1+ u' 1- dup -> nshift >number\n"
"            dup nshift - -> nshift\n"
"            -> u' -> c-addr -> dhi -> dlo\n"
"        THEN\n"
"\\ convert exponent\n"
"        u' 0>\n"
"        IF\n"
"            c-addr c@ [char] E =\n"
"            c-addr c@ [char] e =  OR\n"
"            IF\n"
"                1 +-> c-addr   -1 +-> u'   \\ skip E char\n"
"                u' 0>\n"
"                IF\n"
"                    c-addr c@ [char] + = \\ ignore + on exponent\n"
"                    IF\n"
"                        1 +-> c-addr   -1 +-> u'   \\ skip char\n"
"                    THEN\n"
"                    c-addr u' ((number?))\n"
"                    num_type_single =\n"
"                    IF\n"
"                       nshift + -> nshift\n"
"                       true -> flag\n"
"                    THEN\n"
"                ELSE\n"
"                    true -> flag   \\ allow \"1E\"\n"
"                THEN\n"
"            THEN\n"
"        ELSE\n"
"\\ only require E field if this variable is true\n"
"            fp-require-e @ not -> flag\n"
"        THEN\n"
"    THEN\n"
"\\ convert double precision int to float\n"
"    flag\n"
"    IF\n"
"        dlo dhi d>f\n"
"        10 s>f nshift s>f f** f*   \\ apply exponent\n"
"        fsign\n"
"        IF\n"
"            fnegate\n"
"        THEN\n"
"    THEN\n"
"    flag\n"
";\n"
"\n"
"3 constant NUM_TYPE_FLOAT   \\ possible return type for NUMBER?\n"
"\n"
": (FP.NUMBER?)   ( $addr -- 0 | n 1 | d 2 | r 3 , convert string to number )\n"
"\\ check to see if it is a valid float, if not use old (NUMBER?)\n"
"    dup count >float\n"
"    IF\n"
"        drop NUM_TYPE_FLOAT\n"
"    ELSE\n"
"        (number?)\n"
"    THEN\n"
";\n"
"\n"
"defer fp.old.number?\n"
"variable FP-IF-INIT\n"
"\n"
": FP.TERM    ( -- , deinstall fp conversion )\n"
"    fp-if-init @\n"
"    IF\n"
"        what's  fp.old.number? is number?\n"
"        fp-if-init off\n"
"    THEN\n"
";\n"
"\n"
": FP.INIT  ( -- , install FP converion )\n"
"    fp.term\n"
"    what's number? is fp.old.number?\n"
"    ['] (fp.number?) is number?\n"
"    fp-if-init on\n"
"    .\" Floating point numeric conversion installed.\" cr\n"
";\n"
"\n"
"FP.INIT\n"
"if.forgotten fp.term\n"
"\n"
"\n"
"0 [IF]\n"
"\n"
"23.8e-9 fconstant fsmall\n"
"1.0 fsmall f- fconstant falmost1\n"
".\" Should be 1.0 = \" falmost1 f. cr\n"
"\n"
": TSEGF  ( r -f- , print in all formats )\n"
".\" --------------------------------\" cr\n"
"    34 0\n"
"    DO\n"
"        fdup fs. 4 spaces  fdup fe. 4 spaces\n"
"        fdup fg. 4 spaces  fdup f.  cr\n"
"        10.0 f/\n"
"    LOOP\n"
"    fdrop\n"
";\n"
"\n"
": TFP\n"
"    1.234e+22 tsegf\n"
"    1.23456789e+22 tsegf\n"
"    0.927 fsin 1.234e+22 f* tsegf\n"
";\n"
"\n"
"[THEN]\n";

const char* floats_fth = (const char*) temp_binary_data_93;

//================== forget.fth ==================
static const unsigned char temp_binary_data_94[] =
"\\ @(#) forget.fth 98/01/26 1.2\n"
"\\ forget.fth\n"
"\\\n"
"\\ forget part of dictionary\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\\\n"
"\\ 19970701 PLB Use unsigned compares for machines with \"negative\" addresses.\n"
"\n"
"variable RFENCE    \\ relocatable value below which we won't forget\n"
"\n"
": FREEZE  ( -- , protect below here )\n"
"    here rfence a!\n"
";\n"
"\n"
": FORGET.NFA  ( nfa -- , set DP etc. )\n"
"    dup name> >code dp !\n"
"    prevname ( dup current ! ) dup context ! n>nextlink headers-ptr !\n"
";\n"
"\n"
": VERIFY.FORGET  ( nfa -- , ask for verification if below fence )\n"
"    dup name> >code rfence a@ u<  \\ 19970701\n"
"    IF\n"
"        >newline dup id. .\"  is below fence!!\" cr\n"
"        drop\n"
"    ELSE forget.nfa\n"
"    THEN\n"
";\n"
"\n"
": (FORGET)  ( <name> -- )\n"
"    BL word findnfa\n"
"    IF  verify.forget\n"
"    ELSE .\" FORGET - couldn't find \" count type cr abort\n"
"    THEN\n"
";\n"
"\n"
"variable LAST-FORGET   \\ contains address of last if.forgotten frame\n"
"0 last-forget !\n"
"\n"
": IF.FORGOTTEN  ( <name> -- , place links in dictionary without header )\n"
"    bl word find\n"
"    IF  ( xt )\n"
"        here                \\ start of frame\n"
"        last-forget a@ a,   \\ Cell[0] = rel address of previous frame\n"
"        last-forget a!      \\ point to this frame\n"
"        compile,            \\ Cell[1] = xt for this frame\n"
"    ELSE .\" IF.FORGOTTEN - couldn't find \" dup 9 dump cr count type cr abort\n"
"    THEN\n"
";\n"
"if.forgotten noop\n"
"\n"
": [FORGET]  ( <name> -- , forget then exec forgotten words )\n"
"    (forget)\n"
"    last-forget\n"
"    BEGIN a@ dup 0<>   \\ 19970701\n"
"        IF dup here u>   \\ 19970701\n"
"            IF dup cell+ x@ execute false\n"
"            ELSE dup last-forget a! true\n"
"            THEN\n"
"        ELSE true\n"
"        THEN\n"
"    UNTIL drop\n"
";\n"
"\n"
": FORGET ( <name> -- , execute latest [FORGET] )\n"
"    \" [FORGET]\" find\n"
"    IF  execute\n"
"    ELSE .\" FORGET - couldn't find \" count type cr abort\n"
"    THEN\n"
";\n"
"\n"
": ANEW ( -- , forget if defined then redefine )\n"
"    >in @\n"
"    bl word find\n"
"    IF over >in ! forget\n"
"    THEN drop\n"
"    >in ! variable\n"
";\n"
"\n"
": MARKER  ( <name> -- , define a word that forgets itself when executed, ANS )\n"
"    CREATE\n"
"        latest namebase -  \\ convert to relocatable\n"
"        ,                  \\ save for DOES>\n"
"    DOES>  ( -- body )\n"
"        @ namebase +       \\ convert back to NFA\n"
"        verify.forget\n"
";\n";

const char* forget_fth = (const char*) temp_binary_data_94;

//================== history.fth ==================
static const unsigned char temp_binary_data_95[] =
"\\ Command Line History\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1988 Phil Burk\n"
"\\ Revised 2001 for pForth\n"
"\n"
"0 [IF]\n"
"\n"
"Requires an ANSI compatible terminal.\n"
"\n"
"To get Windows computers to use ANSI mode in their DOS windows,\n"
"Add this line to \"C:\\CONFIG.SYS\" then reboot.\n"
"\n"
"  device=c:\\windows\\command\\ansi.sys\n"
"\n"
"When command line history is on, you can use the UP and DOWN arrow to scroll\n"
"through previous commands. Use the LEFT and RIGHT arrows to edit within a line.\n"
"   CONTROL-A moves to beginning of line.\n"
"   CONTROL-E moves to end of line.\n"
"   CONTROL-X erases entire line.\n"
"\n"
"\n"
"HISTORY#       ( -- , dump history buffer with numbers)\n"
"HISTORY        ( -- , dump history buffer )\n"
"XX             ( line# -- , execute line x of history )\n"
"HISTORY.RESET  ( -- , clear history tables )\n"
"HISTORY.ON     ( -- , install history vectors )\n"
"HISTORY.OFF    ( -- , uninstall history vectors )\n"
"\n"
"[THEN]\n"
"\n"
"include? ESC[ termio.fth\n"
"\n"
"ANEW TASK-HISTORY.FTH\n"
"decimal\n"
"\n"
"private{\n"
"\n"
"\\ You can expand the history buffer by increasing this constant!!!!!!!!!!\n"
"2048 constant KH_HISTORY_SIZE\n"
"\n"
"create KH-HISTORY kh_history_size allot\n"
"KH-HISTORY kh_history_size erase\n"
"\n"
"\\ An entry in the history buffer consists of\n"
"\\   byte  - Count byte = N,\n"
"\\   chars - N chars,\n"
"\\   short -  line number in Big Endian format,\n"
"\\   byte  - another Count byte = N, for reverse scan\n"
"\\\n"
"\\ The most recent entry is put at the beginning,\n"
"\\ older entries are shifted up.\n"
"\n"
"4 constant KH_LINE_EXTRA_SIZE ( 2 count bytes plus 2 line_number bytes )\n"
"\n"
": KH-END ( -- addr , end of history buffer )\n"
"    kh-history kh_history_size +\n"
";\n"
"\n"
": LINENUM@ ( addr -- w , stores in BigEndian format )\n"
"    dup c@ 8 shift\n"
"    swap 1+ c@ or\n"
";\n"
"\n"
": LINENUM! ( w addr -- )\n"
"    over -8 shift over c!\n"
"    1+ c!\n"
";\n"
"\n"
"variable KH-LOOK      ( cursor offset into history, point to 1st count byte of line )\n"
"variable KH-MAX\n"
"variable KH-COUNTER       ( 16 bit counter for line # )\n"
"variable KH-SPAN          ( total number of characters in line )\n"
"variable KH-MATCH-SPAN    ( span for matching on shift-up )\n"
"variable KH-CURSOR        ( points to next insertion point )\n"
"variable KH-ADDRESS       ( address to store chars )\n"
"variable KH-INSIDE        ( true if we are scrolling inside the history buffer )\n"
"\n"
": KH.MAKE.ROOM ( N -- , make room for N more bytes at beginning)\n"
"    >r  ( save N )\n"
"    kh-history dup r@ + ( source dest )\n"
"    kh_history_size r> - 0 max move\n"
";\n"
"\n"
": KH.NEWEST.LINE  ( -- addr count , most recent line )\n"
"    kh-history count\n"
";\n"
"\n"
": KH.REWIND ( -- , move cursor to most recent line )\n"
"    0 kh-look !\n"
";\n"
"\n"
": KH.CURRENT.ADDR ( -- $addr , count byte of current line )\n"
"    kh-look @ kh-history +\n"
";\n"
"\n"
": KH.CURRENT.LINE ( -- addr count )\n"
"    kh.current.addr count\n"
";\n"
"\n"
": KH.COMPARE ( addr count -- flag , true if redundant )\n"
"    kh.newest.line compare 0=   \\ note: ANSI COMPARE is different than JForth days\n"
";\n"
"\n"
": KH.NUM.ADDR ( -- addr , address of current line's line count )\n"
"    kh.current.line +\n"
";\n"
"\n"
": KH.CURRENT.NUM ( -- # , number of current line )\n"
"    kh.num.addr LINENUM@\n"
";\n"
"\n"
": KH.ADDR++  ( $addr -- $addr' , convert one kh to previous )\n"
"    count + 3 +\n"
";\n"
": KH.ADDR--  ( $addr -- $addr' , convert one kh to next )\n"
"    dup 1- c@   \\ get next lines endcount\n"
"    4 +  \\ account for lineNum and two count bytes\n"
"    -       \\ calc previous address\n"
";\n"
"\n"
": KH.ENDCOUNT.ADDR ( -- addr , address of current end count )\n"
"    kh.num.addr 2+\n"
";\n"
"\n"
": KH.ADD.LINE ( addr count -- )\n"
"    dup 256 >\n"
"    IF .\" KH.ADD.LINE - Too big for history!\" 2drop\n"
"    ELSE   ( add to end )\n"
"\\ Compare with most recent line.\n"
"        2dup kh.compare\n"
"        IF 2drop\n"
"        ELSE\n"
"            >r ( save count )\n"
"\\ Set look pointer to point to first count byte of last string.\n"
"            0 kh-look !\n"
"\\ Make room for this line of text and line header.\n"
"\\ PLB20100823 Was cell+ which broke on 64-bit code.\n"
"            r@ KH_LINE_EXTRA_SIZE + kh.make.room\n"
"\\ Set count bytes at beginning and end.\n"
"            r@ kh-history c!  ( start count )\n"
"            r@ kh.endcount.addr c!\n"
"            kh-counter @ kh.num.addr LINENUM!  ( line )\n"
"\\ Number lines modulo 1024\n"
"            kh-counter @ 1+ $ 3FF and kh-counter !\n"
"            kh-history 1+   ( calc destination )\n"
"            r> cmove  ( copy chars into space )\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
": KH.BACKUP.LINE  { | cantmove addr' -- cantmove , advance KH-LOOK if in bounds }\n"
"    true -> cantmove ( default flag, at end of history )\n"
"\\ KH-LOOK points to count at start of current line\n"
"    kh.current.addr c@       \\ do we have any lines?\n"
"    IF\n"
"        kh.current.addr kh.addr++ -> addr'\n"
"        addr' kh-end U<      \\ within bounds?\n"
"        IF\n"
"            addr' c@     \\ older line has chars?\n"
"            IF\n"
"                addr' kh-history - kh-look !\n"
"                false -> cantmove\n"
"            THEN\n"
"        THEN\n"
"    THEN\n"
"    cantmove\n"
";\n"
"\n"
": KH.FORWARD.LINE ( -- cantmove? )\n"
"    kh-look @ 0= dup not\n"
"    IF  kh.current.addr kh.addr--\n"
"    kh-history - kh-look !\n"
"    THEN\n"
";\n"
"\n"
": KH.OLDEST.LINE   ( -- addr count | 0, oldest in buffer )\n"
"    BEGIN kh.backup.line\n"
"    UNTIL\n"
"    kh.current.line dup 0=\n"
"    IF\n"
"        nip\n"
"    THEN\n"
";\n"
"\n"
": KH.FIND.LINE ( line# -- $addr )\n"
"    kh.rewind\n"
"    BEGIN kh.current.num over -\n"
"    WHILE kh.backup.line\n"
"        IF .\" Line not in History Buffer!\" cr drop 0 exit\n"
"        THEN\n"
"    REPEAT\n"
"    drop kh.current.addr\n"
";\n"
"\n"
"\n"
": KH-BUFFER ( -- buffer )\n"
"    kh-address @\n"
";\n"
"\n"
": KH.RETURN ( -- , move to beginning of line )\n"
"    0 out !\n"
"    13 emit\n"
";\n"
"\n"
": KH.REPLACE.LINE  ( addr count -- , make this the current line of input )\n"
"    kh.return\n"
"    tio.erase.eol\n"
"    dup kh-span !\n"
"    dup kh-cursor !\n"
"    2dup kh-buffer swap cmove\n"
"    type\n"
";\n"
"\n"
": KH.GET.MATCH ( -- , search for line with same start )\n"
"    kh-match-span @ 0=  ( keep length for multiple matches )\n"
"    IF kh-span @ kh-match-span !\n"
"    THEN\n"
"    BEGIN\n"
"        kh.backup.line not\n"
"    WHILE\n"
"        kh.current.line drop\n"
"        kh-buffer kh-match-span @ text=\n"
"        IF kh.current.line kh.replace.line\n"
"           exit\n"
"        THEN\n"
"    REPEAT\n"
";\n"
"\n"
": KH.FAR.RIGHT\n"
"    kh-span @ kh-cursor @ - dup 0>\n"
"    IF\n"
"        tio.forwards\n"
"        kh-span @ kh-cursor !\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": KH.FAR.LEFT ( -- )\n"
"    kh.return\n"
"    kh-cursor off\n"
";\n"
"\n"
": KH.GET.OLDER ( -- , goto previous line )\n"
"    kh-inside @\n"
"    IF kh.backup.line drop\n"
"    THEN\n"
"    kh.current.line kh.replace.line\n"
"    kh-inside on\n"
";\n"
"\n"
": KH.GET.NEWER ( -- , next line )\n"
"    kh.forward.line\n"
"    IF\n"
"        kh-inside off\n"
"        tib 0\n"
"    ELSE  kh.current.line\n"
"    THEN\n"
"    kh.replace.line\n"
";\n"
"\n"
": KH.CLEAR.LINE ( -- , rewind history scrolling and clear line )\n"
"    kh.rewind\n"
"    tib 0 kh.replace.line\n"
"    kh-inside off\n"
";\n"
"\n"
": KH.GO.RIGHT  ( -- )\n"
"    kh-cursor @ kh-span @ <\n"
"    IF 1 kh-cursor +!\n"
"       1 tio.forwards\n"
"    THEN\n"
";\n"
"\n"
": KH.GO.LEFT ( -- )\n"
"    kh-cursor @ ?dup\n"
"    IF 1- kh-cursor !\n"
"       1 tio.backwards\n"
"    THEN\n"
";\n"
"\n"
": KH.REFRESH  ( -- , redraw current line as is )\n"
"    kh.return\n"
"    kh-buffer kh-span @ type\n"
"    tio.erase.eol\n"
"\n"
"    kh.return\n"
"    kh-cursor @ ?dup\n"
"    IF tio.forwards\n"
"    THEN\n"
"\n"
"    kh-span @ out !\n"
";\n"
"\n"
": KH.BACKSPACE ( -- , backspace character from buffer and screen )\n"
"    kh-cursor @ ?dup  ( past 0? )\n"
"    IF  kh-span @ <\n"
"        IF  ( inside line )\n"
"            kh-buffer kh-cursor @ +  ( -- source )\n"
"            dup 1- ( -- source dest )\n"
"            kh-span @ kh-cursor @ - cmove\n"
"\\            .\" Deleted!\" cr\n"
"        ELSE\n"
"            backspace\n"
"        THEN\n"
"        -1 kh-span +!\n"
"        -1 kh-cursor +!\n"
"    ELSE bell\n"
"    THEN\n"
"    kh.refresh\n"
";\n"
"\n"
": KH.DELETE ( -- , forward delete )\n"
"    kh-cursor @ kh-span @ <  ( before end )\n"
"    IF  ( inside line )\n"
"        kh-buffer kh-cursor @ + 1+ ( -- source )\n"
"        dup 1- ( -- source dest )\n"
"        kh-span @ kh-cursor @ - 0 max cmove\n"
"        -1 kh-span +!\n"
"        kh.refresh\n"
"    THEN\n"
";\n"
"\n"
": KH.HANDLE.WINDOWS.KEY ( char -- , handle fkeys or arrows used by Windows ANSI.SYS )\n"
"    CASE\n"
"        $ 8D OF kh.get.match    ENDOF\n"
"            0 kh-match-span ! ( reset if any other key )\n"
"        $ 48 OF kh.get.older    ENDOF\n"
"        $ 50 OF kh.get.newer  ENDOF\n"
"        $ 4D OF kh.go.right ENDOF\n"
"        $ 4B OF kh.go.left  ENDOF\n"
"        $ 91 OF kh.clear.line  ENDOF\n"
"        $ 74 OF kh.far.right ENDOF\n"
"        $ 73 OF kh.far.left  ENDOF\n"
"        $ 53 OF kh.delete  ENDOF\n"
"    ENDCASE\n"
";\n"
"\n"
": KH.HANDLE.ANSI.KEY ( char -- , handle fkeys or arrows used by ANSI terminal )\n"
"    CASE\n"
"        $ 41 OF kh.get.older    ENDOF\n"
"        $ 42 OF kh.get.newer  ENDOF\n"
"        $ 43 OF kh.go.right ENDOF\n"
"        $ 44 OF kh.go.left  ENDOF\n"
"    ENDCASE\n"
";\n"
"\n"
": KH.SPECIAL.KEY ( char  -- true | false , handle fkeys or arrows, true if handled )\n"
"    true >r\n"
"    CASE\n"
"\n"
"    $ E0 OF key kh.handle.windows.key\n"
"    ENDOF\n"
"\n"
"    ASCII_ESCAPE OF\n"
"        key dup $ 4F = \\ for TELNET\n"
"        $ 5B = OR \\ for regular ANSI terminals\n"
"        IF\n"
"            key kh.handle.ansi.key\n"
"        ELSE\n"
"            rdrop false >r\n"
"        THEN\n"
"    ENDOF\n"
"\n"
"        ASCII_BACKSPACE OF kh.backspace ENDOF\n"
"        ASCII_DELETE    OF kh.backspace ENDOF\n"
"        ASCII_CTRL_X    OF kh.clear.line ENDOF\n"
"        ASCII_CTRL_A    OF kh.far.left ENDOF\n"
"        ASCII_CTRL_E    OF kh.far.right ENDOF\n"
"\n"
"    rdrop false >r\n"
"\n"
"    ENDCASE\n"
"    r>\n"
";\n"
"\n"
": KH.SMART.KEY ( -- char )\n"
"    BEGIN\n"
"        key dup kh.special.key\n"
"    WHILE\n"
"        drop\n"
"    REPEAT\n"
";\n"
"\n"
": KH.INSCHAR  { charc | repaint -- }\n"
"    false -> repaint\n"
"    kh-cursor @ kh-span @ <\n"
"    IF\n"
"\\ Move characters up\n"
"        kh-buffer kh-cursor @ +  ( -- source )\n"
"        dup 1+ ( -- source dest )\n"
"        kh-span @ kh-cursor @ - cmove>\n"
"        true -> repaint\n"
"    THEN\n"
"\\ write character to buffer\n"
"    charc kh-buffer kh-cursor @ + c!\n"
"    1 kh-cursor +!\n"
"    1 kh-span +!\n"
"    repaint\n"
"    IF kh.refresh\n"
"    ELSE charc emit\n"
"    THEN\n"
";\n"
"\n"
": EOL? ( char -- flag , true if an end of line character )\n"
"    dup 13 =\n"
"    swap 10 = OR\n"
";\n"
"\n"
": KH.GETLINE ( max -- )\n"
"    kh-max !\n"
"    kh-span off\n"
"    kh-cursor off\n"
"    kh-inside off\n"
"    kh.rewind\n"
"    0 kh-match-span !\n"
"    BEGIN\n"
"        kh-max @ kh-span @ >\n"
"        IF  kh.smart.key\n"
"            dup EOL? not  ( <cr?> )\n"
"        ELSE 0 false\n"
"        THEN  ( -- char flag )\n"
"    WHILE ( -- char )\n"
"        kh.inschar\n"
"    REPEAT drop\n"
"    kh-span @ kh-cursor @ - ?dup\n"
"    IF tio.forwards  ( move to end of line )\n"
"    THEN\n"
"    space\n"
"    flushemit\n"
";\n"
"\n"
": KH.ACCEPT ( addr max -- numChars )\n"
"    swap kh-address !\n"
"    kh.getline\n"
"    kh-span @ 0>\n"
"    IF kh-buffer kh-span @ kh.add.line\n"
"    THEN\n"
"    kh-span @\n"
";\n"
"\n"
": TEST.HISTORY\n"
"    4 0 DO\n"
"        pad 128 kh.accept\n"
"        cr pad swap type cr\n"
"    LOOP\n"
";\n"
"\n"
"}private\n"
"\n"
"\n"
": HISTORY# ( -- , dump history buffer with numbers)\n"
"    cr kh.oldest.line ?dup\n"
"    IF\n"
"        BEGIN kh.current.num 3 .r .\" ) \" type ?pause cr\n"
"            kh.forward.line 0=\n"
"        WHILE kh.current.line\n"
"        REPEAT\n"
"    THEN\n"
";\n"
"\n"
": HISTORY ( -- , dump history buffer )\n"
"    cr kh.oldest.line ?dup\n"
"    IF\n"
"        BEGIN type ?pause cr\n"
"            kh.forward.line 0=\n"
"        WHILE kh.current.line\n"
"        REPEAT\n"
"    THEN\n"
";\n"
"\n"
": XX  ( line# -- , execute line x of history )\n"
"    kh.find.line ?dup\n"
"    IF count evaluate\n"
"    THEN\n"
";\n"
"\n"
"\n"
": HISTORY.RESET  ( -- , clear history tables )\n"
"    kh-history kh_history_size erase\n"
"    kh-counter off\n"
";\n"
"\n"
": HISTORY.ON ( -- , install history vectors )\n"
"    history.reset\n"
"    what's accept ['] (accept) =\n"
"    IF ['] kh.accept is accept\n"
"    THEN\n"
";\n"
"\n"
": HISTORY.OFF ( -- , uninstall history vectors )\n"
"    what's accept ['] kh.accept =\n"
"    IF ['] (accept) is accept\n"
"    THEN\n"
";\n"
"\n"
"\n"
": AUTO.INIT\n"
"    auto.init\n"
"    history.on\n"
";\n"
": AUTO.TERM\n"
"    history.off\n"
"    auto.term\n"
";\n"
"\n"
"if.forgotten history.off\n"
"\n"
"0 [IF]\n"
"history.reset\n"
"history.on\n"
"[THEN]\n";

const char* history_fth = (const char*) temp_binary_data_95;

//================== loadhist.fth ==================
static const unsigned char temp_binary_data_96[] =
"\\ Load history and save new dictionary.\n"
"\\ This is not part of the standard build because some computers\n"
"\\ do not support ANSI terminal I/O.\n"
"\n"
"include? ESC[ termio.fth\n"
"include? HISTORY history.fth\n"
"c\" pforth.dic\" save-forth\n";

const char* loadhist_fth = (const char*) temp_binary_data_96;

//================== loadp4th.fth ==================
static const unsigned char temp_binary_data_97[] =
"\\ @(#) loadp4th.fth 98/01/28 1.3\n"
"\\ Load various files needed by PForth\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\n"
"include? forget  forget.fth\n"
"include? >number numberio.fth\n"
"include? task-misc1.fth   misc1.fth\n"
"include? case    case.fth\n"
"include? $=      strings.fth\n"
"include? privatize   private.fth\n"
"include? (local) ansilocs.fth\n"
"include? {       locals.fth\n"
"include? fm/mod  math.fth\n"
"include? task-misc2.fth misc2.fth\n"
"include? [if]    condcomp.fth\n"
"include? save-input save-input.fth\n"
"include? read-line  file.fth\n"
"include? require    require.fth\n"
"\n"
"\\ load floating point support if basic support is in kernel\n"
"exists? F*\n"
"   [IF]  include? task-floats.fth floats.fth\n"
"   [THEN]\n"
"\n"
"\\ useful but optional stuff follows --------------------\n"
"\n"
"include? task-member.fth   member.fth\n"
"include? :struct c_struct.fth\n"
"include? smif{   smart_if.fth\n"
"include? file?   filefind.fth\n"
"include? see     see.fth\n"
"include? words.like wordslik.fth\n"
"include? trace   trace.fth\n"
"include? ESC[    termio.fth\n"
"include? HISTORY history.fth\n"
"\n"
"map\n";

const char* loadp4th_fth = (const char*) temp_binary_data_97;

//================== locals.fth ==================
static const unsigned char temp_binary_data_98[] =
"\\ @(#) $M$ 98/01/26 1.2\n"
"\\ standard { v0 v1 ... vn | l0 l1 .. lm -- } syntax\n"
"\\ based on ANSI basis words (LOCAL) and TO\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\n"
"\\ MOD: PLB 2/11/00 Allow EOL and \\ between { }.\n"
"\n"
"anew task-locals.fth\n"
"\n"
"private{\n"
"variable loc-temp-mode    \\ if true, declaring temporary variables\n"
"variable loc-comment-mode \\ if true, in comment section\n"
"variable loc-done\n"
"}private\n"
"\n"
": { ( <local-declaration}> -- )\n"
"    loc-done off\n"
"    loc-temp-mode off\n"
"    loc-comment-mode off\n"
"    BEGIN\n"
"        bl word count\n"
"        dup 0>           \\ make sure we are not at the end of a line\n"
"        IF\n"
"            over c@\n"
"            CASE\n"
"    \\ handle special characters\n"
"            ascii }  OF  loc-done on          2drop  ENDOF\n"
"            ascii |  OF  loc-temp-mode on     2drop  ENDOF\n"
"            ascii -  OF  loc-comment-mode on  2drop  ENDOF\n"
"            ascii )  OF  .\" { ... ) imbalance!\" cr abort  ENDOF\n"
"            ascii \\  OF  postpone \\  2drop ENDOF   \\ Forth comment\n"
"\n"
"    \\ process name\n"
"            >r  ( save char )\n"
"            ( addr len )\n"
"            loc-comment-mode @\n"
"            IF\n"
"                2drop\n"
"            ELSE\n"
"    \\ if in temporary mode, assign local var = 0\n"
"                loc-temp-mode @\n"
"                IF compile false\n"
"                THEN\n"
"    \\ otherwise take value from stack\n"
"                (local)\n"
"            THEN\n"
"            r>\n"
"            ENDCASE\n"
"        ELSE\n"
"            2drop refill 0= abort\" End of input while defining local variables!\"\n"
"        THEN\n"
"        loc-done @\n"
"    UNTIL\n"
"    0 0 (local)\n"
"; immediate\n"
"\n"
"privatize\n"
"\n"
"\\ tests\n"
": tlv1  { n -- }  n  dup n *  dup n *  ;\n"
"\n"
": tlv2 { v1 v2 | l1 l2 -- }\n"
"    v1 . v2 . cr\n"
"    v1 v2 + -> l1\n"
"    l1 . l2 . cr\n"
";\n";

const char* locals_fth = (const char*) temp_binary_data_98;

//================== math.fth ==================
static const unsigned char temp_binary_data_99[] =
"\\ @(#) math.fth 98/01/26 1.2\n"
"\\ Extended Math routines\n"
"\\ FM/MOD SM/REM\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\n"
"anew task-math.fth\n"
"decimal\n"
"\n"
": FM/MOD { dl dh nn | dlp dhp nnp rem quo -- rem quo , floored }\n"
"    dl dh dabs -> dhp -> dlp\n"
"    nn abs -> nnp\n"
"    dlp dhp nnp um/mod -> quo -> rem\n"
"    dh 0<\n"
"    IF  \\ negative dividend\n"
"        nn 0<\n"
"        IF   \\ negative divisor\n"
"            rem negate -> rem\n"
"        ELSE  \\ positive divisor\n"
"            rem 0=\n"
"            IF\n"
"                quo negate -> quo\n"
"            ELSE\n"
"                quo 1+ negate -> quo\n"
"                nnp rem - -> rem\n"
"            THEN\n"
"        THEN\n"
"    ELSE  \\ positive dividend\n"
"        nn 0<\n"
"        IF  \\ negative divisor\n"
"            rem 0=\n"
"            IF\n"
"                quo negate -> quo\n"
"            ELSE\n"
"                nnp rem - negate -> rem\n"
"                quo 1+ negate -> quo\n"
"            THEN\n"
"        THEN\n"
"    THEN\n"
"    rem quo\n"
";\n"
"\n"
": SM/REM { dl dh nn | dlp dhp nnp rem quo -- rem quo , symmetric }\n"
"    dl dh dabs -> dhp -> dlp\n"
"    nn abs -> nnp\n"
"    dlp dhp nnp um/mod -> quo -> rem\n"
"    dh 0<\n"
"    IF  \\ negative dividend\n"
"        rem negate -> rem\n"
"        nn 0>\n"
"        IF   \\ positive divisor\n"
"            quo negate -> quo\n"
"        THEN\n"
"    ELSE  \\ positive dividend\n"
"        nn 0<\n"
"        IF  \\ negative divisor\n"
"            quo negate -> quo\n"
"        THEN\n"
"    THEN\n"
"    rem quo\n"
";\n"
"\n"
"\n"
": /MOD ( a b -- rem quo )\n"
"    >r s>d r> sm/rem\n"
";\n"
"\n"
": MOD ( a b -- rem )\n"
"    /mod drop\n"
";\n"
"\n"
": */MOD ( a b c -- rem a*b/c , use double precision intermediate value )\n"
"    >r m*\n"
"    r> sm/rem\n"
";\n"
": */ ( a b c -- a*b/c , use double precision intermediate value )\n"
"    */mod\n"
"    nip\n"
";\n";

const char* math_fth = (const char*) temp_binary_data_99;

//================== member.fth ==================
static const unsigned char temp_binary_data_100[] =
"\\ @(#) member.fth 98/01/26 1.2\n"
"\\ This files, along with c_struct.fth, supports the definition of\n"
"\\ structure members similar to those used in 'C'.\n"
"\\\n"
"\\ Some of this same code is also used by ODE,\n"
"\\ the Object Development Environment.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\\\n"
"\\ MOD: PLB 1/16/87 Use abort\" instead of er.report.\n"
"\\ MOD: PLB 2/19/87 Made OB.MEMBER immediate, use literal.\n"
"\\ MOD: PLB/MDH 6/7/88 Use 16 bit values in member defs.\n"
"\\ MOD: PLB 7/31/88 Add USHORT and UBYTE.\n"
"\\ MOD: PLB 1/20/89 Treat LITERAL as state sensitive.\n"
"\\ MOD: RDG 9/19/90 Add floating point member support.\n"
"\\ MOD: PLB 6/10/91 Add RPTR\n"
"\\ 00001 PLB 8/3/92 Make RPTR a -4 for S@ and S!\n"
"\\ 941102 RDG port to pforth\n"
"\\ 941108 PLB more porting to pforth. Use ?LITERAL instead os smart literal.\n"
"\\ 960710 PLB align long members for SUN\n"
"\n"
"ANEW TASK-MEMBER.FTH\n"
"decimal\n"
"\n"
": FIND.BODY   ( -- , pfa true | $name false , look for word in dict. )\n"
"\\ Return address of parameter data.\n"
"     bl word find\n"
"     IF  >body true\n"
"     ELSE false\n"
"     THEN\n"
";\n"
"\n"
"\\ Variables shared with object oriented code.\n"
"VARIABLE OB-STATE  ( Compilation state. )\n"
"VARIABLE OB-CURRENT-CLASS  ( ABS_CLASS_BASE of current class )\n"
"1 constant OB_DEF_CLASS   ( defining a class )\n"
"2 constant OB_DEF_STRUCT  ( defining a structure )\n"
"\n"
"\\ A member contains:\n"
"\\   cell size of data in bytes (1, 2, cell)\n"
"\\   cell offset within structure\n"
"\n"
"cell 1- constant CELL_MASK\n"
"cell negate constant -CELL\n"
"cell constant OB_OFFSET_SIZE\n"
"\n"
": OB.OFFSET@ ( member_def -- offset ) @ ;\n"
": OB.OFFSET, ( value -- ) , ;\n"
": OB.SIZE@ ( member_def -- offset )\n"
"        ob_offset_size + @ ;\n"
": OB.SIZE, ( value -- ) , ;\n"
"\n"
"( Members are associated with an offset from the base of a structure. )\n"
": OB.MAKE.MEMBER ( +-bytes -- , make room in an object at compile time)\n"
"    dup >r  ( -- +-b , save #bytes )\n"
"    ABS     ( -- |+-b| )\n"
"    ob-current-class @ ( -- b addr-space)\n"
"    tuck @          ( as #b c , current space needed )\n"
"    over CELL_MASK and 0=        ( multiple of cell? )\n"
"    IF\n"
"        aligned\n"
"    ELSE\n"
"        over 1 and 0=   ( multiple of two? )\n"
"        IF\n"
"            even-up\n"
"        THEN\n"
"    THEN\n"
"    swap over + rot !    ( update space needed )\n"
"\\ Save data in member definition. %M\n"
"    ob.offset,    ( save old offset for ivar )\n"
"    r> ob.size,   ( store size in bytes for ..! and ..@ )\n"
";\n"
"\n"
"\\ Unions allow one to address the same memory as different members.\n"
"\\ Unions work by saving the current offset for members on\n"
"\\ the stack and then reusing it for different members.\n"
": UNION{  ( -- offset , Start union definition. )\n"
"    ob-current-class @ @\n"
";\n"
"\n"
": }UNION{ ( old-offset -- new-offset , Middle of union )\n"
"    union{     ( Get current for }UNION to compare )\n"
"    swap ob-current-class @ !  ( Set back to old )\n"
";\n"
"\n"
": }UNION ( offset -- , Terminate union definition, check lengths. )\n"
"    union{ = NOT\n"
"    abort\" }UNION - Two parts of UNION are not the same size!\"\n"
";\n"
"\n"
"\\ Make members compile their offset, for \"disposable includes\".\n"
": OB.MEMBER  ( #bytes -- , make room in an object at compile time)\n"
"           ( -- offset , run time for structure )\n"
"    CREATE ob.make.member immediate\n"
"    DOES> ob.offset@  ( get offset ) ?literal\n"
";\n"
"\n"
": OB.FINDIT  ( <thing> -- pfa , get pfa of thing or error )\n"
"    find.body not\n"
"    IF cr count type .\"    ?\??\"\n"
"       true abort\" OB.FINDIT - Word not found!\"\n"
"    THEN\n"
";\n"
"\n"
": OB.STATS ( member_pfa --  offset #bytes )\n"
"    dup ob.offset@ swap\n"
"    ob.size@\n"
";\n"
"\n"
": OB.STATS? ( <member> -- offset #bytes )\n"
"    ob.findit ob.stats\n"
";\n"
"\n"
": SIZEOF() ( <struct>OR<class> -- #bytes , lookup size of object )\n"
"    ob.findit @\n"
"    ?literal\n"
"; immediate\n"
"\n"
"\\ Basic word for defining structure members.\n"
": BYTES ( #bytes -- , error check for structure only )\n"
"    ob-state @ ob_def_struct = not\n"
"    abort\" BYTES - Only valid in :STRUCT definitions.\"\n"
"    ob.member\n"
";\n"
"\n"
"\\ Declare various types of structure members.\n"
"\\ Negative size indicates a signed member.\n"
": BYTE ( <name> -- , declare space for a byte )\n"
"    -1 bytes ;\n"
"\n"
": SHORT ( <name> -- , declare space for a 16 bit value )\n"
"    -2 bytes ;\n"
"\n"
": LONG ( <name> -- )\n"
"    cell bytes ;\n"
"\n"
": UBYTE ( <name> -- , declare space for signed  byte )\n"
"    1 bytes ;\n"
"\n"
": USHORT ( <name> -- , declare space for signed 16 bit value )\n"
"    2 bytes ;\n"
"\n"
"\n"
"\\ Aliases\n"
": APTR    ( <name> -- ) long ;\n"
": RPTR    ( <name> -- ) -cell bytes ; \\ relative relocatable pointer 00001\n"
": ULONG   ( <name> -- ) long ;\n"
"\n"
": STRUCT ( <struct> <new_ivar> -- , define a structure as an ivar )\n"
"    [compile] sizeof() bytes\n"
";\n";

const char* member_fth = (const char*) temp_binary_data_100;

//================== misc1.fth ==================
static const unsigned char temp_binary_data_101[] =
"\\ @(#) misc1.fth 98/01/26 1.2\n"
"\\ miscellaneous words\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\n"
"anew task-misc1.fth\n"
"decimal\n"
"\n"
": >> rshift ;\n"
": << lshift ;\n"
"\n"
": (WARNING\")  ( flag $message -- )\n"
"    swap\n"
"    IF count type\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": WARNING\" ( flag <message> -- , print warning if true. )\n"
"    [compile] \"  ( compile message )\n"
"    state @\n"
"    IF  compile (warning\")\n"
"    ELSE (warning\")\n"
"    THEN\n"
"; IMMEDIATE\n"
"\n"
": (ABORT\")  ( flag $message -- )\n"
"    swap\n"
"    IF\n"
"        count type cr\n"
"        err_abortq throw\n"
"    ELSE drop\n"
"    THEN\n"
";\n"
"\n"
": ABORT\" ( flag <message> -- , print warning if true. )\n"
"    [compile] \"  ( compile message )\n"
"    state @\n"
"    IF  compile (abort\")\n"
"    ELSE (abort\")\n"
"    THEN\n"
"; IMMEDIATE\n"
"\n"
"\n"
": ?PAUSE ( -- , Pause if key hit. )\n"
"    ?terminal\n"
"    IF  key drop cr .\" Hit space to continue, any other key to abort:\"\n"
"        key dup emit BL = not abort\" Terminated\"\n"
"    THEN\n"
";\n"
"\n"
"60 constant #cols\n"
"\n"
": CR?  ( -- , do CR if near end )\n"
"    OUT @ #cols 16 - 10 max >\n"
"    IF cr\n"
"    THEN\n"
";\n"
"\n"
": CLS ( -- clear screen )\n"
"    40 0 do cr loop\n"
";\n"
": PAGE ( -- , clear screen, compatible with Brodie )\n"
"    cls\n"
";\n"
"\n"
": $ ( <number> -- N , convert next number as hex )\n"
"    base @ hex\n"
"    bl lword number? num_type_single = not\n"
"    abort\" Not a single number!\"\n"
"    swap base !\n"
"    state @\n"
"    IF [compile] literal\n"
"    THEN\n"
"; immediate\n"
"\n"
": .HX   ( nibble -- )\n"
"    dup 9 >\n"
"    IF    $ 37\n"
"    ELSE  $ 30\n"
"    THEN  + emit\n"
";\n"
"\n"
"variable TAB-WIDTH  8 TAB-WIDTH !\n"
": TAB  ( -- , tab over to next stop )\n"
"    out @ tab-width @ mod\n"
"    tab-width @   swap - spaces\n"
";\n"
"\n"
"\\ Vocabulary listing\n"
": WORDS  ( -- )\n"
"    0 latest\n"
"    BEGIN  dup 0<>\n"
"    WHILE  dup id. tab cr? ?pause\n"
"        prevname\n"
"        swap 1+ swap\n"
"    REPEAT drop\n"
"    cr . .\"  words\" cr\n"
";\n"
"\n"
": VLIST words ;\n"
"\n"
"variable CLOSEST-NFA\n"
"variable CLOSEST-XT\n"
"\n"
": >NAME  ( xt -- nfa , scans dictionary for closest nfa, SLOW! )\n"
"    0 closest-nfa !\n"
"    0 closest-xt !\n"
"    latest\n"
"    BEGIN  dup 0<>\n"
"        IF ( -- addr nfa ) 2dup name> ( addr nfa addr xt ) <\n"
"            IF true  ( addr below this cfa, can't be it)\n"
"            ELSE ( -- addr nfa )\n"
"                2dup name>  ( addr nfa addr xt ) =\n"
"                IF ( found it ! ) dup closest-nfa ! false\n"
"                ELSE dup name> closest-xt @ >\n"
"                    IF dup closest-nfa ! dup name> closest-xt !\n"
"                    THEN\n"
"                    true\n"
"                THEN\n"
"            THEN\n"
"        ELSE false\n"
"        THEN\n"
"    WHILE\n"
"        prevname\n"
"    REPEAT ( -- cfa nfa )\n"
"    2drop\n"
"    closest-nfa @\n"
";\n"
"\n"
": @EXECUTE  ( addr -- , execute if non-zero )\n"
"    x@ ?dup\n"
"    IF execute\n"
"    THEN\n"
";\n"
"\n"
": TOLOWER ( char -- char_lower )\n"
"    dup ascii [ <\n"
"    IF  dup ascii @ >\n"
"        IF ascii A - ascii a +\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
": EVALUATE ( i*x c-addr num -- j*x , evaluate string of Forth )\n"
"\\ save current input state and switch to passed in string\n"
"    source >r >r\n"
"    set-source\n"
"    -1 push-source-id\n"
"    >in @ >r\n"
"    0 >in !\n"
"\\ interpret the string\n"
"    interpret\n"
"\\ restore input state\n"
"    pop-source-id drop\n"
"    r> >in !\n"
"    r> r> set-source\n"
";\n"
"\n"
": \\S ( -- , comment out rest of file )\n"
"    source-id\n"
"    IF\n"
"        BEGIN \\ using REFILL is safer than popping SOURCE-ID\n"
"            refill 0=\n"
"        UNTIL\n"
"    THEN\n"
";\n";

const char* misc1_fth = (const char*) temp_binary_data_101;

//================== misc2.fth ==================
static const unsigned char temp_binary_data_102[] =
"\\ @(#) misc2.fth 98/01/26 1.2\n"
"\\ Utilities for PForth extracted from HMSL\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\\\n"
"\\ 00001 9/14/92 Added call, 'c w->s\n"
"\\ 00002 11/23/92 Moved redef of : to loadcom.fth\n"
"\n"
"anew task-misc2.fth\n"
"\n"
": 'N  ( <name> -- , make 'n state smart )\n"
"    bl word find\n"
"    IF\n"
"        state @\n"
"        IF  namebase - ( make nfa relocatable )\n"
"            [compile] literal   ( store nfa of word to be compiled )\n"
"            compile namebase+\n"
"        THEN\n"
"    THEN\n"
"; IMMEDIATE\n"
"\n"
": ?LITERAL  ( n -- , do literal if compiling )\n"
"    state @\n"
"    IF [compile] literal\n"
"    THEN\n"
";\n"
"\n"
": 'c ( <name> -- xt , state sensitive ' )\n"
"    ' ?literal\n"
"; immediate\n"
"\n"
"variable if-debug\n"
"\n"
": ? ( address -- , fatch from address and print value )\n"
"    @ .\n"
";\n"
"\n"
"decimal\n"
"create msec-delay 10000 ,  ( default for SUN )\n"
": (MSEC) ( #msecs -- )\n"
"    0\n"
"    do  msec-delay @ 0\n"
"        do loop\n"
"    loop\n"
";\n"
"\n"
"defer msec\n"
"' (msec) is msec\n"
"\n"
": SHIFT ( val n -- val<<n )\n"
"    dup 0<\n"
"    IF negate arshift\n"
"    ELSE lshift\n"
"    THEN\n"
";\n"
"\n"
"\n"
"variable rand-seed here rand-seed !\n"
": random ( -- random_number )\n"
"    rand-seed @\n"
"    31421 * 6927 +\n"
"    65535 and dup rand-seed !\n"
";\n"
": choose  ( range -- random_number , in range )\n"
"    random * -16 shift\n"
";\n"
"\n"
": wchoose ( hi lo -- random_number )\n"
"    tuck - choose +\n"
";\n"
"\n"
"\n"
"\\ sort top two items on stack.\n"
": 2sort ( a b -- a<b | b<a , largest on top of stack)\n"
"    2dup >\n"
"    if swap\n"
"    then\n"
";\n"
"\n"
"\\ sort top two items on stack.\n"
": -2sort ( a b -- a>b | b>a , smallest on top of stack)\n"
"    2dup <\n"
"    if swap\n"
"    then\n"
";\n"
"\n"
": barray  ( #bytes -- ) ( index -- addr )\n"
"    create allot\n"
"    does>  +\n"
";\n"
"\n"
": warray  ( #words -- ) ( index -- addr )\n"
"    create 2* allot\n"
"    does> swap 2* +\n"
";\n"
"\n"
": array  ( #cells -- ) ( index -- addr )\n"
"    create cell* allot\n"
"    does> swap cell* +\n"
";\n"
"\n"
": .bin  ( n -- , print in binary )\n"
"    base @ binary swap . base !\n"
";\n"
": .dec  ( n -- )\n"
"    base @ decimal swap . base !\n"
";\n"
": .hex  ( n -- )\n"
"    base @ hex swap . base !\n"
";\n"
"\n"
": B->S ( c -- c' , sign extend byte )\n"
"    dup $ 80 and\n"
"    IF\n"
"        [ $ 0FF invert ] literal or\n"
"    ELSE\n"
"        $ 0FF and\n"
"    THEN\n"
";\n"
": W->S ( 16bit-signed -- cell-signed )\n"
"    dup $ 8000 and\n"
"    IF\n"
"        [ $ 0FFFF invert ] literal or\n"
"    ELSE\n"
"        $ 0FFFF and\n"
"    THEN\n"
";\n"
"\n"
": WITHIN { n1 n2 n3 -- flag }\n"
"    n2 n3 <=\n"
"    IF\n"
"        n2 n1 <=\n"
"        n1 n3 <  AND\n"
"    ELSE\n"
"        n2 n1 <=\n"
"        n1 n3 <  OR\n"
"    THEN\n"
";\n"
"\n"
": MOVE ( src dst num -- )\n"
"    >r 2dup - 0<\n"
"    IF\n"
"        r> CMOVE>\n"
"    ELSE\n"
"        r> CMOVE\n"
"    THEN\n"
";\n"
"\n"
": ERASE ( caddr num -- )\n"
"    dup 0>\n"
"    IF\n"
"        0 fill\n"
"    ELSE\n"
"        2drop\n"
"    THEN\n"
";\n"
"\n"
": BLANK ( addr u -- , set memory to blank )\n"
"    DUP 0>\n"
"    IF\n"
"        BL FILL\n"
"    ELSE\n"
"        2DROP\n"
"    THEN\n"
";\n"
"\n"
"\\ Obsolete but included for CORE EXT word set.\n"
": QUERY REFILL DROP ;\n"
"VARIABLE SPAN\n"
": EXPECT accept span ! ;\n"
": TIB source drop ;\n"
"\n"
"\n"
": UNUSED ( -- unused , dictionary space )\n"
"    CODELIMIT HERE -\n"
";\n"
"\n"
": MAP  ( -- , dump interesting dictionary info )\n"
"    .\" Code Segment\" cr\n"
"    .\"    CODEBASE           = \" codebase .hex cr\n"
"    .\"    HERE               = \" here .hex cr\n"
"    .\"    CODELIMIT          = \" codelimit .hex cr\n"
"    .\"    Compiled Code Size = \" here codebase - . cr\n"
"    .\"    CODE-SIZE          = \" code-size @ . cr\n"
"    .\"    Code Room UNUSED   = \" UNUSED . cr\n"
"    .\" Name Segment\" cr\n"
"    .\"    NAMEBASE           = \" namebase .hex cr\n"
"    .\"    HEADERS-PTR @      = \" headers-ptr @ .hex cr\n"
"    .\"    NAMELIMIT          = \" namelimit .hex cr\n"
"    .\"    CONTEXT @          = \" context @ .hex cr\n"
"    .\"    LATEST             = \" latest .hex  .\"  = \" latest id. cr\n"
"    .\"    Compiled Name size = \" headers-ptr @ namebase - . cr\n"
"    .\"    HEADERS-SIZE       = \" headers-size @ . cr\n"
"    .\"    Name Room Left     = \" namelimit headers-ptr @ - . cr\n"
";\n"
"\n"
"\n"
"\\ Search for substring S2 in S1\n"
": SEARCH { addr1 cnt1 addr2 cnt2 | addr3 cnt3 flag --  addr3 cnt3 flag }\n"
"\\ .\" Search for \" addr2 cnt2 type  .\"  in \"  addr1 cnt1 type cr\n"
"\\ if true, s1 contains s2 at addr3 with cnt3 chars remaining\n"
"\\ if false, s3 = s1\n"
"    addr1 -> addr3\n"
"    cnt1 -> cnt3\n"
"    cnt1 cnt2 < not\n"
"    IF\n"
"        cnt1 cnt2 - 1+ 0\n"
"        DO\n"
"            true -> flag\n"
"            cnt2 0\n"
"            ?DO\n"
"                addr2 i chars + c@\n"
"                addr1 i j + chars + c@ <> \\ mismatch?\n"
"                IF\n"
"                    false -> flag\n"
"                    LEAVE\n"
"                THEN\n"
"            LOOP\n"
"            flag\n"
"            IF\n"
"                addr1 i chars + -> addr3\n"
"                cnt1 i - -> cnt3\n"
"                LEAVE\n"
"            THEN\n"
"        LOOP\n"
"    THEN\n"
"    addr3 cnt3 flag\n"
";\n"
"\n"
"private{\n"
"\n"
": env= ( c-addr u c-addr1 u1 x -- x true true | c-addr u false )\n"
"    { x } 2over compare 0= if 2drop x true true else false then\n"
";\n"
"\n"
": 2env= ( c-addr u c-addr1 u1 x y -- x y true true | c-addr u false )\n"
"    { x y } 2over compare 0= if 2drop x y true true else false then\n"
";\n"
"\n"
"0 invert constant max-u\n"
"0 invert 1 rshift constant max-n\n"
"\n"
"}private\n"
"\n"
": ENVIRONMENT? ( c-addr u -- false | i*x true )\n"
"    s\" /COUNTED-STRING\"      255 env= if exit then\n"
"    s\" /HOLD\"                128 env= if exit then \\ same as PAD\n"
"    s\" /PAD\"                 128 env= if exit then\n"
"    s\" ADDRESS-UNITS-BITS\"     8 env= if exit then\n"
"    s\" FLOORED\"            false env= if exit then\n"
"    s\" MAX-CHAR\"             255 env= if exit then\n"
"    s\" MAX-D\"       max-n max-u 2env= if exit then\n"
"    s\" MAX-N\"              max-n env= if exit then\n"
"    s\" MAX-U\"              max-u env= if exit then\n"
"    s\" MAX-UD\"      max-u max-u 2env= if exit then\n"
"    s\" RETURN-STACK-CELLS\"   512 env= if exit then \\ DEFAULT_RETURN_DEPTH\n"
"    s\" STACK-CELLS\"          512 env= if exit then \\ DEFAULT_USER_DEPTH\n"
"    \\ FIXME: maybe define those:\n"
"    \\ s\" FLOATING-STACK\"\n"
"    \\ s\" MAX-FLOAT\"\n"
"    \\ s\" #LOCALS\"\n"
"    \\ s\" WORDLISTS\"\n"
"    2drop false\n"
";\n"
"\n"
"privatize\n";

const char* misc2_fth = (const char*) temp_binary_data_102;

//================== numberio.fth ==================
static const unsigned char temp_binary_data_103[] =
"\\ @(#) numberio.fth 98/01/26 1.2\n"
"\\ numberio.fth\n"
"\\\n"
"\\ numeric conversion\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\n"
"anew task-numberio.fth\n"
"decimal\n"
"\n"
"\\ ------------------------ INPUT -------------------------------\n"
"\\ Convert a single character to a number in the given base.\n"
": DIGIT   ( char base -- n true | char false )\n"
"    >r\n"
"\\ convert lower to upper\n"
"    dup ascii a < not\n"
"    IF\n"
"        ascii a - ascii A +\n"
"    THEN\n"
"\\\n"
"    dup dup ascii A 1- >\n"
"    IF ascii A - ascii 9 + 1+\n"
"    ELSE ( char char )\n"
"        dup ascii 9 >\n"
"        IF\n"
"            ( between 9 and A is bad )\n"
"            drop 0 ( trigger error below )\n"
"        THEN\n"
"    THEN\n"
"    ascii 0 -\n"
"    dup r> <\n"
"    IF dup 1+ 0>\n"
"        IF nip true\n"
"        ELSE drop FALSE\n"
"        THEN\n"
"    ELSE drop FALSE\n"
"    THEN\n"
";\n"
"\n"
": >NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 , convert till bad char , CORE )\n"
"    >r\n"
"    BEGIN\n"
"        r@ 0>    \\ any characters left?\n"
"        IF\n"
"            dup c@ base @\n"
"            digit ( ud1 c-addr , n true | char false )\n"
"            IF\n"
"                TRUE\n"
"            ELSE\n"
"                drop FALSE\n"
"            THEN\n"
"        ELSE\n"
"            false\n"
"        THEN\n"
"    WHILE ( -- ud1 c-addr n  )\n"
"        swap >r  ( -- ud1lo ud1hi n  )\n"
"        swap  base @ ( -- ud1lo n ud1hi base  )\n"
"        um* drop ( -- ud1lo n ud1hi*baselo  )\n"
"        rot  base @ ( -- n ud1hi*baselo ud1lo base )\n"
"        um* ( -- n ud1hi*baselo ud1lo*basello ud1lo*baselhi )\n"
"        d+  ( -- ud2 )\n"
"        r> 1+     \\ increment char*\n"
"        r> 1- >r  \\ decrement count\n"
"    REPEAT\n"
"    r>\n"
";\n"
"\n"
"\\ obsolete\n"
": CONVERT  ( ud1 c-addr1 -- ud2 c-addr2 , convert till bad char , CORE EXT )\n"
"    256 >NUMBER DROP\n"
";\n"
"\n"
"0 constant NUM_TYPE_BAD\n"
"1 constant NUM_TYPE_SINGLE\n"
"2 constant NUM_TYPE_DOUBLE\n"
"\n"
"\\ Like >number, but temporarily switch BASE.\n"
": (>number-with-base) ( ud c-addr u base -- ud' c-addr' u' )\n"
"\tbase @ >r base ! >number r> base !\n"
";\n"
"\n"
"\\ This is similar to the F83 NUMBER? except that it returns a number type\n"
"\\ and then either a single or double precision number.\n"
": ((NUMBER?))   ( c-addr u -- 0 | n 1 | d 2 , convert string to number )\n"
"    dup 0= IF 2drop NUM_TYPE_BAD exit THEN   \\ any chars?\n"
"\n"
"    base @ -rot\t\t\t( base c-addr u )\n"
"\n"
"    \\ Recognize prefixes and change base if needed\n"
"    over c@ >r\t\t\t( base c-addr u  ) ( r: char )\n"
"    r@ [char] # = if rot drop 10 -rot 1 /string then\n"
"    r@ [char] $ = if rot drop 16 -rot 1 /string then\n"
"    r@ [char] % = if rot drop  2 -rot 1 /string then\n"
"    r@ [char] ' = if\n"
"\t    \\ Recognize '<char>'\n"
"\t    dup 3 = if\n"
"\t\t    over 2 chars + c@ [char] ' = if\n"
"\t\t\t    drop nip rdrop\n"
"\t\t\t    char+ c@ NUM_TYPE_SINGLE exit\n"
"\t\t    then\n"
"\t    then\n"
"    then\n"
"    r> drop\n"
"\n"
"\\ check for '-' at beginning, skip if present\n"
"    over c@ ascii - = \\ is it a '-'\n"
"    dup >r            \\ save flag\n"
"    IF 1 /string  ( -- base c-addr+1 cnt-1 , skip past minus sign )\n"
"    THEN\n"
"\n"
"    ( base c-addr cnt ) ( r: minus-flag )\n"
"    rot >r 0 0 2swap r>\n"
"    (>number-with-base) dup 0=   \\ convert as much as we can\n"
"    IF\n"
"        2drop    \\ drop addr cnt\n"
"        drop     \\ drop hi part of num\n"
"        r@       \\ check flag to see if '-' sign used\n"
"        IF  negate\n"
"        THEN\n"
"        NUM_TYPE_SINGLE\n"
"    ELSE  ( -- d addr cnt )\n"
"        1 = swap             \\ if final character is '.' then double\n"
"        c@ ascii . =  AND\n"
"        IF\n"
"            r@      \\ check flag to see if '-' sign used\n"
"            IF  dnegate\n"
"            THEN\n"
"            NUM_TYPE_DOUBLE\n"
"        ELSE\n"
"            2drop\n"
"            NUM_TYPE_BAD\n"
"        THEN\n"
"    THEN\n"
"    rdrop\n"
";\n"
"\n"
": (NUMBER?)   ( $addr -- 0 | n 1 | d 2 , convert string to number )\n"
"    count ((number?))\n"
";\n"
"\n"
"' (number?) is number?\n"
"\\ hex\n"
"\\ 0sp c\" xyz\" (number?) .s\n"
"\\ 0sp c\" 234\" (number?) .s\n"
"\\ 0sp c\" -234\" (number?) .s\n"
"\\ 0sp c\" 234.\" (number?) .s\n"
"\\ 0sp c\" -234.\" (number?) .s\n"
"\\ 0sp c\" 1234567855554444.\" (number?) .s\n"
"\n"
"\n"
"\\ ------------------------ OUTPUT ------------------------------\n"
"\\ Number output based on F83\n"
"variable HLD    \\ points to last character added\n"
"\n"
": hold   ( char -- , add character to text representation)\n"
"    -1 hld  +!\n"
"    hld @  c!\n"
";\n"
": <#     ( -- , setup conversion )\n"
"    pad hld !\n"
";\n"
": #>     ( d -- addr len , finish conversion )\n"
"    2drop  hld @  pad  over -\n"
";\n"
": sign   ( n -- , add '-' if negative )\n"
"    0<  if  ascii - hold  then\n"
";\n"
": #      ( d -- d , convert one digit )\n"
"   base @  mu/mod rot 9 over <\n"
"   IF  7 +\n"
"   THEN\n"
"   ascii 0 + hold\n"
";\n"
": #s     ( d -- d , convert remaining digits )\n"
"    BEGIN  #  2dup or 0=\n"
"    UNTIL\n"
";\n"
"\n"
"\n"
": (UD.) ( ud -- c-addr cnt )\n"
"    <# #s #>\n"
";\n"
": UD.   ( ud -- , print unsigned double number )\n"
"    (ud.)  type space\n"
";\n"
": UD.R  ( ud n -- )\n"
"    >r  (ud.)  r> over - spaces type\n"
";\n"
": (D.)  ( d -- c-addr cnt )\n"
"    tuck dabs <# #s rot sign #>\n"
";\n"
": D.    ( d -- )\n"
"    (d.)  type space\n"
";\n"
": D.R   ( d n -- , right justified )\n"
"    >r  (d.)  r>  over - spaces  type\n"
";\n"
"\n"
": (U.)  ( u -- c-addr cnt )\n"
"    0 (ud.)\n"
";\n"
": U.    ( u -- , print unsigned number )\n"
"    0 ud.\n"
";\n"
": U.R   ( u n -- , print right justified )\n"
"    >r  (u.)  r> over - spaces  type\n"
";\n"
": (.)   ( n -- c-addr cnt )\n"
"    dup abs 0 <# #s rot sign #>\n"
";\n"
": .     ( n -- , print signed number)\n"
"   (.)  type space\n"
";\n"
": .R    ( n l -- , print right justified)\n"
"    >r  (.)  r> over - spaces type\n"
";\n";

const char* numberio_fth = (const char*) temp_binary_data_103;

//================== private.fth ==================
static const unsigned char temp_binary_data_104[] =
"\\ @(#) private.fth 98/01/26 1.2\n"
"\\ PRIVATIZE\n"
"\\\n"
"\\ Privatize words that are only needed within the file\n"
"\\ and do not need to be exported.\n"
"\\\n"
"\\ Usage:\n"
"\\    PRIVATE{\n"
"\\    : FOO ;  \\ Everything between PRIVATE{ and }PRIVATE will become private.\n"
"\\    : MOO ;\n"
"\\    }PRIVATE\n"
"\\    : GOO   foo moo ;  \\ can use foo and moo\n"
"\\    PRIVATIZE          \\ smudge foo and moo\n"
"\\    ' foo              \\ will fail\n"
"\\\n"
"\\ Copyright 1996 Phil Burk\n"
"\\\n"
"\\ 19970701 PLB Use unsigned compares for machines with \"negative\" addresses.\n"
"\n"
"anew task-private.fth\n"
"\n"
"variable private-start\n"
"variable private-stop\n"
"$ 20 constant FLAG_SMUDGE\n"
"\n"
": PRIVATE{\n"
"    latest private-start !\n"
"    0 private-stop !\n"
";\n"
": }PRIVATE\n"
"    private-stop @ 0= not abort\" Extra }PRIVATE\"\n"
"    latest private-stop !\n"
";\n"
": PRIVATIZE  ( -- , smudge all words between PRIVATE{ and }PRIVATE )\n"
"    private-start @ 0= abort\" Missing PRIVATE{\"\n"
"    private-stop @ 0= abort\" Missing }PRIVATE\"\n"
"    private-stop @\n"
"    BEGIN\n"
"        dup private-start @ u>    \\ 19970701\n"
"    WHILE\n"
"\\       .\" Smudge \" dup id. cr\n"
"        dup c@ flag_smudge or over c!\n"
"        prevname\n"
"    REPEAT\n"
"    drop\n"
"    0 private-start !\n"
"    0 private-stop !\n"
";\n";

const char* private_fth = (const char*) temp_binary_data_104;

//================== require.fth ==================
static const unsigned char temp_binary_data_105[] =
"\\ REQUIRE and REQUIRED\n"
"\\\n"
"\\ This code is part of pForth.\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\n"
"private{\n"
"\n"
"\\ Has the file with name C-ADDR/U already been included?\n"
"\\\n"
"\\ This searches the \"::::<filename>\" marker created by INCLUDED.  This\n"
"\\ works for now, but may break if pForth ever receives wordlists.\n"
": INCLUDED? ( c-addr u -- flag )\n"
"    s\" ::::\" here place         ( c-addr u )\n"
"    here $append                ( )\n"
"    here find nip 0<>           ( found? )\n"
";\n"
"\n"
"\\ FIXME: use real PARSE-NAME when available\n"
": (PARSE-NAME) ( \"word\" -- c-addr u ) bl parse-word ;\n"
"\n"
"}private\n"
"\n"
": REQUIRED ( i*x c-addr u -- j*x ) 2dup included? IF 2drop ELSE included THEN ;\n"
": REQUIRE ( i*x \"name\" -- i*x ) (parse-name) required ;\n"
"\n"
"privatize\n";

const char* require_fth = (const char*) temp_binary_data_105;

//================== save-input.fth ==================
static const unsigned char temp_binary_data_106[] =
"\\ SAVE-INPUT and RESTORE-INPUT\n"
"\\\n"
"\\ This code is part of pForth.\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\n"
"anew task-save-input.fth\n"
"\n"
"private{\n"
"\n"
": SAVE-BUFFER ( -- column source-id 2 ) >in @ source-id 2 ;\n"
"\n"
"\\ Restore >IN from COLUMN unless COLUMN is too large.  Valid values\n"
"\\ for COLUMN are from 0 to (including) the length of SOURCE plus one.\n"
": RESTORE-COLUMN ( column -- flag )\n"
"    source nip 1+ over u<\n"
"    IF   drop  true\n"
"    ELSE >in ! false\n"
"    THEN\n"
";\n"
"\n"
"\\ Return the file-position of the beginning of the current line in\n"
"\\ file SOURCE-ID.  Assume that the current line is stored in SOURCE\n"
"\\ and that the current file-position is at an end-of-line (or\n"
"\\ end-of-file).\n"
": LINE-START-POSITION ( -- ud )\n"
"    source-id file-position throw\n"
"    \\ unless at end-of-file, subtract newline\n"
"    source-id file-size throw 2over d= 0= IF 1 s>d d- THEN\n"
"    \\ subtract line length\n"
"    source nip s>d d-\n"
";\n"
"\n"
": SAVE-FILE ( column line filepos:ud source-id 5 -- )\n"
"    >in @\n"
"    source-line-number@\n"
"    line-start-position\n"
"    source-id\n"
"    5\n"
";\n"
"\n"
": RESTORE-FILE ( column line filepos:ud -- flag )\n"
"    source-id reposition-file  IF 2drop true EXIT THEN\n"
"    refill                     0= IF 2drop true EXIT THEN\n"
"    source-line-number!\n"
"    restore-column\n"
";\n"
"\n"
": NDROP ( n*x n -- ) 0 ?DO drop LOOP ;\n"
"\n"
"}private\n"
"\n"
"\\ Source      Stack\n"
"\\ EVALUATE    >IN  SourceID=(-1)  2\n"
"\\ keyboard    >IN  SourceID=(0)   2\n"
"\\ file        >IN  lineNumber filePos  SourceID=(fileID) 5\n"
": SAVE-INPUT ( -- column {line filepos}? source-id n )\n"
"    source-id CASE\n"
"\t-1 OF save-buffer ENDOF\n"
"\t0  OF save-buffer ENDOF\n"
"\tdrop save-file EXIT\n"
"    ENDCASE\n"
";\n"
"\n"
": RESTORE-INPUT ( column {line filepos}? source-id n -- flag )\n"
"    over source-id <> IF ndrop true EXIT THEN\n"
"    drop\n"
"    CASE\n"
"\t-1 OF restore-column ENDOF\n"
"\t0  OF restore-column ENDOF\n"
"\tdrop restore-file EXIT\n"
"    ENDCASE\n"
";\n"
"\n"
"privatize\n";

const char* saveinput_fth = (const char*) temp_binary_data_106;

//================== savedicd.fth ==================
static const unsigned char temp_binary_data_107[] =
"\\ @(#) savedicd.fth 98/01/26 1.2\n"
"\\ Save dictionary as data table.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1987 Phil Burk\n"
"\\ All Rights Reserved.\n"
"\\\n"
"\\ 970311 PLB Fixed problem with calling SDAD when in HEX mode.\n"
"\\ 20010606 PLB Fixed AUTO.INIT , started with ';' !!\n"
"\n"
"decimal\n"
"ANEW TASK-SAVE_DIC_AS_DATA\n"
"\n"
"\\ !!! set to 4 for minimally sized dictionary to prevent DIAB\n"
"\\ compiler from crashing!  Allocate more space in pForth.\n"
"4 constant SDAD_NAMES_EXTRA   \\ space for additional names\n"
"4 constant SDAD_CODE_EXTRA    \\ space for additional names\n"
"\n"
"\\ buffer the file I/O for better performance\n"
"256 constant SDAD_BUFFER_SIZE\n"
"create SDAD-BUFFER SDAD_BUFFER_SIZE allot\n"
"variable SDAD-BUFFER-INDEX\n"
"variable SDAD-BUFFER-FID\n"
"        0 SDAD-BUFFER-FID !\n"
"\n"
": SDAD.FLUSH  ( -- ior )\n"
"    sdad-buffer sdad-buffer-index @  \\ data\n"
"\\ 2dup type\n"
"    sdad-buffer-fid @  write-file\n"
"    0 sdad-buffer-index !\n"
";\n"
"\n"
": SDAD.EMIT  ( char -- )\n"
"    sdad-buffer-index @  sdad_buffer_size >=\n"
"    IF\n"
"        sdad.flush abort\" SDAD.FLUSH failed!\"\n"
"    THEN\n"
"\\\n"
"    sdad-buffer sdad-buffer-index @ + c!\n"
"    1 sdad-buffer-index +!\n"
";\n"
"\n"
": SDAD.TYPE  ( c-addr cnt -- )\n"
"    0 DO\n"
"        dup c@ sdad.emit    \\ char to buffer\n"
"        1+   \\ advance char pointer\n"
"    LOOP\n"
"    drop\n"
";\n"
"\n"
": $SDAD.LINE  ( $addr -- )\n"
"    count sdad.type\n"
"    EOL sdad.emit\n"
";\n"
"\n"
": (U8.)  ( u -- a l , unsigned conversion, at least 8 digits )\n"
"    0 <#  # # # #  # # # #S #>\n"
";\n"
": (U2.)  ( u -- a l , unsigned conversion, at least 2 digits )\n"
"    0 <#  # #S #>\n"
";\n"
"\n"
": SDAD.CLOSE ( -- )\n"
"    SDAD-BUFFER-FID @ ?dup\n"
"    IF\n"
"        sdad.flush abort\" SDAD.FLUSH failed!\"\n"
"        close-file drop\n"
"        0 SDAD-BUFFER-FID !\n"
"    THEN\n"
";\n"
"\n"
": SDAD.OPEN  ( -- ior, open file )\n"
"    sdad.close\n"
"    s\" pfdicdat.h\" r/w create-file dup >r\n"
"    IF\n"
"        drop .\" Could not create file pfdicdat.h\" cr\n"
"    ELSE\n"
"        SDAD-BUFFER-FID !\n"
"    THEN\n"
"    r>\n"
";\n"
"\n"
": SDAD.DUMP.HEX  { val -- }\n"
"    base @ >r hex\n"
"    s\" 0x\" sdad.type\n"
"    val (u8.) sdad.type\n"
"    r> base !\n"
";\n"
": SDAD.DUMP.HEX,\n"
"    s\"    \" sdad.type\n"
"    sdad.dump.hex\n"
"    ascii , sdad.emit\n"
";\n"
"\n"
": SDAD.DUMP.HEX.BYTE  { val -- }\n"
"    base @ >r hex\n"
"    s\" 0x\" sdad.type\n"
"    val (u2.) sdad.type\n"
"    r> base !\n"
";\n"
": SDAD.DUMP.HEX.BYTE,\n"
"    sdad.dump.hex.byte\n"
"    ascii , sdad.emit\n"
";\n"
"\n"
": SDAD.DUMP.DATA { start-address end-address num-zeros | num-bytes -- }\n"
"    end-address start-address - -> num-bytes\n"
"    num-bytes 0\n"
"    ?DO\n"
"        i $ 7FF and 0= IF .\" 0x\" i .hex cr THEN   \\ progress report\n"
"        i 15 and 0=\n"
"        IF\n"
"\n"
"             EOL sdad.emit\n"
"             s\" /* \" sdad.type\n"
"             i sdad.dump.hex\n"
"             s\" : */ \" sdad.type\n"
"        THEN   \\ 16 bytes per line, print offset\n"
"        start-address   i + c@\n"
"        sdad.dump.hex.byte,\n"
"    LOOP\n"
"\\\n"
"    num-zeros 0\n"
"    ?DO\n"
"        i $ 7FF and 0= IF i . cr THEN   \\ progress report\n"
"        i 15 and 0= IF EOL sdad.emit THEN   \\ 15 numbers per line\n"
"        0 sdad.dump.hex.byte,\n"
"    LOOP\n"
";\n"
"\n"
": SDAD.DEFINE  { $name val -- }\n"
"    s\" #define \" sdad.type\n"
"    $name  count sdad.type\n"
"    s\"   (\" sdad.type\n"
"    val sdad.dump.hex\n"
"    c\" )\" $sdad.line\n"
";\n"
"\n"
": IS.LITTLE.ENDIAN?  ( -- flag , is Forth in Little Endian mode? )\n"
"    1 pad !\n"
"    pad c@\n"
";\n"
"\n"
": SDAD   { | fid -- }\n"
"    sdad.open abort\" sdad.open failed!\"\n"
"\\ Write headers.\n"
"    c\" /* This file generated by the Forth command SDAD */\" $sdad.line\n"
"\n"
"    c\" HEADERPTR\" headers-ptr @ namebase - sdad.define\n"
"    c\" RELCONTEXT\" context @ namebase - sdad.define\n"
"    c\" CODEPTR\" here codebase - sdad.define\n"
"    c\" IF_LITTLE_ENDIAN\" IS.LITTLE.ENDIAN? IF 1 ELSE 0 THEN sdad.define\n"
"\n"
".\" Saving Names\" cr\n"
"    s\" static const uint8_t MinDicNames[] = {\" sdad.type\n"
"    namebase headers-ptr @ SDAD_NAMES_EXTRA sdad.dump.data\n"
"    EOL sdad.emit\n"
"    c\" };\" $sdad.line\n"
"\n"
".\" Saving Code\" cr\n"
"    s\" static const uint8_t MinDicCode[] = {\" sdad.type\n"
"    codebase here SDAD_CODE_EXTRA sdad.dump.data\n"
"    EOL sdad.emit\n"
"    c\" };\" $sdad.line\n"
"\n"
"    sdad.close\n"
";\n"
"\n"
"if.forgotten sdad.close\n"
"\n"
": AUTO.INIT ( -- , init at launch )\n"
"    auto.init \\ daisy chain initialization\n"
"    0 SDAD-BUFFER-FID !\n"
"    0 SDAD-BUFFER-INDEX !\n"
";\n"
"\n"
".\" Enter: SDAD\" cr\n";

const char* savedicd_fth = (const char*) temp_binary_data_107;

//================== see.fth ==================
static const unsigned char temp_binary_data_108[] =
"\\ @(#) see.fth 98/01/26 1.4\n"
"\\ SEE ( <name> -- , disassemble pForth word )\n"
"\\\n"
"\\ Copyright 1996 Phil Burk\n"
"\n"
"' file? >code rfence a!\n"
"\n"
"anew task-see.fth\n"
"\n"
": .XT ( xt -- , print execution tokens name )\n"
"    >name\n"
"    dup c@ flag_immediate and\n"
"    IF\n"
"        .\" POSTPONE \"\n"
"    THEN\n"
"    id. space\n"
";\n"
"\n"
"\\ dictionary may be defined as byte code or cell code\n"
"0 constant BYTE_CODE\n"
"\n"
"BYTE_CODE [IF]\n"
"    : CODE@ ( addr -- xt , fetch from code space )   C@ ;\n"
"    1 constant CODE_CELL\n"
"    .( BYTE_CODE not implemented) abort\n"
"[ELSE]\n"
"    : CODE@ ( addr -- xt , fetch from code space )   @ ;\n"
"    CELL constant CODE_CELL\n"
"[THEN]\n"
"\n"
"private{\n"
"\n"
"0 value see_level  \\ level of conditional imdentation\n"
"0 value see_addr   \\ address of next token\n"
"0 value see_out\n"
"\n"
": SEE.INDENT.BY ( -- n )\n"
"    see_level 1+ 1 max 4 *\n"
";\n"
"\n"
": SEE.CR\n"
"    >newline\n"
"    see_addr .\" ( \".hex .\" )\"\n"
"    see.indent.by spaces\n"
"    0 -> see_out\n"
";\n"
": SEE.NEWLINE\n"
"    see_out 0>\n"
"    IF see.cr\n"
"    THEN\n"
";\n"
": SEE.CR?\n"
"    see_out 6 >\n"
"    IF\n"
"        see.newline\n"
"    THEN\n"
";\n"
": SEE.OUT+\n"
"    1 +-> see_out\n"
";\n"
"\n"
": SEE.ADVANCE\n"
"    code_cell +-> see_addr\n"
";\n"
": SEE.GET.INLINE ( -- n )\n"
"    see_addr @\n"
";\n"
"\n"
": SEE.GET.TARGET  ( -- branch-target-addr )\n"
"    see_addr @ see_addr +\n"
";\n"
"\n"
": SEE.SHOW.LIT ( -- )\n"
"    see.get.inline .\n"
"    see.advance\n"
"    see.out+\n"
";\n"
"\n"
"exists? F* [IF]\n"
": SEE.SHOW.FLIT ( -- )\n"
"    see_addr f@ f.\n"
"    1 floats +-> see_addr\n"
"    see.out+\n"
";\n"
"[THEN]\n"
"\n"
": SEE.SHOW.ALIT ( -- )\n"
"    see.get.inline >name id. space\n"
"    see.advance\n"
"    see.out+\n"
";\n"
"\n"
": SEE.SHOW.STRING ( -- )\n"
"    see_addr count 2dup + aligned -> see_addr type\n"
"    see.out+\n"
";\n"
": SEE.SHOW.TARGET ( -- )\n"
"    see.get.target .hex see.advance\n"
";\n"
"\n"
": SEE.BRANCH ( -- addr | , handle branch )\n"
"    -1 +-> see_level\n"
"    see.newline\n"
"    see.get.inline  0>\n"
"    IF  \\ forward branch\n"
"        .\" ELSE \"\n"
"        see.get.target \\ calculate address of target\n"
"        1 +-> see_level\n"
"        nip \\ remove old address for THEN\n"
"    ELSE\n"
"        .\" REPEAT \" see.get.target .hex\n"
"        drop \\ remove old address for THEN\n"
"    THEN\n"
"    see.advance\n"
"    see.cr\n"
";\n"
"\n"
": SEE.0BRANCH ( -- addr | , handle 0branch )\n"
"    see.newline\n"
"    see.get.inline 0>\n"
"    IF  \\ forward branch\n"
"        .\" IF or WHILE \"\n"
"        see.get.target \\ calculate adress of target\n"
"        1 +-> see_level\n"
"    ELSE\n"
"        .\" UNTIL=>\" see.get.target .hex\n"
"    THEN\n"
"    see.advance\n"
"    see.cr\n"
";\n"
"\n"
": SEE.XT  { xt -- }\n"
"    xt\n"
"    CASE\n"
"        0 OF see_level 0> IF .\" EXIT \" see.out+ ELSE .\" ;\" 0  -> see_addr THEN ENDOF\n"
"        ['] (LITERAL) OF see.show.lit ENDOF\n"
"        ['] (ALITERAL) OF see.show.alit ENDOF\n"
"[ exists? (FLITERAL) [IF] ]\n"
"        ['] (FLITERAL) OF see.show.flit ENDOF\n"
"[ [THEN] ]\n"
"        ['] BRANCH    OF see.branch ENDOF\n"
"        ['] 0BRANCH   OF see.0branch ENDOF\n"
"        ['] (LOOP)    OF -1 +-> see_level see.newline .\" LOOP \" see.advance see.cr  ENDOF\n"
"        ['] (+LOOP)   OF -1 +-> see_level see.newline .\" +LOOP\" see.advance see.cr  ENDOF\n"
"        ['] (DO)      OF see.newline .\" DO\" 1 +-> see_level see.cr ENDOF\n"
"        ['] (?DO)     OF see.newline .\" ?DO \" see.advance 1 +-> see_level see.cr ENDOF\n"
"        ['] (.\") OF .' .\" ' see.show.string .' \" ' ENDOF\n"
"        ['] (C\") OF .' C\" ' see.show.string .' \" ' ENDOF\n"
"        ['] (S\") OF .' S\" ' see.show.string .' \" ' ENDOF\n"
"\n"
"        see.cr? xt .xt see.out+\n"
"    ENDCASE\n"
";\n"
"\n"
": (SEE) { cfa | xt  -- }\n"
"    0 -> see_level\n"
"    cfa -> see_addr\n"
"    see.cr\n"
"    0 \\ fake address for THEN handler\n"
"    BEGIN\n"
"        see_addr code@ -> xt\n"
"        BEGIN\n"
"            dup see_addr ( >newline .s ) =\n"
"        WHILE\n"
"            -1 +-> see_level see.newline\n"
"            .\" THEN \" see.cr\n"
"            drop\n"
"        REPEAT\n"
"        CODE_CELL +-> see_addr\n"
"        xt see.xt\n"
"        see_addr 0=\n"
"    UNTIL\n"
"    cr\n"
"    0= not abort\" SEE conditional analyser nesting failed!\"\n"
";\n"
"\n"
"}PRIVATE\n"
"\n"
": SEE  ( <name> -- , disassemble )\n"
"    '\n"
"    dup ['] FIRST_COLON >\n"
"    IF\n"
"        >code (see)\n"
"    ELSE\n"
"        >name id.\n"
"        .\"  is primitive defined in 'C' kernel.\" cr\n"
"    THEN\n"
";\n"
"\n"
"PRIVATIZE\n"
"\n"
"0 [IF]\n"
"\n"
": SEE.JOKE\n"
"    dup swap drop\n"
";\n"
"\n"
": SEE.IF\n"
"    IF\n"
"        .\" hello\" cr\n"
"    ELSE\n"
"        .\" bye\" cr\n"
"    THEN\n"
"    see.joke\n"
";\n"
": SEE.DO\n"
"    4 0\n"
"    DO\n"
"        i . cr\n"
"    LOOP\n"
";\n"
": SEE.\"\n"
"    .\" Here are some strings.\" cr\n"
"    c\" Forth string.\" count type cr\n"
"    s\" Addr/Cnt string\" type cr\n"
";\n"
"\n"
"[THEN]\n";

const char* see_fth = (const char*) temp_binary_data_108;

//================== siev.fth ==================
static const unsigned char temp_binary_data_109[] =
"\\ #! /usr/stud/paysan/bin/forth\n"
"\n"
"DECIMAL\n"
"\\ : SECS TIME&DATE  SWAP 60 * + SWAP 3600 * +  NIP NIP NIP ;\n"
"CREATE FLAGS 8190 ALLOT\n"
"variable eflag\n"
"\\ FLAGS 8190 + CONSTANT EFLAG\n"
"\n"
"\\ use secondary fill like pForth   !!!\n"
": FILL { caddr num charval -- }\n"
"    num 0\n"
"    ?DO\n"
"        charval caddr i + c!\n"
"    LOOP\n"
";\n"
"\n"
": PRIMES  ( -- n )  FLAGS 8190 1 FILL  0 3  EFLAG @ FLAGS\n"
"  DO   I C@\n"
"       IF  DUP I + DUP EFLAG @ <\n"
"           IF    EFLAG @ SWAP\n"
"                 DO  0 I C! DUP  +LOOP\n"
"           ELSE  DROP  THEN  SWAP 1+ SWAP\n"
"           THEN  2 +\n"
"       LOOP  DROP ;\n"
"\n"
": BENCHMARK  0 100 0 DO  PRIMES NIP  LOOP ;           \\ !!! ONLY 100\n"
"\\ SECS BENCHMARK . SECS SWAP - CR . .( secs)\n"
": main\n"
"    flags 8190 + eflag !\n"
"    benchmark ( . ) drop\n"
";\n";

const char* siev_fth = (const char*) temp_binary_data_109;

//================== smart_if.fth ==================
static const unsigned char temp_binary_data_110[] =
"\\ @(#) smart_if.fth 98/01/26 1.2\n"
"\\ Smart Conditionals\n"
"\\ Allow use of if, do, begin, etc.outside of colon definitions.\n"
"\\\n"
"\\ Thanks to Mitch Bradley for the idea.\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\n"
"anew task-smart_if.fth\n"
"\n"
"variable SMIF-XT    \\ execution token for conditional code\n"
"variable SMIF-DEPTH \\ depth of nested conditionals\n"
"\n"
": SMIF{   ( -- , if executing, start compiling, setup depth )\n"
"    state @ 0=\n"
"    IF\n"
"        :noname smif-xt !\n"
"        1 smif-depth !\n"
"    ELSE\n"
"        1 smif-depth +!\n"
"    THEN\n"
";\n"
"\n"
": }SMIF  ( -- , unnest, stop compiling, execute code and forget )\n"
"    smif-xt @\n"
"    IF\n"
"        -1 smif-depth +!\n"
"        smif-depth @ 0 <=\n"
"        IF\n"
"            postpone ;             \\ stop compiling\n"
"            smif-xt @ execute      \\ execute conditional code\n"
"            smif-xt @ >code dp !   \\ forget conditional code\n"
"            0 smif-xt !   \\ clear so we don't mess up later\n"
"        THEN\n"
"    THEN\n"
";\n"
"\n"
"\\ redefine conditionals to use smart mode\n"
": IF      smif{   postpone if     ; immediate\n"
": DO      smif{   postpone do     ; immediate\n"
": ?DO     smif{   postpone ?do    ; immediate\n"
": BEGIN   smif{   postpone begin  ; immediate\n"
": THEN    postpone then    }smif  ; immediate\n"
": REPEAT  postpone repeat  }smif  ; immediate\n"
": UNTIL   postpone until   }smif  ; immediate\n"
": LOOP    postpone loop    }smif  ; immediate\n"
": +LOOP   postpone +loop   }smif  ; immediate\n";

const char* smart_if_fth = (const char*) temp_binary_data_110;

//================== strings.fth ==================
static const unsigned char temp_binary_data_111[] =
"\\ @(#) strings.fth 98/01/26 1.2\n"
"\\ String support for PForth\n"
"\\\n"
"\\ Copyright Phil Burk 1994\n"
"\n"
"ANEW TASK-STRINGS.FTH\n"
"\n"
": -TRAILING  ( c-addr u1 -- c-addr u2 , strip trailing blanks )\n"
"    dup 0>\n"
"    IF\n"
"        BEGIN\n"
"            2dup 1- chars + c@ bl =\n"
"            over 0> and\n"
"        WHILE\n"
"            1-\n"
"        REPEAT\n"
"    THEN\n"
";\n"
"\n"
"\\ Structure of string table\n"
": $ARRAY  (  )\n"
"    CREATE  ( #strings #chars_max --  )\n"
"        dup ,\n"
"        2+ * even-up allot\n"
"    DOES>    ( index -- $addr )\n"
"        dup @  ( get #chars )\n"
"        rot * + cell+\n"
";\n"
"\n"
"\\ Compare two strings\n"
": $= ( $1 $2 -- flag , true if equal )\n"
"    -1 -rot\n"
"    dup c@ 1+ 0\n"
"    DO  dup c@ tolower\n"
"        2 pick c@ tolower -\n"
"        IF rot drop 0 -rot LEAVE\n"
"        THEN\n"
"        1+ swap 1+ swap\n"
"    LOOP 2drop\n"
";\n"
"\n"
": TEXT=  ( addr1 addr2 count -- flag )\n"
"    >r -1 -rot\n"
"    r> 0\n"
"    ?DO  dup c@ tolower\n"
"        2 pick c@ tolower -\n"
"        IF rot drop 0 -rot LEAVE\n"
"        THEN\n"
"        1+ swap 1+ swap\n"
"    LOOP 2drop\n"
";\n"
"\n"
": TEXT=?  ( addr1 count addr2 -- flag , for JForth compatibility )\n"
"    swap text=\n"
";\n"
"\n"
": $MATCH?  ( $string1 $string2 -- flag , case INsensitive )\n"
"    dup c@ 1+ text=\n"
";\n"
"\n"
"\n"
": INDEX ( $string char -- false | address_char true , search for char in string )\n"
"    >r >r 0 r> r>\n"
"    over c@ 1+ 1\n"
"    DO  over i + c@ over =\n"
"        IF  rot drop\n"
"            over i + rot rot LEAVE\n"
"        THEN\n"
"    LOOP 2drop\n"
"    ?dup 0= 0=\n"
";\n"
"\n"
"\n"
": $APPEND.CHAR  ( $string char -- ) \\ ugly stack diagram\n"
"    over count chars + c!\n"
"    dup c@ 1+ swap c!\n"
";\n"
"\n"
"\\ ----------------------------------------------\n"
": ($ROM)  ( index address -- $string )\n"
"    ( -- index address )\n"
"    swap 0\n"
"    ?DO dup c@ 1+ + aligned\n"
"    LOOP\n"
";\n"
"\n"
": $ROM ( packed array of strings, unalterable )\n"
"    CREATE ( <name> -- )\n"
"    DOES> ( index -- $string )  ($rom)\n"
";\n"
"\n"
": TEXTROM ( packed array of strings, unalterable )\n"
"    CREATE ( <name> -- )\n"
"    DOES> ( index -- address count )  ($rom) count\n"
";\n"
"\n"
"\\ -----------------------------------------------\n";

const char* strings_fth = (const char*) temp_binary_data_111;

//================== system.fth ==================
static const unsigned char temp_binary_data_112[] =
": FIRST_COLON ;\n"
"\n"
": LATEST context @ ;\n"
"\n"
": FLAG_IMMEDIATE 64 ;\n"
"\n"
": IMMEDIATE\n"
"        latest dup c@ flag_immediate OR\n"
"        swap c!\n"
";\n"
"\n"
": (   41 word drop ; immediate\n"
"( That was the definition for the comment word. )\n"
"( Now we can add comments to what we are doing! )\n"
"( Note that we are in decimal numeric input mode. )\n"
"\n"
": \\ ( <line> -- , comment out rest of line )\n"
"        EOL word drop\n"
"; immediate\n"
"\n"
"\\ 1 echo !  \\ Uncomment this line to echo Forth code while compiling.\n"
"\n"
"\\ *********************************************************************\n"
"\\ This is another style of comment that is common in Forth.\n"
"\\ pFORTH - Portable Forth System\n"
"\\ Based on HMSL Forth\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\\ *********************************************************************\n"
"\n"
": COUNT  dup 1+ swap c@ ;\n"
"\n"
"\\ Miscellaneous support words\n"
": ON ( addr -- , set true )\n"
"        -1 swap !\n"
";\n"
": OFF ( addr -- , set false )\n"
"        0 swap !\n"
";\n"
"\n"
": CELL+ ( n -- n+cell )  cell + ;\n"
": CELL- ( n -- n+cell )  cell - ;\n"
": CELL* ( n -- n*cell )  cells ;\n"
"\n"
": CHAR+ ( n -- n+size_of_char ) 1+ ;\n"
": CHARS ( n -- n*size_of_char , don't do anything)  ; immediate\n"
"\n"
"\\ useful stack manipulation words\n"
": -ROT ( a b c -- c a b )\n"
"        rot rot\n"
";\n"
": 3DUP ( a b c -- a b c a b c )\n"
"        2 pick 2 pick 2 pick\n"
";\n"
": 2DROP ( a b -- )\n"
"        drop drop\n"
";\n"
": NIP ( a b -- b )\n"
"        swap drop\n"
";\n"
": TUCK ( a b -- b a b )\n"
"        swap over\n"
";\n"
"\n"
": <= ( a b -- f , true if A <= b )\n"
"        > 0=\n"
";\n"
": >= ( a b -- f , true if A >= b )\n"
"        < 0=\n"
";\n"
"\n"
": INVERT ( n -- 1'comp )\n"
"    -1 xor\n"
";\n"
"\n"
": NOT ( n -- !n , logical negation )\n"
"        0=\n"
";\n"
"\n"
": NEGATE ( n -- -n )\n"
"        0 swap -\n"
";\n"
"\n"
": DNEGATE ( d -- -d , negate by doing 0-d )\n"
"        0 0 2swap d-\n"
";\n"
"\n"
"\n"
"\\ --------------------------------------------------------------------\n"
"\n"
": ID.   ( nfa -- )\n"
"    count 31 and type\n"
";\n"
"\n"
": DECIMAL   10 base !  ;\n"
": OCTAL      8 base !  ;\n"
": HEX       16 base !  ;\n"
": BINARY     2 base !  ;\n"
"\n"
": PAD ( -- addr )\n"
"        here 128 +\n"
";\n"
"\n"
": $MOVE ( $src $dst -- )\n"
"        over c@ 1+ cmove\n"
";\n"
": BETWEEN ( n lo hi -- flag , true if between lo & hi )\n"
"        >r over r> > >r\n"
"        < r> or 0=\n"
";\n"
": [ ( -- , enter interpreter mode )\n"
"        0 state !\n"
"; immediate\n"
": ] ( -- enter compile mode )\n"
"        1 state !\n"
";\n"
"\n"
": EVEN-UP  ( n -- n | n+1 , make even )  dup 1 and +  ;\n"
": ALIGNED  ( addr -- a-addr )\n"
"        [ cell 1- ] literal +\n"
"        [ cell 1- invert ] literal and\n"
";\n"
": ALIGN ( -- , align DP )  dp @ aligned dp ! ;\n"
": ALLOT ( nbytes -- , allot space in dictionary ) dp +! ( align ) ;\n"
"\n"
": C,    ( c -- )  here c! 1 chars dp +! ;\n"
": W,    ( w -- )  dp @ even-up dup dp !    w!  2 chars dp +! ;\n"
": , ( n -- , lay into dictionary )  align here !  cell allot ;\n"
"\n"
"\\ Dictionary conversions ------------------------------------------\n"
"\n"
": N>NEXTLINK  ( nfa -- nextlink , traverses name field )\n"
"        dup c@ 31 and 1+ + aligned\n"
";\n"
"\n"
": NAMEBASE  ( -- base-of-names )\n"
"        Headers-Base @\n"
";\n"
": CODEBASE  ( -- base-of-code dictionary )\n"
"        Code-Base @\n"
";\n"
"\n"
": NAMELIMIT  ( -- limit-of-names )\n"
"        Headers-limit @\n"
";\n"
": CODELIMIT  ( -- limit-of-code, last address in dictionary )\n"
"        Code-limit @\n"
";\n"
"\n"
": NAMEBASE+   ( rnfa -- nfa , convert relocatable nfa to actual )\n"
"        namebase +\n"
";\n"
"\n"
": >CODE ( xt -- secondary_code_address, not valid for primitives )\n"
"        codebase +\n"
";\n"
"\n"
": CODE> ( secondary_code_address -- xt , not valid for primitives )\n"
"        codebase -\n"
";\n"
"\n"
": N>LINK  ( nfa -- lfa )\n"
"        2 CELLS -\n"
";\n"
"\n"
": >BODY   ( xt -- pfa )\n"
"    >code body_offset +\n"
";\n"
"\n"
": BODY>   ( pfa -- xt )\n"
"    body_offset - code>\n"
";\n"
"\n"
"\\ convert between addresses useable by @, and relocatable addresses.\n"
": USE->REL  ( useable_addr -- rel_addr )\n"
"        codebase -\n"
";\n"
": REL->USE  ( rel_addr -- useable_addr )\n"
"        codebase +\n"
";\n"
"\n"
"\\ for JForth code\n"
"\\ : >REL  ( adr -- adr )  ; immediate\n"
"\\ : >ABS  ( adr -- adr )  ; immediate\n"
"\n"
": X@ ( addr -- xt , fetch execution token from relocatable )   @ ;\n"
": X! ( addr -- xt , store execution token as relocatable )   ! ;\n"
"\n"
"\\ Compiler support ------------------------------------------------\n"
": COMPILE, ( xt -- , compile call to xt )\n"
"        ,\n"
";\n"
"\n"
"( Compiler support , based on FIG )\n"
": [COMPILE]  ( <name> -- , compile now even if immediate )\n"
"    ' compile,\n"
";  IMMEDIATE\n"
"\n"
": (COMPILE) ( xt -- , postpone compilation of token )\n"
"        [compile] literal       ( compile a call to literal )\n"
"        ( store xt of word to be compiled )\n"
"\n"
"        [ ' compile, ] literal   \\ compile call to compile,\n"
"        compile,\n"
";\n"
"\n"
": COMPILE  ( <name> -- , save xt and compile later )\n"
"    ' (compile)\n"
"; IMMEDIATE\n"
"\n"
"\n"
": :NONAME ( -- xt , begin compilation of headerless secondary )\n"
"        align\n"
"        here code>   \\ convert here to execution token\n"
"        ]\n"
";\n"
"\n"
"\\ Error codes defined in ANSI Exception word set.\n"
": ERR_ABORT         -1 ;   \\ general abort\n"
": ERR_ABORTQ        -2 ;   \\ for abort\"\n"
": ERR_EXECUTING    -14 ;   \\ compile time word while not compiling\n"
": ERR_PAIRS        -22 ;   \\ mismatch in conditional\n"
": ERR_DEFER       -258 ;  \\ not a deferred word\n"
"\n"
": ABORT ( i*x -- )\n"
"    ERR_ABORT throw\n"
";\n"
"\n"
"\\ Conditionals in '83 form -----------------------------------------\n"
": CONDITIONAL_KEY ( -- , lazy constant ) 29521 ;\n"
": ?CONDITION   ( f -- )  conditional_key - err_pairs ?error ;\n"
": >MARK      ( -- addr )   here 0 ,  ;\n"
": >RESOLVE   ( addr -- )   here over - swap !  ;\n"
": <MARK      ( -- addr )   here  ;\n"
": <RESOLVE   ( addr -- )   here - ,  ;\n"
"\n"
": ?COMP  ( -- , error if not compiling )\n"
"        state @ 0= err_executing ?error\n"
";\n"
": ?PAIRS ( n m -- )\n"
"        - err_pairs ?error\n"
";\n"
"\\ conditional primitives\n"
": IF     ( -- f orig )  ?comp compile 0branch  conditional_key >mark     ; immediate\n"
": THEN   ( f orig -- )  swap ?condition  >resolve   ; immediate\n"
": BEGIN  ( -- f dest )  ?comp conditional_key <mark   ; immediate\n"
": AGAIN  ( f dest -- )  compile branch  swap ?condition  <resolve  ; immediate\n"
": UNTIL  ( f dest -- )  compile 0branch swap ?condition  <resolve  ; immediate\n"
": AHEAD  ( -- f orig )  compile branch   conditional_key >mark     ; immediate\n"
"\n"
"\\ conditionals built from primitives\n"
": ELSE   ( f orig1 -- f orig2 )\n"
"    [compile] AHEAD  2swap [compile] THEN  ; immediate\n"
": WHILE  ( f dest -- f orig f dest )  [compile]  if   2swap ; immediate\n"
": REPEAT ( -- f orig f dest ) [compile] again  [compile] then  ; immediate\n"
"\n"
": [']  ( <name> -- xt , define compile time tick )\n"
"        ?comp ' [compile] literal\n"
"; immediate\n"
"\n"
"\\ for example:\n"
"\\ compile time:  compile create , (does>) then ;\n"
"\\ execution time:  create <name>, ',' data, then patch pi to point to @\n"
"\\    : con create , does> @ ;\n"
"\\    345 con pi\n"
"\\    pi\n"
"\\\n"
": (DOES>)  ( xt -- , modify previous definition to execute code at xt )\n"
"        latest name> >code \\ get address of code for new word\n"
"        cell + \\ offset to second cell in create word\n"
"        !      \\ store execution token of DOES> code in new word\n"
";\n"
"\n"
": DOES>   ( -- , define execution code for CREATE word )\n"
"        0 [compile] literal \\ dummy literal to hold xt\n"
"        here cell-          \\ address of zero in literal\n"
"        compile (does>)     \\ call (DOES>) from new creation word\n"
"        >r                  \\ move addrz to return stack so ; doesn't see stack garbage\n"
"        [compile] ;         \\ terminate part of code before does>\n"
"        r>\n"
"        :noname       ( addrz xt )\n"
"        swap !              \\ save execution token in literal\n"
"; immediate\n"
"\n"
": VARIABLE  ( <name> -- )\n"
"    CREATE 0 , \\ IMMEDIATE\n"
"\\       DOES> [compile] aliteral  \\ %Q This could be optimised\n"
";\n"
"\n"
": 2VARIABLE  ( <name> -c- ) ( -x- addr )\n"
"        create 0 , 0 ,\n"
";\n"
"\n"
": CONSTANT  ( n <name> -c- ) ( -x- n )\n"
"        CREATE , ( n -- )\n"
"        DOES> @ ( -- n )\n"
";\n"
"\n"
"\n"
"\n"
"0 1- constant -1\n"
"0 2- constant -2\n"
"\n"
": 2! ( x1 x2 addr -- , store x2 followed by x1 )\n"
"        swap over ! cell+ !\n"
";\n"
": 2@ ( addr -- x1 x2 )\n"
"        dup cell+ @ swap @\n"
";\n"
"\n"
"\n"
": ABS ( n -- |n| )\n"
"        dup 0<\n"
"        IF negate\n"
"        THEN\n"
";\n"
": DABS ( d -- |d| )\n"
"        dup 0<\n"
"        IF dnegate\n"
"        THEN\n"
";\n"
"\n"
": S>D  ( s -- d , extend signed single precision to double )\n"
"        dup 0<\n"
"        IF -1\n"
"        ELSE 0\n"
"        THEN\n"
";\n"
"\n"
": D>S ( d -- s ) drop ;\n"
"\n"
": /MOD ( a b -- rem quo , unsigned version, FIXME )\n"
"        >r s>d r> um/mod\n"
";\n"
"\n"
": MOD ( a b -- rem )\n"
"        /mod drop\n"
";\n"
"\n"
": 2* ( n -- n*2 )\n"
"        1 lshift\n"
";\n"
": 2/ ( n -- n/2 )\n"
"        1 arshift\n"
";\n"
"\n"
": D2*  ( d -- d*2 )\n"
"        2* over\n"
"        cell 8 * 1- rshift or  swap\n"
"        2* swap\n"
";\n"
"\n"
": D= ( xd1 xd2 -- flag )\n"
"\trot = -rot = and\n"
";\n"
"\n"
": D< ( d1 d2 -- flag )\n"
"    d- nip 0<\n"
";\n"
"\n"
": D> ( d1 d2 -- flag )\n"
"    2swap d<\n"
";\n"
"\n"
"\\ define some useful constants ------------------------------\n"
"1 0= constant FALSE\n"
"0 0= constant TRUE\n"
"32 constant BL\n"
"\n"
"\n"
"\\ Store and Fetch relocatable data addresses. ---------------\n"
": IF.USE->REL  ( use -- rel , preserve zero )\n"
"        dup IF use->rel THEN\n"
";\n"
": IF.REL->USE  ( rel -- use , preserve zero )\n"
"        dup IF rel->use THEN\n"
";\n"
"\n"
": A!  ( dictionary_address addr -- )\n"
"    >r if.use->rel r> !\n"
";\n"
": A@  ( addr -- dictionary_address )\n"
"    @ if.rel->use\n"
";\n"
"\n"
": A, ( dictionary_address -- )\n"
"    if.use->rel ,\n"
";\n"
"\n"
"\\ Stack data structure ----------------------------------------\n"
"\\ This is a general purpose stack utility used to implement necessary\n"
"\\ stacks for the compiler or the user.  Not real fast.\n"
"\\ These stacks grow up which is different then normal.\n"
"\\   cell 0 - stack pointer, offset from pfa of word\n"
"\\   cell 1 - limit for range checking\n"
"\\   cell 2 - first data location\n"
"\n"
": :STACK   ( #cells -- )\n"
"        CREATE  2 cells ,          ( offset of first data location )\n"
"                dup ,              ( limit for range checking, not currently used )\n"
"                cells cell+ allot  ( allot an extra cell for safety )\n"
";\n"
"\n"
": >STACK  ( n stack -- , push onto stack, postincrement )\n"
"        dup @ 2dup cell+ swap ! ( -- n stack offset )\n"
"        + !\n"
";\n"
"\n"
": STACK>  ( stack -- n , pop , predecrement )\n"
"        dup @ cell- 2dup swap !\n"
"        + @\n"
";\n"
"\n"
": STACK@ ( stack -- n , copy )\n"
"        dup @ cell- + @\n"
";\n"
"\n"
": STACK.PICK ( index stack -- n , grab Nth from top of stack )\n"
"        dup @ cell- +\n"
"        swap cells -   \\ offset for index\n"
"        @\n"
";\n"
": STACKP ( stack -- ptr , to next empty location on stack )\n"
"    dup @ +\n"
";\n"
"\n"
": 0STACKP  ( stack -- , clear stack)\n"
"    8 swap !\n"
";\n"
"\n"
"32 :stack ustack\n"
"ustack 0stackp\n"
"\n"
"\\ Define JForth like words.\n"
": >US ustack >stack ;\n"
": US> ustack stack> ;\n"
": US@ ustack stack@ ;\n"
": 0USP ustack 0stackp ;\n"
"\n"
"\n"
"\\ DO LOOP ------------------------------------------------\n"
"\n"
"3 constant do_flag\n"
"4 constant leave_flag\n"
"5 constant ?do_flag\n"
"\n"
": DO    ( -- , loop-back do_flag jump-from ?do_flag )\n"
"        ?comp\n"
"        compile  (do)\n"
"        here >us do_flag  >us  ( for backward branch )\n"
"; immediate\n"
"\n"
": ?DO    ( -- , loop-back do_flag jump-from ?do_flag  , on user stack )\n"
"        ?comp\n"
"        ( leave address to set for forward branch )\n"
"        compile  (?do)\n"
"        here 0 ,\n"
"        here >us do_flag  >us  ( for backward branch )\n"
"        >us ( for forward branch ) ?do_flag >us\n"
"; immediate\n"
"\n"
": LEAVE  ( -- addr leave_flag )\n"
"        compile (leave)\n"
"        here 0 , >us\n"
"        leave_flag >us\n"
"; immediate\n"
"\n"
": LOOP-FORWARD  ( -us- jump-from ?do_flag -- )\n"
"        BEGIN\n"
"                us@ leave_flag =\n"
"                us@ ?do_flag =\n"
"                OR\n"
"        WHILE\n"
"                us> leave_flag =\n"
"                IF\n"
"                        us> here over - cell+ swap !\n"
"                ELSE\n"
"                        us> dup\n"
"                        here swap -\n"
"                        cell+ swap !\n"
"                THEN\n"
"        REPEAT\n"
";\n"
"\n"
": LOOP-BACK  (  loop-addr do_flag -us- )\n"
"        us> do_flag ?pairs\n"
"        us> here -  here\n"
"        !\n"
"        cell allot\n"
";\n"
"\n"
": LOOP    ( -- , loop-back do_flag jump-from ?do_flag )\n"
"   compile  (loop)\n"
"   loop-forward loop-back\n"
"; immediate\n"
"\n"
"\\ : DOTEST 5 0 do 333 . loop 888 . ;\n"
"\\ : ?DOTEST0 0 0 ?do 333 . loop 888 . ;\n"
"\\ : ?DOTEST1 5 0 ?do 333 . loop 888 . ;\n"
"\n"
": +LOOP    ( -- , loop-back do_flag jump-from ?do_flag )\n"
"   compile  (+loop)\n"
"   loop-forward loop-back\n"
"; immediate\n"
"\n"
": UNLOOP ( loop-sys -r- )\n"
"        r> \\ save return pointer\n"
"        rdrop rdrop\n"
"        >r\n"
";\n"
"\n"
": RECURSE ( ? -- ? , call the word currently being defined )\n"
"        latest  name> compile,\n"
"; immediate\n"
"\n"
"\n"
"\n"
": SPACE  bl emit ;\n"
": SPACES  512 min 0 max 0 ?DO space LOOP ;\n"
": 0SP depth 0 ?do drop loop ;\n"
"\n"
": >NEWLINE ( -- , CR if needed )\n"
"        out @ 0>\n"
"        IF cr\n"
"        THEN\n"
";\n"
"\n"
"\n"
"\\ Support for DEFER --------------------\n"
": CHECK.DEFER  ( xt -- , error if not a deferred word by comparing to type )\n"
"    >code @\n"
"        ['] emit >code @\n"
"        - err_defer ?error\n"
";\n"
"\n"
": >is ( xt -- address_of_vector )\n"
"        >code\n"
"        cell +\n"
";\n"
"\n"
": (IS)  ( xt_do xt_deferred -- )\n"
"        >is !\n"
";\n"
"\n"
": IS  ( xt <name> -- , act like normal IS )\n"
"        '  \\ xt\n"
"        dup check.defer\n"
"        state @\n"
"        IF [compile] literal compile (is)\n"
"        ELSE (is)\n"
"        THEN\n"
"; immediate\n"
"\n"
": (WHAT'S)  ( xt -- xt_do )\n"
"        >is @\n"
";\n"
": WHAT'S  ( <name> -- xt , what will deferred word call? )\n"
"        '  \\ xt\n"
"        dup check.defer\n"
"        state @\n"
"        IF [compile] literal compile (what's)\n"
"        ELSE (what's)\n"
"        THEN\n"
"; immediate\n"
"\n"
": /STRING   ( addr len n -- addr' len' )\n"
"   over min  rot over   +  -rot  -\n"
";\n"
": PLACE   ( addr len to -- , move string )\n"
"   3dup  1+  swap cmove  c! drop\n"
";\n"
"\n"
": PARSE-WORD   ( char -- addr len )\n"
"   >r  source tuck >in @ /string  r@ skip over swap r> scan\n"
"   >r  over -  rot r>  dup 0<> + - >in !\n"
";\n"
": PARSE   ( char -- addr len )\n"
"   >r  source >in @  /string  over swap  r> scan\n"
"   >r  over -  dup r> 0<>  -  >in +!\n"
";\n"
"\n"
": LWORD  ( char -- addr )\n"
"        parse-word here place here \\ 00002 , use PARSE-WORD\n"
";\n"
"\n"
": ASCII ( <char> -- char , state smart )\n"
"        bl parse drop c@\n"
"        state @\n"
"        IF [compile] literal\n"
"        THEN\n"
"; immediate\n"
"\n"
": CHAR ( <char> -- char , interpret mode )\n"
"        bl parse drop c@\n"
";\n"
"\n"
": [CHAR] ( <char> -- char , for compile mode )\n"
"        char [compile] literal\n"
"; immediate\n"
"\n"
": $TYPE  ( $string -- )\n"
"        count type\n"
";\n"
"\n"
": 'word   ( -- addr )   here ;\n"
"\n"
": EVEN    ( addr -- addr' )   dup 1 and +  ;\n"
"\n"
": (C\")   ( -- $addr , some Forths return addr AND count, OBSOLETE?)\n"
"        r> dup count + aligned >r\n"
";\n"
": (S\")   ( -- c-addr cnt )\n"
"        r> count 2dup + aligned >r\n"
";\n"
"\n"
": (.\")  ( -- , type following string )\n"
"        r> count 2dup + aligned >r type\n"
";\n"
"\n"
": \",  ( adr len -- , place string into dictionary )\n"
"         tuck 'word place 1+ allot align\n"
";\n"
": ,\"   ( -- )\n"
"   [char] \" parse \",\n"
";\n"
"\n"
": .(  ( <string> -- , type string delimited by parentheses )\n"
"    [CHAR] ) PARSE TYPE\n"
"; IMMEDIATE\n"
"\n"
": .\"   ( <string> -- , type string )\n"
"        state @\n"
"        IF      compile (.\")  ,\"\n"
"        ELSE [char] \" parse type\n"
"        THEN\n"
"; immediate\n"
"\n"
"\n"
": .'   ( <string> -- , type string delimited by single quote )\n"
"        state @\n"
"        IF    compile (.\")  [char] ' parse \",\n"
"        ELSE [char] ' parse type\n"
"        THEN\n"
"; immediate\n"
"\n"
": C\"    ( <string> -- addr , return string address, ANSI )\n"
"        state @\n"
"        IF compile (c\")   ,\"\n"
"        ELSE [char] \" parse pad place pad\n"
"        THEN\n"
"; immediate\n"
"\n"
": S\"    ( <string> -- , -- addr , return string address, ANSI )\n"
"        state @\n"
"        IF compile (s\")   ,\"\n"
"        ELSE [char] \" parse pad place pad count\n"
"        THEN\n"
"; immediate\n"
"\n"
": \"    ( <string> -- , -- addr , return string address )\n"
"        [compile] C\"\n"
"; immediate\n"
": P\"    ( <string> -- , -- addr , return string address )\n"
"        [compile] C\"\n"
"; immediate\n"
"\n"
": \"\"  ( <string> -- addr )\n"
"        state @\n"
"        IF\n"
"                compile (C\")\n"
"                bl parse-word  \",\n"
"        ELSE\n"
"                bl parse-word pad place pad\n"
"        THEN\n"
"; immediate\n"
"\n"
": SLITERAL ( addr cnt -- , compile string )\n"
"    compile (S\")\n"
"    \",\n"
"; IMMEDIATE\n"
"\n"
": $APPEND ( addr count $1 -- , append text to $1 )\n"
"    over >r\n"
"        dup >r\n"
"    count +  ( -- a2 c2 end1 )\n"
"    swap cmove\n"
"    r> dup c@  ( a1 c1 )\n"
"    r> + ( -- a1 totalcount )\n"
"    swap c!\n"
";\n"
"\n"
"\n"
"\\ ANSI word to replace [COMPILE] and COMPILE ----------------\n"
": POSTPONE  ( <name> -- )\n"
"    bl word find\n"
"    dup 0=\n"
"    IF\n"
"        .\" Postpone could not find \" count type cr abort\n"
"    ELSE\n"
"        0>\n"
"        IF compile,  \\ immediate\n"
"        ELSE (compile)  \\ normal\n"
"        THEN\n"
"    THEN\n"
"; immediate\n"
"\n"
"\\ -----------------------------------------------------------------\n"
"\\ Auto Initialization\n"
": AUTO.INIT  ( -- )\n"
"\\ Kernel finds AUTO.INIT and executes it after loading dictionary.\n"
"\\   .\" Begin AUTO.INIT ------\" cr\n"
";\n"
": AUTO.TERM  ( -- )\n"
"\\ Kernel finds AUTO.TERM and executes it on bye.\n"
"\\   .\" End AUTO.TERM ------\" cr\n"
";\n"
"\n"
"\\ -------------- INCLUDE ------------------------------------------\n"
"variable TRACE-INCLUDE\n"
"\n"
": INCLUDE.MARK.START  ( c-addr u -- , mark start of include for FILE?)\n"
"    dup 5 + allocate throw >r\n"
"    \" ::::\" r@ $move\n"
"    r@ $append\n"
"    r@ ['] noop (:)\n"
"    r> free throw\n"
";\n"
"\n"
": INCLUDE.MARK.END  ( -- , mark end of include )\n"
"    \" ;;;;\" ['] noop (:)\n"
";\n"
"\n"
": INCLUDED ( c-addr u -- )\n"
"\t\\ Print messages.\n"
"        trace-include @\n"
"        IF\n"
"                >newline .\" Include \" 2dup type cr\n"
"        THEN\n"
"        here >r\n"
"        2dup r/o open-file\n"
"        IF  ( -- c-addr u bad-fid )\n"
"                drop .\" Could not find file \" type cr abort\n"
"        ELSE ( -- c-addr u good-fid )\n"
"\t\t-rot include.mark.start\n"
"                depth >r\n"
"                include-file    \\ will also close the file\n"
"                depth 1+ r> -\n"
"                IF\n"
"                        .\" Warning: stack depth changed during include!\" cr\n"
"                        .s cr\n"
"                        0sp\n"
"                THEN\n"
"                include.mark.end\n"
"        THEN\n"
"        trace-include @\n"
"        IF\n"
"                .\"     include added \" here r@ - . .\" bytes,\"\n"
"                codelimit here - . .\" left.\" cr\n"
"        THEN\n"
"        rdrop\n"
";\n"
"\n"
": $INCLUDE ( $filename -- ) count included ;\n"
"\n"
"create INCLUDE-SAVE-NAME 128 allot\n"
": INCLUDE ( <fname> -- )\n"
"        BL lword\n"
"        dup include-save-name $move  \\ save for RI\n"
"        $include\n"
";\n"
"\n"
": RI ( -- , ReInclude previous file as a convenience )\n"
"        include-save-name $include\n"
";\n"
"\n"
": INCLUDE? ( <word> <file> -- , load file if word not defined )\n"
"        bl word find\n"
"        IF drop bl word drop  ( eat word from source )\n"
"        ELSE drop include\n"
"        THEN\n"
";\n"
"\n"
"\\ desired sizes for dictionary loaded after SAVE-FORTH\n"
"variable HEADERS-SIZE\n"
"variable CODE-SIZE\n"
"\n"
": AUTO.INIT\n"
"    auto.init\n"
"    codelimit codebase - code-size !\n"
"    namelimit namebase - headers-size !\n"
";\n"
"auto.init\n"
"\n"
": SAVE-FORTH ( $name -- )\n"
"    0                                    \\ Entry point\n"
"    headers-ptr @ namebase - 65536 +     \\ NameSize\n"
"    headers-size @ MAX\n"
"    here codebase - 131072 +              \\ CodeSize\n"
"    code-size @ MAX\n"
"    (save-forth)\n"
"    IF\n"
"        .\" SAVE-FORTH failed!\" cr abort\n"
"    THEN\n"
";\n"
"\n"
": TURNKEY ( $name entry-token-- )\n"
"    0     \\ NameSize = 0, names not saved in turnkey dictionary\n"
"    here codebase - 131072 +             \\ CodeSize, remember that base is HEX\n"
"    (save-forth)\n"
"    IF\n"
"        .\" TURNKEY failed!\" cr abort\n"
"    THEN\n"
";\n"
"\n"
"\\ Now that we can load from files, load remainder of dictionary.\n"
"\n"
"trace-include on\n"
"\\ Turn this OFF if you do not want to see the contents of the stack after each entry.\n"
"trace-stack off\n"
"\n"
"include loadp4th.fth\n"
"\n"
"decimal\n"
"\n"
": ;;;; ;  \\ Mark end of this file so FILE? can find things in here.\n"
"FREEZE    \\ prevent forgetting below this point\n"
"\n"
".( Dictionary compiled, save in \"pforth.dic\".) cr\n"
"\\ 300000 headers-size !\n"
"\\ 700000 code-size !\n"
"c\" pforth.dic\" save-forth\n";

const char* system_fth = (const char*) temp_binary_data_112;

//================== t_alloc.fth ==================
static const unsigned char temp_binary_data_113[] =
"\\ @(#) t_alloc.fth 97/01/28 1.4\n"
"\\ Test PForth ALLOCATE\n"
"\\\n"
"\\ Copyright 1994 3DO, Phil Burk\n"
"\n"
"anew task-t_alloc.fth\n"
"decimal\n"
"\n"
"64 constant NUM_TAF_SLOTS\n"
"\n"
"variable TAF-MAX-ALLOC\n"
"variable TAF-MAX-SLOT\n"
"\n"
"\\ hold addresses and sizes\n"
"NUM_TAF_SLOTS array TAF-ADDRESSES\n"
"NUM_TAF_SLOTS array TAF-SIZES\n"
"\n"
": TAF.MAX.ALLOC? { | numb addr ior maxb -- max }\n"
"        0 -> maxb\n"
"\\ determine maximum amount we can allocate\n"
"        1024 40 * -> numb\n"
"        BEGIN\n"
"                numb 0>\n"
"        WHILE\n"
"                numb allocate -> ior -> addr\n"
"                ior 0=\n"
"                IF  \\ success\n"
"                        addr free abort\" Free failed!\"\n"
"                        numb -> maxb\n"
"                        0 -> numb\n"
"                ELSE\n"
"                        numb 1024 - -> numb\n"
"                THEN\n"
"        REPEAT\n"
"        maxb\n"
";\n"
"\n"
": TAF.INIT  ( -- )\n"
"        NUM_TAF_SLOTS 0\n"
"        DO\n"
"                0 i taf-addresses !\n"
"        LOOP\n"
"\\\n"
"        taf.max.alloc? .\" Total Avail = \" dup . cr\n"
"        dup taf-max-alloc !\n"
"        NUM_TAF_SLOTS / taf-max-slot !\n"
";\n"
"\n"
": TAF.ALLOC.SLOT { slotnum | addr size -- }\n"
"\\ allocate some RAM\n"
"        taf-max-slot @ 8 -\n"
"        choose 8 +\n"
"        dup allocate abort\" Allocation failed!\"\n"
"        -> addr\n"
"        -> size\n"
"        addr slotnum taf-addresses !\n"
"        size slotnum taf-sizes !\n"
"\\\n"
"\\ paint RAM with slot number\n"
"        addr size slotnum fill\n"
";\n"
"\n"
": TAF.FREE.SLOT { slotnum | addr size -- }\n"
"        slotnum taf-addresses @  -> addr\n"
"\\ something allocated so check it and free it.\n"
"        slotnum taf-sizes @  0\n"
"        DO\n"
"                addr i + c@  slotnum -\n"
"                IF\n"
"                        .\" Error at \" addr i + .\n"
"                        .\" , slot# \" slotnum . cr\n"
"                        abort\n"
"                THEN\n"
"        LOOP\n"
"        addr free abort\" Free failed!\"\n"
"        0 slotnum taf-addresses !\n"
";\n"
"\n"
": TAF.DO.SLOT { slotnum  -- }\n"
"        slotnum taf-addresses @ 0=\n"
"        IF\n"
"                slotnum taf.alloc.slot\n"
"        ELSE\n"
"                slotnum taf.free.slot\n"
"        THEN\n"
";\n"
"\n"
": TAF.TERM\n"
"        NUM_TAF_SLOTS 0\n"
"        DO\n"
"                i taf-addresses @\n"
"                IF\n"
"                        i taf.free.slot\n"
"                THEN\n"
"        LOOP\n"
"\\\n"
"        taf.max.alloc? dup .\" Final    MAX = \" . cr\n"
"        .\" Original MAX = \" taf-max-alloc @ dup . cr\n"
"        = IF .\" Test PASSED.\" ELSE .\" Test FAILED!\" THEN cr\n"
"\n"
";\n"
"\n"
": TAF.TEST ( NumTests -- )\n"
"        1 max\n"
"        dup . .\" tests\" cr \\ flushemit\n"
"        taf.init\n"
"        .\" Please wait for test to complete...\" cr\n"
"        0\n"
"        DO  NUM_TAF_SLOTS choose taf.do.slot\n"
"        LOOP\n"
"        taf.term\n"
";\n"
"\n"
".( Testing ALLOCATE and FREE) cr\n"
"10000 taf.test\n"
"\n";

const char* t_alloc_fth = (const char*) temp_binary_data_113;

//================== t_case.fth ==================
static const unsigned char temp_binary_data_114[] =
"\\ test CASE\n"
"anew test-case\n"
": TCASE  ( N -- )\n"
"    CASE\n"
"    0 OF .\" is zero\" ENDOF\n"
"    1 OF\n"
"        2 choose\n"
"        CASE\n"
"        0 OF .\" chose zero\" ENDOF\n"
"        1 OF .\" chose one\" ENDOF\n"
"        [ .s cr .\" of-depth = \" of-depth @ . cr ]\n"
"        ENDCASE\n"
"    ENDOF\n"
"    [ .s cr .\" of-depth = \" of-depth @ . cr ]\n"
"    ENDCASE\n"
";\n";

const char* t_case_fth = (const char*) temp_binary_data_114;

//================== t_corex.fth ==================
static const unsigned char temp_binary_data_115[] =
"\\ @(#) t_corex.fth 98/03/16 1.2\n"
"\\ Test ANS Forth Core Extensions\n"
"\\\n"
"\\ Copyright 1994 3DO, Phil Burk\n"
"\n"
"INCLUDE? }T{  t_tools.fth\n"
"\n"
"ANEW TASK-T_COREX.FTH\n"
"\n"
"DECIMAL\n"
"\n"
"TEST{\n"
"\n"
"\\ ==========================================================\n"
"T{ 1 2 3 }T{ 1 2 3 }T\n"
"\n"
"\\  ----------------------------------------------------- .(\n"
"T{ 27 .( IF YOU SEE THIS THEN .( WORKED!) }T{ 27 }T\n"
"\n"
"CR .(     1234 - SHOULD LINE UP WITH NEXT LINE.) CR 1234 8 .R CR\n"
"\n"
"T{ .( )   987   .( TEST NULL STRING IN .( ) CR }T{ 987 }T\n"
"\n"
"\\  ----------------------------------------------------- 0<>\n"
"T{ 5 0<> }T{ TRUE }T\n"
"T{ 0 0<> }T{ 0 }T\n"
"T{ -1000 0<> }T{ TRUE }T\n"
"\n"
"\\  ----------------------------------------------------- 2>R 2R> 2R@\n"
": T2>R  ( -- .... )\n"
"    17\n"
"    20 5 2>R\n"
"    19\n"
"    2R@\n"
"    37\n"
"    2R>\n"
"\\ 2>R should be the equivalent of SWAP >R >R so this next construct\n"
"\\ should reduce to a SWAP.\n"
"    88 77 2>R R> R>\n"
";\n"
"T{ T2>R }T{ 17 19 20 5 37 20 5 77 88 }T\n"
"\n"
"\\  ----------------------------------------------------- :NONAME\n"
"T{ :NONAME  100 50 + ; EXECUTE }T{ 150 }T\n"
"\n"
"\\  ----------------------------------------------------- <>\n"
"T{ 12345 12305 <> }T{ TRUE }T\n"
"T{ HEX 98765432 98765432 DECIMAL <> }T{ 0 }T\n"
"\n"
"\\  ----------------------------------------------------- ?DO\n"
": T?DO  ( n -- sum_n ) 0 SWAP 1+ 0 ?DO i + LOOP ;\n"
"T{ 0 T?DO }T{ 0 }T\n"
"T{ 4 T?DO }T{ 10 }T\n"
"\n"
"\\  ----------------------------------------------------- AGAIN\n"
": T.AGAIN  ( n --  )\n"
"    BEGIN\n"
"        DUP .\n"
"        DUP 6 < IF EXIT THEN\n"
"        1-\n"
"    AGAIN\n"
";\n"
"T{ 10 T.AGAIN CR }T{ 5 }T\n"
"\n"
"\\  ----------------------------------------------------- C\"\n"
": T.C\"  ( -- $STRING )\n"
"    C\" x5&\"\n"
";\n"
"T{ T.C\"  C@  }T{ 3 }T\n"
"T{ T.C\"  COUNT DROP C@  }T{ CHAR x }T\n"
"T{ T.C\"  COUNT DROP CHAR+ C@ }T{  CHAR 5 }T\n"
"T{ T.C\"  COUNT DROP 2 CHARS + C@  }T{ CHAR & }T\n"
"\n"
"\\  ----------------------------------------------------- CASE\n"
": T.CASE  ( N -- )\n"
"    CASE\n"
"        1 OF 101 ENDOF\n"
"        27 OF 892 ENDOF\n"
"        941 SWAP \\ default\n"
"    ENDCASE\n"
";\n"
"T{ 1 T.CASE }T{ 101 }T\n"
"T{ 27 T.CASE }T{ 892 }T\n"
"T{ 49 T.CASE }T{ 941 }T\n"
"\n"
"\\  ----------------------------------------------------- COMPILE,\n"
": COMPILE.SWAP    ['] SWAP COMPILE, ; IMMEDIATE\n"
": T.COMPILE,\n"
"    19 20 27 COMPILE.SWAP 39\n"
";\n"
"T{ T.COMPILE, }T{ 19 27 20 39 }T\n"
"\n"
"\\  ----------------------------------------------------- CONVERT\n"
": T.CONVERT\n"
"    0 S>D  S\" 1234xyz\" DROP CONVERT\n"
"    >R\n"
"    D>S\n"
"    R> C@\n"
";\n"
"T{ T.CONVERT }T{ 1234 CHAR x }T\n"
"\n"
"\\  ----------------------------------------------------- ERASE\n"
": T.COMMA.SEQ  ( n -- , lay down N sequential bytes )\n"
"    0 ?DO I C, LOOP\n"
";\n"
"CREATE T-ERASE-DATA   64 T.COMMA.SEQ\n"
"T{ T-ERASE-DATA 8 + C@ }T{ 8 }T\n"
"T{ T-ERASE-DATA 7 + 3 ERASE\n"
"T{ T-ERASE-DATA 6 + C@ }T{ 6 }T\n"
"T{ T-ERASE-DATA 7 + C@ }T{ 0 }T\n"
"T{ T-ERASE-DATA 8 + C@ }T{ 0 }T\n"
"T{ T-ERASE-DATA 9 + C@ }T{ 0 }T\n"
"T{ T-ERASE-DATA 10 + C@ }T{ 10 }T\n"
"\n"
"\\  ----------------------------------------------------- FALSE\n"
"T{ FALSE }T{ 0 }T\n"
"\n"
"\\  ----------------------------------------------------- HEX\n"
"T{ HEX 10 DECIMAL }T{ 16 }T\n"
"\n"
"\\  ----------------------------------------------------- MARKER\n"
": INDIC?  ( <name> -- ifInDic , is the following word defined? )\n"
"    bl word find\n"
"    swap drop 0= 0=\n"
";\n"
"create FOOBAR\n"
"MARKER MYMARK  \\ create word that forgets itself\n"
"create GOOFBALL\n"
"MYMARK\n"
"T{ indic? foobar  indic? mymark indic? goofball }T{ true false false }T\n"
"\n"
"\\  ----------------------------------------------------- NIP\n"
"T{ 33 44 55 NIP  }T{ 33 55 }T\n"
"\n"
"\\  ----------------------------------------------------- PARSE\n"
": T.PARSE  ( char <string>char -- addr num )\n"
"    PARSE\n"
"    >R  \\ save length\n"
"    PAD R@ CMOVE  \\ move string to pad\n"
"    PAD R>\n"
";\n"
"T{ CHAR % T.PARSE wxyz% SWAP C@ }T{  4  CHAR w }T\n"
"\n"
"\\  ----------------------------------------------------- PICK\n"
"T{ 13 12 11 10 2 PICK  }T{ 13 12 11 10 12 }T\n"
"\n"
"\\  ----------------------------------------------------- QUERY\n"
"T{ ' QUERY 0<> }T{ TRUE }T\n"
"\n"
"\\  ----------------------------------------------------- REFILL\n"
"T{ ' REFILL 0<> }T{ TRUE }T\n"
"\n"
"\\  ----------------------------------------------------- RESTORE-INPUT\n"
"T{ : T.SAVE-INPUT SAVE-INPUT RESTORE-INPUT ; T.SAVE-INPUT }T{ 0 }T\n"
"\n"
"\\ TESTING SAVE-INPUT and RESTORE-INPUT with a string source\n"
"\n"
"VARIABLE SI_INC 0 SI_INC !\n"
"\n"
": SI1\n"
"   SI_INC @ >IN +!\n"
"   15 SI_INC !\n"
";\n"
"\n"
": S$ S\" SAVE-INPUT SI1 RESTORE-INPUT 12345\" ;\n"
"\n"
"T{ S$ EVALUATE SI_INC @ }T{ 0 2345 15 }T\n"
"\n"
"\\  ----------------------------------------------------- ROLL\n"
"T{ 15 14 13 12 11 10 0 ROLL  }T{  15 14 13 12 11 10 }T\n"
"T{ 15 14 13 12 11 10 1 ROLL  }T{  15 14 13 12 10 11 }T\n"
"T{ 15 14 13 12 11 10 2 ROLL  }T{  15 14 13 11 10 12 }T\n"
"T{ 15 14 13 12 11 10 3 ROLL  }T{  15 14 12 11 10 13 }T\n"
"T{ 15 14 13 12 11 10 4 ROLL  }T{  15 13 12 11 10 14 }T\n"
"\n"
"\\  ----------------------------------------------------- SOURCE-ID\n"
"T{ SOURCE-ID 0<> }T{ TRUE }T\n"
"T{ : T.SOURCE-ID  S\" SOURCE-ID\" EVALUATE  ;   T.SOURCE-ID }T{ -1 }T\n"
"\n"
"\\  ----------------------------------------------------- SPAN\n"
"T{ ' SPAN 0<>  }T{ TRUE }T\n"
"\n"
"\\  ----------------------------------------------------- TO VALUE\n"
"333 VALUE  MY-VALUE\n"
"T{ MY-VALUE }T{ 333 }T\n"
"T{ 1000 TO MY-VALUE   MY-VALUE }T{ 1000 }T\n"
": TEST.VALUE  ( -- 19 100 )\n"
"    100 TO MY-VALUE\n"
"    19\n"
"    MY-VALUE\n"
";\n"
"T{ TEST.VALUE }T{ 19 100 }T\n"
"\n"
"\\  ----------------------------------------------------- TRUE\n"
"T{ TRUE }T{ 0 0= }T\n"
"\n"
"\\  ----------------------------------------------------- TUCK\n"
"T{ 44 55 66 TUCK }T{ 44 66 55 66 }T\n"
"\n"
"\\  ----------------------------------------------------- U.R\n"
"HEX CR .(     ABCD4321 - SHOULD LINE UP WITH NEXT LINE.) CR\n"
"ABCD4321 C U.R CR DECIMAL\n"
"\n"
"\\  ----------------------------------------------------- U>\n"
"T{ -5 3 U> }T{ TRUE }T\n"
"T{ 10 8 U> }T{ TRUE }T\n"
"\n"
"\\  ----------------------------------------------------- UNUSED\n"
"T{ UNUSED 0> }T{ TRUE }T\n"
"\n"
"\\  ----------------------------------------------------- WITHIN\n"
"T{  4  5 10 WITHIN }T{ 0 }T\n"
"T{  5  5 10 WITHIN }T{ TRUE }T\n"
"T{  9  5 10 WITHIN }T{ TRUE }T\n"
"T{ 10  5 10 WITHIN }T{ 0 }T\n"
"\n"
"T{  4  10 5 WITHIN }T{ TRUE }T\n"
"T{  5  10 5 WITHIN }T{ 0 }T\n"
"T{  9  10 5 WITHIN }T{ 0 }T\n"
"T{ 10  10 5 WITHIN }T{ TRUE }T\n"
"\n"
"T{  -6  -5 10 WITHIN }T{ 0 }T\n"
"T{  -5  -5 10 WITHIN    }T{ TRUE }T\n"
"T{  9  -5 10 WITHIN    }T{ TRUE }T\n"
"T{ 10  -5 10 WITHIN }T{ 0 }T\n"
"\n"
"\n"
"\\  ----------------------------------------------------- [COMPILE]\n"
": T.[COMPILE].IF  [COMPILE] IF ; IMMEDIATE\n"
": T.[COMPILE]  40 0> T.[COMPILE].IF 97 ELSE 53 THEN 97 = ;\n"
"T{ T.[COMPILE] }T{ TRUE }T\n"
"\n"
"\\  ----------------------------------------------------- \\\n"
"\n"
"\\ .( TESTING DO +LOOP with large and small increments )\n"
"\n"
"\\ Contributed by Andrew Haley\n"
"0 invert CONSTANT MAX-UINT\n"
"0 INVERT 1 RSHIFT CONSTANT MAX-INT\n"
"0 INVERT 1 RSHIFT INVERT    CONSTANT MIN-INT\n"
"MAX-UINT 8 RSHIFT 1+ CONSTANT USTEP\n"
"USTEP NEGATE CONSTANT -USTEP\n"
"MAX-INT 7 RSHIFT 1+ CONSTANT STEP\n"
"STEP NEGATE CONSTANT -STEP\n"
"\n"
"VARIABLE BUMP\n"
"\n"
"T{ : GD8 BUMP ! DO 1+ BUMP @ +LOOP ; }T{ }T\n"
"\n"
"T{ 0 MAX-UINT 0 USTEP GD8 }T{ 256 }T\n"
"T{ 0 0 MAX-UINT -USTEP GD8 }T{ 256 }T\n"
"\n"
"T{ 0 MAX-INT MIN-INT STEP GD8 }T{ 256 }T\n"
"T{ 0 MIN-INT MAX-INT -STEP GD8 }T{ 256 }T\n"
"\n"
"\\ Two's complement arithmetic, wraps around modulo wordsize\n"
"\\ Only tested if the Forth system does wrap around, use of conditional\n"
"\\ compilation deliberately avoided\n"
"\n"
"MAX-INT 1+ MIN-INT = CONSTANT +WRAP?\n"
"MIN-INT 1- MAX-INT = CONSTANT -WRAP?\n"
"MAX-UINT 1+ 0=       CONSTANT +UWRAP?\n"
"0 1- MAX-UINT =      CONSTANT -UWRAP?\n"
"\n"
": GD9  ( n limit start step f result -- )\n"
"   >R IF GD8 ELSE 2DROP 2DROP R@ THEN }T{ R> }T\n"
";\n"
"\n"
"T{ 0 0 0  USTEP +UWRAP? 256 GD9\n"
"T{ 0 0 0 -USTEP -UWRAP?   1 GD9\n"
"T{ 0 MIN-INT MAX-INT  STEP +WRAP? 1 GD9\n"
"T{ 0 MAX-INT MIN-INT -STEP -WRAP? 1 GD9\n"
"\n"
"\\ --------------------------------------------------------------------------\n"
"\\ .( TESTING DO +LOOP with maximum and minimum increments )\n"
"\n"
": (-MI) MAX-INT DUP NEGATE + 0= IF MAX-INT NEGATE ELSE -32767 THEN ;\n"
"(-MI) CONSTANT -MAX-INT\n"
"\n"
"T{ 0 1 0 MAX-INT GD8  }T{ 1 }T\n"
"T{ 0 -MAX-INT NEGATE -MAX-INT OVER GD8  }T{ 2 }T\n"
"\n"
"T{ 0 MAX-INT  0 MAX-INT GD8  }T{ 1 }T\n"
"T{ 0 MAX-INT  1 MAX-INT GD8  }T{ 1 }T\n"
"T{ 0 MAX-INT -1 MAX-INT GD8  }T{ 2 }T\n"
"T{ 0 MAX-INT DUP 1- MAX-INT GD8  }T{ 1 }T\n"
"\n"
"T{ 0 MIN-INT 1+   0 MIN-INT GD8  }T{ 1 }T\n"
"T{ 0 MIN-INT 1+  -1 MIN-INT GD8  }T{ 1 }T\n"
"T{ 0 MIN-INT 1+   1 MIN-INT GD8  }T{ 2 }T\n"
"T{ 0 MIN-INT 1+ DUP MIN-INT GD8  }T{ 1 }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"\\ .( TESTING number prefixes # $ % and 'c' character input )\n"
"\\ Adapted from the Forth 200X Draft 14.5 document\n"
"\n"
"VARIABLE OLD-BASE\n"
"DECIMAL BASE @ OLD-BASE !\n"
"T{ #1289 }T{ 1289 }T\n"
"T{ #-1289 }T{ -1289 }T\n"
"T{ $12eF }T{ 4847 }T\n"
"T{ $-12eF }T{ -4847 }T\n"
"T{ %10010110 }T{ 150 }T\n"
"T{ %-10010110 }T{ -150 }T\n"
"T{ 'z' }T{ 122 }T\n"
"T{ 'Z' }T{ 90 }T\n"
"\\ Check BASE is unchanged\n"
"T{ BASE @ OLD-BASE @ = }T{ TRUE }T\n"
"\n"
"\\ Repeat in Hex mode\n"
"16 OLD-BASE ! 16 BASE !\n"
"T{ #1289 }T{ 509 }T\n"
"T{ #-1289 }T{ -509 }T\n"
"T{ $12eF }T{ 12EF }T\n"
"T{ $-12eF }T{ -12EF }T\n"
"T{ %10010110 }T{ 96 }T\n"
"T{ %-10010110 }T{ -96 }T\n"
"T{ 'z' }T{ 7a }T\n"
"T{ 'Z' }T{ 5a }T\n"
"\\ Check BASE is unchanged\n"
"T{ BASE @ OLD-BASE @ = }T{ TRUE }T   \\ 2\n"
"\n"
"DECIMAL\n"
"\\ Check number prefixes in compile mode\n"
"T{ : nmp  #8327 $-2cbe %011010111 ''' ; nmp }T{ 8327 -11454 215 39 }T\n"
"\n"
"\\  ----------------------------------------------------- ENVIRONMENT?\n"
"\n"
"T{ s\" unknown-query-string\" ENVIRONMENT? }T{ FALSE }T\n"
"T{ s\" MAX-CHAR\" ENVIRONMENT? }T{ 255 TRUE }T\n"
"T{ s\" ADDRESS-UNITS-BITS\" ENVIRONMENT? }T{ 8 TRUE }T\n"
"\n"
"}TEST\n"
"\n";

const char* t_corex_fth = (const char*) temp_binary_data_115;

//================== t_file.fth ==================
static const unsigned char temp_binary_data_116[] =
"\\ Test PForth FILE wordset\n"
"\n"
"\\ To test the ANS File Access word set and extension words\n"
"\n"
"\\ This program was written by Gerry Jackson in 2006, with contributions from\n"
"\\ others where indicated, and is in the public domain - it can be distributed\n"
"\\ and/or modified in any way but please retain this notice.\n"
"\n"
"\\ This program is distributed in the hope that it will be useful,\n"
"\\ but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"\\ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
"\n"
"\\ The tests are not claimed to be comprehensive or correct\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"\\ Version 0.13 S\" in interpretation mode tested.\n"
"\\              Added SAVE-INPUT RESTORE-INPUT REFILL in a file, (moved from\n"
"\\              coreexttest.fth).\n"
"\\              Calls to COMPARE replaced with S= (in utilities.fth)\n"
"\\         0.11 25 April 2015 S\\\" in interpretation mode test added\n"
"\\              REQUIRED REQUIRE INCLUDE tests added\n"
"\\              Two S\" and/or S\\\" buffers availability tested\n"
"\\         0.5  1 April 2012  Tests placed in the public domain.\n"
"\\         0.4  22 March 2009 { and } replaced with T{ and }T\n"
"\\         0.3  20 April 2007  ANS Forth words changed to upper case.\n"
"\\              Removed directory test from the filenames.\n"
"\\         0.2  30 Oct 2006 updated following GForth tests to remove\n"
"\\              system dependency on file size, to allow for file\n"
"\\              buffering and to allow for PAD moving around.\n"
"\\         0.1  Oct 2006 First version released.\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"\\ The tests are based on John Hayes test program for the core word set\n"
"\\ and requires those files to have been loaded\n"
"\n"
"\\ Words tested in this file are:\n"
"\\     ( BIN CLOSE-FILE CREATE-FILE DELETE-FILE FILE-POSITION FILE-SIZE\n"
"\\     OPEN-FILE R/O R/W READ-FILE READ-LINE REPOSITION-FILE RESIZE-FILE\n"
"\\     S\" S\\\" SOURCE-ID W/O WRITE-FILE WRITE-LINE\n"
"\\     FILE-STATUS FLUSH-FILE RENAME-FILE SAVE-INPUT RESTORE-INPUT\n"
"\\     REFILL\n"
"\n"
"\\ Words not tested:\n"
"\\     INCLUDED INCLUDE-FILE (as these will likely have been\n"
"\\     tested in the execution of the test files)\n"
"\\ ----------------------------------------------------------------------------\n"
"\\ Assumptions, dependencies and notes:\n"
"\\     - tester.fr (or ttester.fs), errorreport.fth and utilities.fth have been\n"
"\\       included prior to this file\n"
"\\     - the Core word set is available and tested\n"
"\\     - These tests create files in the current directory, if all goes\n"
"\\       well these will be deleted. If something fails they may not be\n"
"\\       deleted. If this is a problem ensure you set a suitable\n"
"\\       directory before running this test. There is no ANS standard\n"
"\\       way of doing this. Also be aware of the file names used below\n"
"\\       which are:  fatest1.txt, fatest2.txt and fatest3.txt\n"
"\\ ----------------------------------------------------------------------------\n"
"\n"
"include? }T{  t_tools.fth\n"
"\n"
"true fp-require-e !\n"
"\n"
"false value verbose\n"
"\n"
": testing\n"
"    verbose IF\n"
"\tsource >in @ /string .\" TESTING: \" type cr\n"
"    THEN\n"
"    source nip >in !\n"
"; immediate\n"
"\n"
": -> }T{ ;\n"
": s= compare 0= ;\n"
": $\" state IF postpone s\" else ['] s\" execute THEN ; immediate\n"
"\n"
"TESTING File Access word set\n"
"\n"
"DECIMAL\n"
"\n"
"TEST{\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING CREATE-FILE CLOSE-FILE\n"
"\n"
": FN1 S\" fatest1.txt\" ;\n"
"VARIABLE FID1\n"
"\n"
"T{ FN1 R/W CREATE-FILE SWAP FID1 ! -> 0 }T\n"
"T{ FID1 @ CLOSE-FILE -> 0 }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING OPEN-FILE W/O WRITE-LINE\n"
"\n"
": LINE1 S\" Line 1\" ;\n"
"\n"
"T{ FN1 W/O OPEN-FILE SWAP FID1 ! -> 0 }T\n"
"T{ LINE1 FID1 @ WRITE-LINE -> 0 }T\n"
"T{ FID1 @ CLOSE-FILE -> 0 }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING R/O FILE-POSITION (simple)  READ-LINE \n"
"\n"
"200 CONSTANT BSIZE\n"
"CREATE BUF BSIZE ALLOT\n"
"VARIABLE #CHARS\n"
"\n"
"T{ FN1 R/O OPEN-FILE SWAP FID1 ! -> 0 }T\n"
"T{ FID1 @ FILE-POSITION -> 0. 0 }T\n"
"T{ BUF 100 FID1 @ READ-LINE ROT DUP #CHARS ! -> TRUE 0 LINE1 SWAP DROP }T\n"
"T{ BUF #CHARS @ LINE1 S= -> TRUE }T\n"
"T{ FID1 @ CLOSE-FILE -> 0 }T\n"
"\n"
"\\ Test with buffer shorter than line.\n"
"T{ FN1 R/O OPEN-FILE SWAP FID1 ! -> 0 }T\n"
"T{ FID1 @ FILE-POSITION -> 0. 0 }T\n"
"T{ BUF 0 FID1 @ READ-LINE ROT DUP #CHARS ! -> TRUE 0 0 }T\n"
"T{ BUF 3 FID1 @ READ-LINE ROT DUP #CHARS ! -> TRUE 0 3 }T\n"
"T{ BUF #CHARS @ LINE1 DROP 3 S= -> TRUE }T\n"
"T{ BUF 100 FID1 @ READ-LINE ROT DUP #CHARS ! -> TRUE 0 LINE1 NIP 3 - }T\n"
"T{ BUF #CHARS @ LINE1 3 /STRING S= -> TRUE }T\n"
"T{ FID1 @ CLOSE-FILE -> 0 }T\n"
"\n"
"\\ Test with buffer exactly as long as the line.\n"
"T{ FN1 R/O OPEN-FILE SWAP FID1 ! -> 0 }T\n"
"T{ FID1 @ FILE-POSITION -> 0. 0 }T\n"
"T{ BUF LINE1 NIP FID1 @ READ-LINE ROT DUP #CHARS ! -> TRUE 0 LINE1 NIP }T\n"
"T{ BUF #CHARS @ LINE1 S= -> TRUE }T\n"
"T{ FID1 @ CLOSE-FILE -> 0 }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING S\" in interpretation mode (compile mode tested in Core tests)\n"
"\n"
"T{ S\" abcdef\" $\" abcdef\" S= -> TRUE }T\n"
"T{ S\" \" $\" \" S= -> TRUE }T\n"
"T{ S\" ghi\"$\" ghi\" S= -> TRUE }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING R/W WRITE-FILE REPOSITION-FILE READ-FILE FILE-POSITION S\"\n"
"\n"
": LINE2 S\" Line 2 blah blah blah\" ;\n"
": RL1 BUF 100 FID1 @ READ-LINE ;\n"
"2VARIABLE FP\n"
"\n"
"T{ FN1 R/W OPEN-FILE SWAP FID1 ! -> 0 }T\n"
"T{ FID1 @ FILE-SIZE DROP FID1 @ REPOSITION-FILE -> 0 }T\n"
"T{ FID1 @ FILE-SIZE -> FID1 @ FILE-POSITION }T\n"
"T{ LINE2 FID1 @ WRITE-FILE -> 0 }T\n"
"T{ 10. FID1 @ REPOSITION-FILE -> 0 }T\n"
"T{ FID1 @ FILE-POSITION -> 10. 0 }T\n"
"T{ 0. FID1 @ REPOSITION-FILE -> 0 }T\n"
"T{ RL1 -> LINE1 SWAP DROP TRUE 0 }T\n"
"T{ RL1 ROT DUP #CHARS ! -> TRUE 0 LINE2 SWAP DROP }T\n"
"T{ BUF #CHARS @ LINE2 S= -> TRUE }T\n"
"T{ RL1 -> 0 FALSE 0 }T\n"
"T{ FID1 @ FILE-POSITION ROT ROT FP 2! -> 0 }T\n"
"T{ FP 2@ FID1 @ FILE-SIZE DROP D= -> TRUE }T\n"
"T{ S\" \" FID1 @ WRITE-LINE -> 0 }T\n"
"T{ S\" \" FID1 @ WRITE-LINE -> 0 }T\n"
"T{ FP 2@ FID1 @ REPOSITION-FILE -> 0 }T\n"
"T{ RL1 -> 0 TRUE 0 }T\n"
"T{ RL1 -> 0 TRUE 0 }T\n"
"T{ RL1 -> 0 FALSE 0 }T\n"
"T{ FID1 @ CLOSE-FILE -> 0 }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING BIN READ-FILE FILE-SIZE\n"
"\n"
": CBUF BUF BSIZE 0 FILL ;\n"
": FN2 S\" FATEST2.TXT\" ;\n"
"VARIABLE FID2\n"
": SETPAD PAD 50 0 DO I OVER C! CHAR+ LOOP DROP ;\n"
"\n"
"SETPAD   \\ If anything else is defined setpad must be called again\n"
"         \\ as pad may move\n"
"\n"
"T{ FN2 R/W BIN CREATE-FILE SWAP FID2 ! -> 0 }T\n"
"T{ PAD 50 FID2 @ WRITE-FILE FID2 @ FLUSH-FILE -> 0 0 }T\n"
"T{ FID2 @ FILE-SIZE -> 50. 0 }T\n"
"T{ 0. FID2 @ REPOSITION-FILE -> 0 }T\n"
"T{ CBUF BUF 29 FID2 @ READ-FILE -> 29 0 }T\n"
"T{ PAD 29 BUF 29 S= -> TRUE }T\n"
"T{ PAD 30 BUF 30 S= -> FALSE }T\n"
"T{ CBUF BUF 29 FID2 @ READ-FILE -> 21 0 }T\n"
"T{ PAD 29 + 21 BUF 21 S= -> TRUE }T\n"
"T{ FID2 @ FILE-SIZE DROP FID2 @ FILE-POSITION DROP D= -> TRUE }T\n"
"T{ BUF 10 FID2 @ READ-FILE -> 0 0 }T\n"
"T{ FID2 @ CLOSE-FILE -> 0 }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING RESIZE-FILE\n"
"\n"
"T{ FN2 R/W BIN OPEN-FILE SWAP FID2 ! -> 0 }T\n"
"T{ 37. FID2 @ RESIZE-FILE -> 0 }T\n"
"T{ FID2 @ FILE-SIZE -> 37. 0 }T\n"
"T{ 0. FID2 @ REPOSITION-FILE -> 0 }T\n"
"T{ CBUF BUF 100 FID2 @ READ-FILE -> 37 0 }T\n"
"T{ PAD 37 BUF 37 S= -> TRUE }T\n"
"T{ PAD 38 BUF 38 S= -> FALSE }T\n"
"T{ 500. FID2 @ RESIZE-FILE -> 0 }T\n"
"T{ FID2 @ FILE-SIZE -> 500. 0 }T\n"
"T{ 0. FID2 @ REPOSITION-FILE -> 0 }T\n"
"T{ CBUF BUF 100 FID2 @ READ-FILE -> 100 0 }T\n"
"T{ PAD 37 BUF 37 S= -> TRUE }T\n"
"T{ FID2 @ CLOSE-FILE -> 0 }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING DELETE-FILE\n"
"\n"
"T{ FN2 DELETE-FILE -> 0 }T\n"
"T{ FN2 R/W BIN OPEN-FILE SWAP DROP 0= -> FALSE }T\n"
"T{ FN2 DELETE-FILE 0= -> FALSE }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING multi-line ( comments\n"
"\n"
"T{ ( 1 2 3\n"
"4 5 6\n"
"7 8 9 ) 11 22 33 -> 11 22 33 }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING SOURCE-ID (can only test it does not return 0 or -1)\n"
"\n"
"T{ SOURCE-ID DUP -1 = SWAP 0= OR -> FALSE }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING RENAME-FILE FILE-STATUS FLUSH-FILE\n"
"\n"
": FN3 S\" fatest3.txt\" ;\n"
": >END FID1 @ FILE-SIZE DROP FID1 @ REPOSITION-FILE ;\n"
"\n"
"\n"
"T{ FN3 DELETE-FILE DROP -> }T\n"
"T{ FN1 FN3 RENAME-FILE 0= -> TRUE }T\n"
"T{ FN1 FILE-STATUS SWAP DROP 0= -> FALSE }T\n"
"T{ FN3 FILE-STATUS SWAP DROP 0= -> TRUE }T  \\ Return value is undefined\n"
"T{ FN3 R/W OPEN-FILE SWAP FID1 ! -> 0 }T\n"
"T{ >END -> 0 }T\n"
"T{ S\" Final line\" fid1 @ WRITE-LINE -> 0 }T\n"
"\n"
"T{ FID1 @ FLUSH-FILE -> 0 }T      \\ Can only test FLUSH-FILE doesn't fail\n"
"T{ FID1 @ CLOSE-FILE -> 0 }T\n"
"\n"
"\\ Tidy the test folder\n"
"T{ fn3 DELETE-FILE DROP -> }T\n"
"\n"
"\\ ------------------------------------------------------------------------------\n"
"TESTING REQUIRED REQUIRE INCLUDED\n"
"\\ Tests taken from Forth 2012 RfD\n"
"\n"
"T{ 0 S\" t_required_helper1.fth\" REQUIRED\n"
"     REQUIRE t_required_helper1.fth\n"
"     INCLUDE t_required_helper1.fth\n"
"     -> 2 }T\n"
"\n"
"T{ 0 INCLUDE t_required_helper2.fth\n"
"     S\" t_required_helper2.fth\" REQUIRED\n"
"     REQUIRE t_required_helper2.fth\n"
"     S\" t_required_helper2.fth\" INCLUDED\n"
"     -> 2 }T\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"TESTING two buffers available for S\" and/or S\\\" (Forth 2012)\n"
"\n"
": SSQ12 S\" abcd\" ;   : SSQ13 S\" 1234\" ;\n"
"T{ S\" abcd\"  S\" 1234\" SSQ13  S= ROT ROT SSQ12 S= -> TRUE TRUE }T\n"
"\\ nyi T{ S\\\" abcd\" S\\\" 1234\" SSQ13 S= ROT ROT SSQ12 S= -> TRUE TRUE }T\n"
"\\ nyi T{ S\" abcd\"  S\\\" 1234\" SSQ13 S= ROT ROT SSQ12 S= -> TRUE TRUE }T\n"
"\\ nyi T{ S\\\" abcd\" S\" 1234\" SSQ13  S= ROT ROT SSQ12 S= -> TRUE TRUE }T\n"
"\n"
"\n"
"\\ -----------------------------------------------------------------------------\n"
"TESTING SAVE-INPUT and RESTORE-INPUT with a file source\n"
"\n"
"VARIABLE SIV -1 SIV !\n"
"\n"
": NEVEREXECUTED\n"
"   CR .\" This should never be executed\" CR\n"
";\n"
"\n"
"T{ 11111 SAVE-INPUT\n"
"\n"
"SIV @\n"
"\n"
"[IF]\n"
"   TESTING the -[IF]- part is executed\n"
"   0 SIV !\n"
"   RESTORE-INPUT\n"
"   NEVEREXECUTED\n"
"   33333\n"
"[ELSE]\n"
"\n"
"  TESTING the -[ELSE]- part is executed\n"
"  22222\n"
"\n"
"[THEN]\n"
"\n"
"   -> 11111 0 22222 }T   \\ 0 comes from RESTORE-INPUT\n"
"\n"
"TESTING nested SAVE-INPUT, RESTORE-INPUT and REFILL from a file\n"
"\n"
": READ_A_LINE\n"
"   REFILL 0=\n"
"   ABORT\" REFILL FAILED\"\n"
";\n"
"\n"
"VARIABLE SI_INC 0 SI_INC !\n"
"\n"
": SI1\n"
"   SI_INC @ >IN +!\n"
"   15 SI_INC !\n"
";\n"
"\n"
": S$ S\" SAVE-INPUT SI1 RESTORE-INPUT 12345\" ;\n"
"\n"
"CREATE 2RES -1 , -1 ,   \\ Don't use 2VARIABLE from Double number word set \n"
"\n"
": SI2\n"
"   READ_A_LINE\n"
"   READ_A_LINE\n"
"   SAVE-INPUT\n"
"   READ_A_LINE\n"
"   READ_A_LINE\n"
"   S$ EVALUATE 2RES 2!\n"
"   RESTORE-INPUT\n"
";\n"
"\n"
"\\ WARNING: do not delete or insert lines of text after si2 is called\n"
"\\ otherwise the next test will fail\n"
"\n"
"T{ SI2\n"
"33333               \\ This line should be ignored\n"
"2RES 2@ 44444      \\ RESTORE-INPUT should return to this line\n"
"\n"
"55555\n"
"TESTING the nested results\n"
" -> 0 0 2345 44444 55555 }T\n"
"\n"
"\\ End of warning\n"
"\n"
"\\ ----------------------------------------------------------------------------\n"
"\n"
"\\ CR .( End of File-Access word set tests) CR\n"
"\n"
"}TEST\n";

const char* t_file_fth = (const char*) temp_binary_data_116;

//================== t_floats.fth ==================
static const unsigned char temp_binary_data_117[] =
"\\ @(#) t_floats.fth 98/02/26 1.1 17:46:04\n"
"\\ Test ANS Forth FLOAT words.\n"
"\\\n"
"\\ Copyright 1994 3DO, Phil Burk\n"
"\n"
"INCLUDE? }T{  t_tools.fth\n"
"\n"
"ANEW TASK-T_FLOATS.FTH\n"
"\n"
"DECIMAL\n"
"3.14159265 fconstant PI\n"
"\n"
"TEST{\n"
"\\ ==========================================================\n"
"T{ 1 2 3 }T{ 1 2 3 }T\n"
"\\  ----------------------------------------------------- D>F F>D\n"
"\\ test some basic floating point <> integer conversion\n"
"T{   4  0 D>F F>D  }T{   4  0 }T\n"
"T{ 835  0 D>F F>D  }T{ 835  0 }T\n"
"T{ -57 -1 D>F F>D  }T{ -57 -1 }T\n"
"T{ 15 S>F 2 S>F F/ F>S }T{ 7 }T  \\ 15.0/2.0 -> 7.5\n"
"\n"
"\\  ----------------------------------------------------- input\n"
"T{ 79.2 F>S }T{ 79 }T\n"
"T{ 0.003 F>S }T{ 0 }T\n"
"\n"
"\\ ------------------------------------------------------ F~\n"
"T{  23.4  23.5  0.2   f~ }T{  true  }T\n"
"T{  23.4  23.7  0.2   f~ }T{  false }T\n"
"T{ 922.3 922.3  0.0   f~ }T{  true  }T\n"
"T{ 922.3 922.31 0.0   f~ }T{  false }T\n"
"T{   0.0   0.0  0.0   f~ }T{  true  }T\n"
"T{   0.0  -0.0  0.0   f~ }T{  false }T\n"
"T{  50.0  51.0 -0.02  f~ }T{  true  }T\n"
"T{  50.0  51.0 -0.002 f~ }T{  false }T\n"
"T{ 500.0 510.0 -0.02  f~ }T{  true  }T\n"
"T{ 500.0 510.0 -0.002 f~ }T{  false }T\n"
"\n"
"\\ convert number to text representation and then back to float\n"
": T_F. ( -- ok? ) ( r ftol -f- )\n"
"    fover (f.) >float fswap f~\n"
"    AND\n"
";\n"
": T_FS. ( -- ok? ) ( r ftol -f- )\n"
"    fover (fs.) >float fswap f~\n"
"    AND\n"
";\n"
": T_FE. ( -- ok? ) ( r ftol -f- )\n"
"    fover (fe.) >float fswap f~\n"
"    AND\n"
";\n"
"\n"
": T_FG. ( -- ok? ) ( r ftol -f- )\n"
"    fover (f.) >float fswap f~\n"
"    AND\n"
";\n"
"\n"
": T_F>D ( -- ok? ) ( r ftol -f- )\n"
"    fover f>d d>f fswap f~\n"
";\n"
"\n"
"T{ 0.0  0.00001 T_F.  }T{  true  }T\n"
"T{ 0.0  0.00001 T_FS.  }T{  true  }T\n"
"T{ 0.0  0.00001 T_FE.  }T{  true  }T\n"
"T{ 0.0  0.00001 T_FG.  }T{  true  }T\n"
"T{ 0.0  0.00001 T_F>D  }T{  true  }T\n"
"\n"
"T{ 12.34  -0.0001 T_F.  }T{  true  }T\n"
"T{ 12.34  -0.0001 T_FS.  }T{  true  }T\n"
"T{ 12.34  -0.0001 T_FE.  }T{  true  }T\n"
"T{ 12.34  -0.0001 T_FG.  }T{  true  }T\n"
"T{ 1234.0  -0.0001 T_F>D  }T{  true  }T\n"
"\n"
"T{ 2345 S>F  79 S>F  F/  -0.0001 T_F.  }T{  true  }T\n"
"T{ 511 S>F  -294 S>F  F/  -0.0001 T_F.  }T{  true  }T\n"
"\n"
": T.SERIES { N matchCFA | flag -- ok? } (  fstart fmult -f- )\n"
"    fswap  ( -- fmult fstart )\n"
"    true -> flag\n"
"    N 0\n"
"    ?DO\n"
"        fdup -0.0001 matchCFA execute not\n"
"        IF\n"
"            false -> flag\n"
"            .\" T_F_SERIES failed for \" i . fdup f. cr\n"
"            leave\n"
"        THEN\n"
"\\       i . fdup f. cr\n"
"        fover f*\n"
"    LOOP\n"
"    matchCFA >name id. .\"  T.SERIES final = \" fs. cr\n"
"    flag\n"
";\n"
"\n"
": T.SERIES_F.    ['] t_f.  t.series ;\n"
": T.SERIES_FS.   ['] t_fs. t.series ;\n"
": T.SERIES_FG.   ['] t_fg. t.series ;\n"
": T.SERIES_FE.   ['] t_fe. t.series ;\n"
": T.SERIES_F>D   ['] t_f>d t.series ;\n"
"\n"
"T{  1.0     1.3       150 t.series_f.    }T{  true  }T\n"
"T{  1.0    -1.3       150 t.series_f.    }T{  true  }T\n"
"T{  2.3456789 1.3719  150 t.series_f.    }T{  true  }T\n"
"\n"
"T{  3000.0  1.298     120 t.series_f>d   }T{  true  }T\n"
"\n"
"T{  1.2     1.27751   150 t.series_fs.   }T{  true  }T\n"
"T{  7.43    0.812255  200 t.series_fs.   }T{  true  }T\n"
"\n"
"T{  1.195   1.30071   150 t.series_fe.   }T{  true  }T\n"
"T{  5.913   0.80644   200 t.series_fe.   }T{  true  }T\n"
"\n"
"T{  1.395   1.55071   120 t.series_fe.   }T{  true  }T\n"
"T{  5.413   0.83644   160 t.series_fe.   }T{  true  }T\n"
"\n"
"\\  ----------------------------------------------------- FABS\n"
"T{  0.0   FABS  0.0         0.00001 F~    }T{  true  }T\n"
"T{  7.0   FABS  7.0         0.00001 F~    }T{  true  }T\n"
"T{ -47.3  FABS  47.3        0.00001 F~    }T{  true  }T\n"
"\n"
"\\  ----------------------------------------------------- FSQRT\n"
"T{  49.0  FSQRT  7.0       -0.0001 F~    }T{  true  }T\n"
"T{  2.0   FSQRT  1.414214  -0.0001 F~    }T{  true  }T\n"
"\n"
"\\  ----------------------------------------------------- FSIN\n"
"T{  0.0   FSIN  0.0         0.00001 F~    }T{  true  }T\n"
"T{  PI    FSIN  0.0         0.00001 F~    }T{  true  }T\n"
"T{  PI 2.0 F*  FSIN   0.0   0.00001 F~    }T{  true  }T\n"
"T{  PI 0.5 F*  FSIN   1.0   0.00001 F~    }T{  true  }T\n"
"T{  PI 6.0 F/  FSIN   0.5   0.00001 F~    }T{  true  }T\n"
"\n"
"\\  ----------------------------------------------------- \\\n"
"}TEST\n"
"\n";

const char* t_floats_fth = (const char*) temp_binary_data_117;

//================== t_include.fth ==================
static const unsigned char temp_binary_data_118[] =
"\\ Test INCLUDE errors.\n"
"\\\n"
"\\ Copyright 2001Phil Burk\n"
"\n"
"include? }T{  t_tools.fth\n"
"\n"
"marker task-t_string.fth\n"
"\n"
"decimal\n"
"\n"
": F_UNDEF \" t_load_undef.fth\" ;\n"
"\n"
"test{\n"
"\n"
"T{ F_UNDEF ' $include catch }T{ F_UNDEF -13 }T\n"
"\n"
"\n"
"}test\n";

const char* t_include_fth = (const char*) temp_binary_data_118;

//================== t_load.fth ==================
static const unsigned char temp_binary_data_119[] =
"\\ Test nested INCLUDE errors.\n"
"\\\n"
"\\ Copyright 2001Phil Burk\n"
"\n"
"\\ include t_load_undef.fth\n"
"\\ include t_load_semi.fth\n"
"include t_load_defer.fth\n";

const char* t_load_fth = (const char*) temp_binary_data_119;

//================== t_load_defer.fth ==================
static const unsigned char temp_binary_data_120[] =
"\\ Test INCLUDE errors.\n"
"\n"
"what's dup >name id.  \\ but DUP is not deferred!\n"
"\n"
"We should never reach this text.\n";

const char* t_load_defer_fth = (const char*) temp_binary_data_120;

//================== t_load_pairs.fth ==================
static const unsigned char temp_binary_data_121[] =
"\\ Test INCLUDE errors.\n"
"\n"
": T.LOAD.PAIRS\n"
"    10 0 DO i . THEN\n"
";\n";

const char* t_load_pairs_fth = (const char*) temp_binary_data_121;

//================== t_load_semi.fth ==================
static const unsigned char temp_binary_data_122[] =
"\\ Test INCLUDE errors.\n"
"\n"
": T.LOAD.PAIRS\n"
"    1 IF\n"
"    .\" hello\" cr\n"
"; \\ missing a THEN\n";

const char* t_load_semi_fth = (const char*) temp_binary_data_122;

//================== t_load_undef.fth ==================
static const unsigned char temp_binary_data_123[] =
"\\ Test INCLUDE errors.\n"
"\n"
": T.LOAD.UNDEF\n"
"    23 45 swap BADWORD \\ reference an undefined word!\n"
";\n";

const char* t_load_undef_fth = (const char*) temp_binary_data_123;

//================== t_locals.fth ==================
static const unsigned char temp_binary_data_124[] =
"\\ @(#) t_locals.fth 97/01/28 1.1\n"
"\\ Test PForth LOCAL variables.\n"
"\\\n"
"\\ Copyright 1996 3DO, Phil Burk\n"
"\n"
"include? }T{  t_tools.fth\n"
"\n"
"anew task-t_locals.fth\n"
"decimal\n"
"\n"
"test{\n"
"\n"
"\\ test value and locals\n"
"T{ 333 value  my-value   my-value }T{  333 }T\n"
"T{ 1000 -> my-value   my-value }T{ 1000 }T\n"
"T{ 35 +-> my-value   my-value }T{ 1035 }T\n"
": test.value  ( -- ok )\n"
"    100 -> my-value\n"
"    my-value 100 =\n"
"    47 +-> my-value\n"
"    my-value 147 = AND\n"
";\n"
"T{ test.value }T{ TRUE }T\n"
"\n"
"\\ test locals in a word\n"
": test.locs  { aa bb | cc -- ok }\n"
"    cc 0=\n"
"    aa bb + -> cc\n"
"    aa bb +   cc = AND\n"
"    aa -> cc\n"
"    bb +->  cc\n"
"    aa bb +   cc = AND\n"
";\n"
"\n"
"T{ 200 59 test.locs }T{  TRUE }T\n"
"\n"
".( Test warning when no locals defined.) cr\n"
": loc.nonames { -- } 1234 ;\n"
"T{ loc.nonames }T{ 1234 }T\n"
"\n"
"\\ try to put EOLs and comments in variable list\n"
": calc.area {\n"
"    width    \\ horizontal dimension\n"
"    height   \\ vertical dimension\n"
"    -- area , calculate area of a rectangle }\n"
"    width height *\n"
";\n"
"\n"
"T{ 5 20 calc.area }T{ 100 }T\n"
"\n"
"}test\n"
"\n";

const char* t_locals_fth = (const char*) temp_binary_data_124;

//================== t_nolf.fth ==================
static const unsigned char temp_binary_data_125[] =
"\\ Test behavior of pForth when line encountered with no EOF at end.\n"
"\n"
".\" First Line of Two\" cr\n"
".\" Second Line of Two\" cr\n";

const char* t_nolf_fth = (const char*) temp_binary_data_125;

//================== t_required_helper1.fth ==================
static const unsigned char temp_binary_data_126[] =
"\\ For testing REQUIRED etc\n"
"\n"
"1+\n";

const char* t_required_helper1_fth = (const char*) temp_binary_data_126;

//================== t_required_helper2.fth ==================
static const unsigned char temp_binary_data_127[] =
"\\ For testing REQUIRED etc\n"
"\n"
"1+\n";

const char* t_required_helper2_fth = (const char*) temp_binary_data_127;

//================== t_strings.fth ==================
static const unsigned char temp_binary_data_128[] =
"\\ @(#) t_strings.fth 97/12/10 1.1\n"
"\\ Test ANS Forth String Word Set\n"
"\\\n"
"\\ Copyright 1994 3DO, Phil Burk\n"
"\n"
"include? }T{  t_tools.fth\n"
"\n"
"marker task-t_string.fth\n"
"\n"
"decimal\n"
"\n"
"test{\n"
"\n"
"echo off\n"
"\n"
"\\ ==========================================================\n"
"\\ test is.ok?\n"
"T{ 1 2 3 }T{ 1 2 3 }T\n"
"\n"
": STR1  S\" Hello    \" ;\n"
": STR2  S\" Hello World\" ;\n"
": STR3  S\" \" ;\n"
"\n"
"\\  ----------------------------------------------------- -TRAILING\n"
"T{ STR1 -TRAILING }T{ STR1 DROP 5 }T\n"
"T{ STR2 -TRAILING }T{ STR2 }T\n"
"T{ STR3 -TRAILING }T{ STR3 }T\n"
"\n"
"\\  ----------------------------------------------------- /STRING\n"
"T{ STR2  6  /STRING  }T{ STR2 DROP 6 CHARS +   STR2 NIP 6 -  }T\n"
"\n"
"\n"
"\\  ----------------------------------------------------- BLANK\n"
": T.COMMA.SEQ  ( n -- , lay down N sequential bytes )\n"
"    0 ?DO I C, LOOP\n"
";\n"
"CREATE T-BLANK-DATA   64 T.COMMA.SEQ\n"
"T{ T-BLANK-DATA 8 + C@ }T{ 8 }T\n"
"T-BLANK-DATA 7 + 3 BLANK\n"
"T{ T-BLANK-DATA 6 + C@ }T{ 6 }T\n"
"T{ T-BLANK-DATA 7 + C@ }T{ BL }T\n"
"T{ T-BLANK-DATA 8 + C@ }T{ BL }T\n"
"T{ T-BLANK-DATA 9 + C@ }T{ BL }T\n"
"T{ T-BLANK-DATA 10 + C@ }T{ 10 }T\n"
"FORGET T.COMMA.SEQ\n"
"\n"
"\\  ----------------------------------------------------- CMOVE\n"
": T.COMMA.SEQ  ( n -- , lay down N sequential bytes )\n"
"    0 ?DO I C, LOOP\n"
";\n"
"CREATE T-BLANK-DATA   64 T.COMMA.SEQ\n"
"T-BLANK-DATA 7 + T-BLANK-DATA 6 + 3 CMOVE\n"
"T{ T-BLANK-DATA 5 + C@ }T{ 5 }T\n"
"T{ T-BLANK-DATA 6 + C@ }T{ 7 }T\n"
"T{ T-BLANK-DATA 7 + C@ }T{ 8 }T\n"
"T{ T-BLANK-DATA 8 + C@ }T{ 9 }T\n"
"T{ T-BLANK-DATA 9 + C@ }T{ 9 }T\n"
"FORGET T.COMMA.SEQ\n"
"\n"
"\\  ----------------------------------------------------- CMOVE>\n"
": T.COMMA.SEQ  ( n -- , lay down N sequential bytes )\n"
"    0 ?DO I C, LOOP\n"
";\n"
"CREATE T-BLANK-DATA   64 T.COMMA.SEQ\n"
"T{ T-BLANK-DATA 6 + T-BLANK-DATA 7 + 3 CMOVE>\n"
"T{ T-BLANK-DATA 5 + C@ }T{ 5 }T\n"
"T{ T-BLANK-DATA 6 + C@ }T{ 6 }T\n"
"T{ T-BLANK-DATA 7 + C@ }T{ 6 }T\n"
"T{ T-BLANK-DATA 8 + C@ }T{ 7 }T\n"
"T{ T-BLANK-DATA 9 + C@ }T{ 8 }T\n"
"T{ T-BLANK-DATA 10 + C@ }T{ 10 }T\n"
"FORGET T.COMMA.SEQ\n"
"\n"
"\\  ----------------------------------------------------- COMPARE\n"
"T{ : T.COMPARE.1 S\" abcd\" S\" abcd\"    compare ; t.compare.1 }T{   0 }T\n"
"T{ : T.COMPARE.2 S\" abcd\" S\" abcde\"   compare ; t.compare.2 }T{  -1 }T\n"
"T{ : T.COMPARE.3 S\" abcdef\" S\" abcde\" compare ; t.compare.3 }T{   1 }T\n"
"T{ : T.COMPARE.4 S\" abGd\" S\" abcde\"   compare ; t.compare.4 }T{  -1 }T\n"
"T{ : T.COMPARE.5 S\" abcd\" S\" aXcde\"   compare ; t.compare.5 }T{   1 }T\n"
"T{ : T.COMPARE.6 S\" abGd\" S\" abcd\"    compare ; t.compare.6 }T{  -1 }T\n"
"T{ : T.COMPARE.7 S\" World\" S\" World\"  compare ; t.compare.7 }T{   0 }T\n"
"FORGET T.COMPARE.1\n"
"\n"
"\\  ----------------------------------------------------- SEARCH\n"
": STR-SEARCH S\" ABCDefghIJKL\" ;\n"
"T{ : T.SEARCH.1 STR-SEARCH S\" ABCD\" SEARCH ; T.SEARCH.1 }T{ STR-SEARCH TRUE }T\n"
"T{ : T.SEARCH.2 STR-SEARCH S\" efg\"  SEARCH ; T.SEARCH.2 }T{\n"
"     STR-SEARCH 4 - SWAP 4 CHARS + SWAP TRUE }T\n"
"T{ : T.SEARCH.3 STR-SEARCH S\" IJKL\" SEARCH ; T.SEARCH.3 }T{\n"
"     STR-SEARCH DROP 8 CHARS + 4 TRUE }T\n"
"T{ : T.SEARCH.4 STR-SEARCH STR-SEARCH SEARCH ; T.SEARCH.4 }T{\n"
"     STR-SEARCH  TRUE }T\n"
"\n"
"T{ : T.SEARCH.5 STR-SEARCH S\" CDex\" SEARCH ; T.SEARCH.5 }T{\n"
"     STR-SEARCH  FALSE }T\n"
"T{ : T.SEARCH.6 STR-SEARCH S\" KLM\" SEARCH ; T.SEARCH.6 }T{\n"
"     STR-SEARCH  FALSE }T\n"
"FORGET STR-SEARCH\n"
"\n"
"\\  ----------------------------------------------------- SLITERAL\n"
"CREATE FAKE-STRING  CHAR H C,   CHAR e C,  CHAR l C, CHAR l C, CHAR o C,\n"
"ALIGN\n"
"T{ : T.SLITERAL.1  [ FAKE-STRING 5 ] SLITERAL ; T.SLITERAL.1   FAKE-STRING 5 COMPARE\n"
"     }T{ 0 }T\n"
"\n"
"}test\n";

const char* t_strings_fth = (const char*) temp_binary_data_128;

//================== t_tools.fth ==================
static const unsigned char temp_binary_data_129[] =
"\\ @(#) t_tools.fth 97/12/10 1.1\n"
"\\ Test Tools for pForth\n"
"\\\n"
"\\ Based on testing tools from John Hayes\n"
"\\ (c) 1993 Johns Hopkins University / Applied Physics Laboratory\n"
"\\\n"
"\\ Syntax was changed to avoid conflict with { -> and } for local variables.\n"
"\\ Also added tracking of #successes and #errors.\n"
"\n"
"anew task-t_tools.fth\n"
"\n"
"decimal\n"
"\n"
"variable TEST-DEPTH\n"
"variable TEST-PASSED\n"
"variable TEST-FAILED\n"
"\n"
": TEST{\n"
"        depth test-depth !\n"
"        0 test-passed !\n"
"        0 test-failed !\n"
";\n"
"\n"
"\n"
": }TEST\n"
"        test-passed @ 4 .r .\"  passed, \"\n"
"        test-failed @ 4 .r .\"  failed.\" cr\n"
";\n"
"\n"
"\n"
"VARIABLE actual-depth       \\ stack record\n"
"CREATE actual-results 20 CELLS ALLOT\n"
"\n"
": empty-stack \\ ( ... -- ) Empty stack.\n"
"   DEPTH dup 0>\n"
"   IF 0 DO DROP LOOP\n"
"   ELSE drop\n"
"   THEN ;\n"
"\n"
"CREATE the-test 128 CHARS ALLOT\n"
"\n"
": ERROR     \\ ( c-addr u -- ) Display an error message followed by\n"
"        \\ the line that had the error.\n"
"   TYPE the-test COUNT TYPE CR \\ display line corresponding to error\n"
"   empty-stack          \\ throw away every thing else\n"
";\n"
"\n"
"\n"
": T{\n"
"    source the-test place\n"
"    empty-stack\n"
";\n"
"\n"
": }T{   \\ ( ... -- ) Record depth and content of stack.\n"
"    DEPTH actual-depth !    \\ record depth\n"
"    DEPTH 0\n"
"    ?DO\n"
"        actual-results I CELLS + !\n"
"    LOOP \\ save them\n"
";\n"
"\n"
": }T    \\ ( ... -- ) Compare stack (expected) contents with saved\n"
"        \\ (actual) contents.\n"
"    DEPTH\n"
"    actual-depth @ =\n"
"    IF  \\ if depths match\n"
"        1 test-passed +!  \\ assume will pass\n"
"        DEPTH 0\n"
"        ?DO             \\ for each stack item\n"
"            actual-results I CELLS + @ \\ compare actual with expected\n"
"            <>\n"
"            IF\n"
"                -1 test-passed +!\n"
"                1 test-failed +!\n"
"                S\" INCORRECT RESULT: \" error\n"
"                LEAVE\n"
"            THEN\n"
"        LOOP\n"
"    ELSE                \\ depth mismatch\n"
"        1 test-failed +!\n"
"        S\" WRONG NUMBER OF RESULTS: \" error\n"
"    THEN\n"
";\n";

const char* t_tools_fth = (const char*) temp_binary_data_129;

//================== termio.fth ==================
static const unsigned char temp_binary_data_130[] =
"\\ Terminal I/O\n"
"\\\n"
"\\ Requires an ANSI compatible terminal.\n"
"\\\n"
"\\ To get Windows computers to use ANSI mode in their DOS windows,\n"
"\\ Add this line to \"C:\\CONFIG.SYS\" then reboot.\n"
"\\\n"
"\\  device=c:\\windows\\command\\ansi.sys\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1988 Phil Burk\n"
"\\ Revised 2001 for pForth\n"
"\n"
"ANEW TASK-TERMIO.FTH\n"
"decimal\n"
"\n"
"$ 08 constant ASCII_BACKSPACE\n"
"$ 7F constant ASCII_DELETE\n"
"$ 1B constant ASCII_ESCAPE\n"
"$ 01 constant ASCII_CTRL_A\n"
"$ 05 constant ASCII_CTRL_E\n"
"$ 18 constant ASCII_CTRL_X\n"
"\n"
"\\ ANSI arrow key sequences\n"
"\\ ESC [ 0x41 is UP\n"
"\\ ESC [ 0x42 is DOWN\n"
"\\ ESC [ 0x43 is RIGHT\n"
"\\ ESC [ 0x44 is LEFT\n"
"\n"
"\\ ANSI terminal control\n"
"\\ ESC [ 2J is clear screen\n"
"\\ ESC [ {n} D is move left\n"
"\\ ESC [ {n} C is move right\n"
"\\ ESC [ K is erase to end of line\n"
"\n"
": ESC[ ( send ESCAPE and [ )\n"
"    ASCII_ESCAPE emit\n"
"    ascii [ emit\n"
";\n"
"\n"
": CLS ( -- , clear screen )\n"
"    ESC[ .\" 2J\"\n"
";\n"
"\n"
": TIO.BACKWARDS ( n -- , move cursor backwards )\n"
"    ESC[\n"
"    base @ >r decimal\n"
"    0 .r\n"
"    r> base !\n"
"    ascii D emit\n"
";\n"
"\n"
": TIO.FORWARDS ( n -- , move cursor forwards )\n"
"    ESC[\n"
"    base @ >r decimal\n"
"    0 .r\n"
"    r> base !\n"
"    ascii C emit\n"
";\n"
"\n"
": TIO.ERASE.EOL ( -- , erase to the end of the line )\n"
"    ESC[\n"
"    ascii K emit\n"
";\n"
"\n"
": BELL ( -- , ring the terminal bell )\n"
"    7 emit\n"
";\n"
"\n"
": BACKSPACE ( -- , backspace action )\n"
"    8 emit  space  8 emit\n"
";\n"
"\n"
"0 [IF] \\ for testing\n"
"\n"
": SHOWKEYS  ( -- , show keys pressed in hex )\n"
"    BEGIN\n"
"        key\n"
"        dup .\n"
"        .\" , $ \" dup .hex cr\n"
"        ascii q =\n"
"    UNTIL\n"
";\n"
"\n"
": AZ ascii z 1+ ascii a DO i emit LOOP ;\n"
"\n"
": TEST.BACK1\n"
"    AZ 5 tio.backwards\n"
"    1000 msec\n"
"    tio.erase.eol\n"
";\n"
": TEST.BACK2\n"
"    AZ 10 tio.backwards\n"
"    1000 msec\n"
"    .\" 12345\"\n"
"    1000 msec\n"
";\n"
"[THEN]\n";

const char* termio_fth = (const char*) temp_binary_data_130;

//================== tester.fth ==================
static const unsigned char temp_binary_data_131[] =
"\\ From: John Hayes S1I\n"
"\\ Subject: tester.fr\n"
"\\ Date: Mon, 27 Nov 95 13:10:09 PST\n"
"\n"
"\\ (C) 1995 JOHNS HOPKINS UNIVERSITY / APPLIED PHYSICS LABORATORY\n"
"\\ MAY BE DISTRIBUTED FREELY AS LONG AS THIS COPYRIGHT NOTICE REMAINS.\n"
"\\ VERSION 1.1\n"
"HEX\n"
"\n"
"\\ SET THE FOLLOWING FLAG TO TRUE FOR MORE VERBOSE OUTPUT; THIS MAY\n"
"\\ ALLOW YOU TO TELL WHICH TEST CAUSED YOUR SYSTEM TO HANG.\n"
"VARIABLE VERBOSE\n"
"   FALSE VERBOSE !\n"
"\n"
": EMPTY-STACK   \\ ( ... -- ) EMPTY STACK: HANDLES UNDERFLOWED STACK TOO.\n"
"   DEPTH ?DUP IF DUP 0< IF NEGATE 0 DO 0 LOOP ELSE 0 DO DROP LOOP THEN THEN ;\n"
"\n"
": ERROR     \\ ( C-ADDR U -- ) DISPLAY AN ERROR MESSAGE FOLLOWED BY\n"
"        \\ THE LINE THAT HAD THE ERROR.\n"
"   TYPE SOURCE TYPE CR          \\ DISPLAY LINE CORRESPONDING TO ERROR\n"
"   EMPTY-STACK              \\ THROW AWAY EVERY THING ELSE\n"
";\n"
"\n"
"VARIABLE ACTUAL-DEPTH           \\ STACK RECORD\n"
"CREATE ACTUAL-RESULTS 20 CELLS ALLOT\n"
"\n"
": {     \\ ( -- ) SYNTACTIC SUGAR.\n"
"   ;\n"
"\n"
": ->        \\ ( ... -- ) RECORD DEPTH AND CONTENT OF STACK.\n"
"   DEPTH DUP ACTUAL-DEPTH !     \\ RECORD DEPTH\n"
"   ?DUP IF              \\ IF THERE IS SOMETHING ON STACK\n"
"      0 DO ACTUAL-RESULTS I CELLS + ! LOOP \\ SAVE THEM\n"
"   THEN ;\n"
"\n"
": }     \\ ( ... -- ) COMPARE STACK (EXPECTED) CONTENTS WITH SAVED\n"
"        \\ (ACTUAL) CONTENTS.\n"
"   DEPTH ACTUAL-DEPTH @ = IF        \\ IF DEPTHS MATCH\n"
"      DEPTH ?DUP IF         \\ IF THERE IS SOMETHING ON THE STACK\n"
"         0 DO               \\ FOR EACH STACK ITEM\n"
"        ACTUAL-RESULTS I CELLS + @  \\ COMPARE ACTUAL WITH EXPECTED\n"
"        <> IF S\" INCORRECT RESULT: \" ERROR LEAVE THEN\n"
"     LOOP\n"
"      THEN\n"
"   ELSE                 \\ DEPTH MISMATCH\n"
"      S\" WRONG NUMBER OF RESULTS: \" ERROR\n"
"   THEN ;\n"
"\n"
": TESTING   \\ ( -- ) TALKING COMMENT.\n"
"   SOURCE VERBOSE @\n"
"   IF DUP >R TYPE CR R> >IN !\n"
"   ELSE >IN ! DROP\n"
"   THEN ;\n"
"\n";

const char* tester_fth = (const char*) temp_binary_data_131;

//================== trace.fth ==================
static const unsigned char temp_binary_data_132[] =
"\\ @(#) trace.fth 98/01/28 1.2\n"
"\\ TRACE ( <name> -- , trace pForth word )\n"
"\\\n"
"\\ Single step debugger.\n"
"\\   TRACE  ( i*x <name> -- , setup trace for Forth word )\n"
"\\   S      ( -- , step over )\n"
"\\   SM     ( many -- , step over many times )\n"
"\\   SD     ( -- , step down )\n"
"\\   G      ( -- , go to end of word )\n"
"\\   GD     ( n -- , go down N levels from current level, stop at end of this level )\n"
"\\\n"
"\\ This debugger works by emulating the inner interpreter of pForth.\n"
"\\ It executes code and maintains a separate return stack for the\n"
"\\ program under test.  Thus all primitives that operate on the return\n"
"\\ stack, such as DO and R> must be trapped.  Local variables must\n"
"\\ also be handled specially.  Several state variables are also\n"
"\\ saved and restored to establish the context for the program being\n"
"\\ tested.\n"
"\\\n"
"\\ Copyright 1997 Phil Burk\n"
"\\\n"
"\\ Modifications:\n"
"\\      19990930 John Providenza - Fixed stack bugs in GD\n"
"\n"
"anew task-trace.fth\n"
"\n"
": SPACE.TO.COLUMN  ( col -- )\n"
"    out @ - spaces\n"
";\n"
"\n"
": IS.PRIMITIVE? ( xt -- flag , true if kernel primitive )\n"
"    ['] first_colon <\n"
";\n"
"\n"
"0 value TRACE_IP         \\ instruction pointer\n"
"0 value TRACE_LEVEL      \\ level of descent for inner interpreter\n"
"0 value TRACE_LEVEL_MAX  \\ maximum level of descent\n"
"\n"
"private{\n"
"\n"
"\\ use fake return stack\n"
"128 cells constant TRACE_RETURN_SIZE \\ size of return stack in bytes\n"
"create TRACE-RETURN-STACK TRACE_RETURN_SIZE 16 + allot\n"
"variable TRACE-RSP\n"
": TRACE.>R     ( n -- ) trace-rsp @ cell- dup trace-rsp ! ! ;  \\ *(--rsp) = n\n"
": TRACE.R>     ( -- n ) trace-rsp @ dup @ swap cell+ trace-rsp ! ;  \\ n = *rsp++\n"
": TRACE.R@     ( -- n ) trace-rsp @ @ ; ; \\ n = *rsp\n"
": TRACE.RPICK  ( index -- n ) cells trace-rsp @ + @ ; ; \\ n = rsp[index]\n"
": TRACE.0RP    ( -- n ) trace-return-stack trace_return_size + 8 + trace-rsp ! ;\n"
": TRACE.RDROP  ( --  ) cell trace-rsp +! ;\n"
": TRACE.RCHECK ( -- , abort if return stack out of range )\n"
"    trace-rsp @ trace-return-stack u<\n"
"        abort\" TRACE return stack OVERFLOW!\"\n"
"    trace-rsp @ trace-return-stack trace_return_size + 12 + u>\n"
"        abort\" TRACE return stack UNDERFLOW!\"\n"
";\n"
"\n"
"\\ save and restore several state variables\n"
"10 cells constant TRACE_STATE_SIZE\n"
"create TRACE-STATE-1 TRACE_STATE_SIZE allot\n"
"create TRACE-STATE-2 TRACE_STATE_SIZE allot\n"
"\n"
"variable TRACE-STATE-PTR\n"
": TRACE.SAVE++ ( addr -- , save next thing )\n"
"    @ trace-state-ptr @ !\n"
"    cell trace-state-ptr +!\n"
";\n"
"\n"
": TRACE.SAVE.STATE  ( -- )\n"
"    state trace.save++\n"
"    hld   trace.save++\n"
"    base  trace.save++\n"
";\n"
"\n"
": TRACE.SAVE.STATE1  ( -- , save normal state )\n"
"    trace-state-1 trace-state-ptr !\n"
"    trace.save.state\n"
";\n"
": TRACE.SAVE.STATE2  ( -- , save state of word being debugged )\n"
"    trace-state-2 trace-state-ptr !\n"
"    trace.save.state\n"
";\n"
"\n"
"\n"
": TRACE.RESTORE++ ( addr -- , restore next thing )\n"
"    trace-state-ptr @ @ swap !\n"
"    cell trace-state-ptr +!\n"
";\n"
"\n"
": TRACE.RESTORE.STATE  ( -- )\n"
"    state trace.restore++\n"
"    hld   trace.restore++\n"
"    base  trace.restore++\n"
";\n"
"\n"
": TRACE.RESTORE.STATE1  ( -- )\n"
"    trace-state-1 trace-state-ptr !\n"
"    trace.restore.state\n"
";\n"
": TRACE.RESTORE.STATE2  ( -- )\n"
"    trace-state-2 trace-state-ptr !\n"
"    trace.restore.state\n"
";\n"
"\n"
"\\ The implementation of these pForth primitives is specific to pForth.\n"
"\n"
"variable TRACE-LOCALS-PTR  \\ point to top of local frame\n"
"\n"
"\\ create a return stack frame for NUM local variables\n"
": TRACE.(LOCAL.ENTRY)  ( x0 x1 ... xn n -- )  { num | lp -- }\n"
"    trace-locals-ptr @ trace.>r\n"
"    trace-rsp @ trace-locals-ptr !\n"
"    trace-rsp @  num cells - trace-rsp !  \\ make room for locals\n"
"    trace-rsp @ -> lp\n"
"    num 0\n"
"    DO\n"
"        lp !\n"
"        cell +-> lp  \\ move data into locals frame on return stack\n"
"    LOOP\n"
";\n"
"\n"
": TRACE.(LOCAL.EXIT) ( -- )\n"
"    trace-locals-ptr @  trace-rsp !\n"
"    trace.r> trace-locals-ptr !\n"
";\n"
": TRACE.(LOCAL@) ( l# -- n , fetch from local frame )\n"
"    trace-locals-ptr @  swap cells - @\n"
";\n"
": TRACE.(1_LOCAL@) ( -- n ) 1 trace.(local@) ;\n"
": TRACE.(2_LOCAL@) ( -- n ) 2 trace.(local@) ;\n"
": TRACE.(3_LOCAL@) ( -- n ) 3 trace.(local@) ;\n"
": TRACE.(4_LOCAL@) ( -- n ) 4 trace.(local@) ;\n"
": TRACE.(5_LOCAL@) ( -- n ) 5 trace.(local@) ;\n"
": TRACE.(6_LOCAL@) ( -- n ) 6 trace.(local@) ;\n"
": TRACE.(7_LOCAL@) ( -- n ) 7 trace.(local@) ;\n"
": TRACE.(8_LOCAL@) ( -- n ) 8 trace.(local@) ;\n"
"\n"
": TRACE.(LOCAL!) ( n l# -- , store into local frame )\n"
"    trace-locals-ptr @  swap cells - !\n"
";\n"
": TRACE.(1_LOCAL!) ( -- n ) 1 trace.(local!) ;\n"
": TRACE.(2_LOCAL!) ( -- n ) 2 trace.(local!) ;\n"
": TRACE.(3_LOCAL!) ( -- n ) 3 trace.(local!) ;\n"
": TRACE.(4_LOCAL!) ( -- n ) 4 trace.(local!) ;\n"
": TRACE.(5_LOCAL!) ( -- n ) 5 trace.(local!) ;\n"
": TRACE.(6_LOCAL!) ( -- n ) 6 trace.(local!) ;\n"
": TRACE.(7_LOCAL!) ( -- n ) 7 trace.(local!) ;\n"
": TRACE.(8_LOCAL!) ( -- n ) 8 trace.(local!) ;\n"
"\n"
": TRACE.(LOCAL+!) ( n l# -- , store into local frame )\n"
"    trace-locals-ptr @  swap cells - +!\n"
";\n"
": TRACE.(?DO)  { limit start ip -- ip' }\n"
"    limit start =\n"
"    IF\n"
"        ip @ +-> ip \\ BRANCH\n"
"    ELSE\n"
"        start trace.>r\n"
"        limit trace.>r\n"
"        cell +-> ip\n"
"    THEN\n"
"    ip\n"
";\n"
"\n"
": TRACE.(LOOP)  { ip | limit indx -- ip' }\n"
"    trace.r> -> limit\n"
"    trace.r> 1+ -> indx\n"
"    limit indx =\n"
"    IF\n"
"        cell +-> ip\n"
"    ELSE\n"
"        indx trace.>r\n"
"        limit trace.>r\n"
"        ip @ +-> ip\n"
"    THEN\n"
"    ip\n"
";\n"
"\n"
": TRACE.(+LOOP)  { delta ip | limit indx oldindx -- ip' }\n"
"    trace.r> -> limit\n"
"    trace.r> -> oldindx\n"
"    oldindx delta + -> indx\n"
"\\ /* Do indices cross boundary between LIMIT-1 and LIMIT ? */\n"
"\\  if( ( (OldIndex - Limit) & ((Limit-1) - NewIndex) & 0x80000000 ) ||\n"
"\\    ( (NewIndex - Limit) & ((Limit-1) - OldIndex) & 0x80000000 ) )\n"
"    oldindx limit -    limit 1-    indx -  AND $ 80000000 AND\n"
"       indx limit -    limit 1- oldindx -  AND $ 80000000 AND OR\n"
"    IF\n"
"        cell +-> ip\n"
"    ELSE\n"
"        indx trace.>r\n"
"        limit trace.>r\n"
"        ip @ +-> ip\n"
"    THEN\n"
"    ip\n"
";\n"
"\n"
": TRACE.CHECK.IP  {  ip -- }\n"
"    ip ['] first_colon u<\n"
"    ip here u> OR\n"
"    IF\n"
"        .\" TRACE - IP out of range = \" ip .hex cr\n"
"        abort\n"
"    THEN\n"
";\n"
"\n"
": TRACE.SHOW.IP { ip -- , print name and offset }\n"
"    ip code> >name dup id.\n"
"    name> >code ip swap - .\"  +\" .\n"
";\n"
"\n"
": TRACE.SHOW.STACK { | mdepth -- }\n"
"    base @ >r\n"
"    .\" <\" base @ decimal 1 .r .\" :\"\n"
"    depth 1 .r .\" > \"\n"
"    r> base !\n"
"    depth 5 min -> mdepth\n"
"    depth mdepth  -\n"
"    IF\n"
"        .\" ... \"  \\ if we don't show entire stack\n"
"    THEN\n"
"    mdepth 0\n"
"    ?DO\n"
"        mdepth i 1+ - pick .  \\ show numbers in current base\n"
"    LOOP\n"
";\n"
"\n"
": TRACE.SHOW.NEXT { ip -- }\n"
"    >newline\n"
"    ip trace.check.ip\n"
"\\ show word name and offset\n"
"    .\" << \"\n"
"    ip trace.show.ip\n"
"    16 space.to.column\n"
"\\ show data stack\n"
"    trace.show.stack\n"
"    40 space.to.column .\"  ||\"\n"
"    trace_level 2* spaces\n"
"    ip code@\n"
"    cell +-> ip\n"
"\\ show primitive about to be executed\n"
"    dup .xt space\n"
"\\ trap any primitives that are followed by inline data\n"
"    CASE\n"
"        ['] (LITERAL)  OF ip @  . ENDOF\n"
"        ['] (ALITERAL) OF ip a@ . ENDOF\n"
"[ exists? (FLITERAL) [IF] ]\n"
"        ['] (FLITERAL) OF ip f@ f. ENDOF\n"
"[ [THEN] ]\n"
"        ['] BRANCH     OF ip @  . ENDOF\n"
"        ['] 0BRANCH    OF ip @  . ENDOF\n"
"        ['] (.\")       OF ip count type .' \"' ENDOF\n"
"        ['] (C\")       OF ip count type .' \"' ENDOF\n"
"        ['] (S\")       OF ip count type .' \"' ENDOF\n"
"    ENDCASE\n"
"    65 space.to.column .\" >> \"\n"
";\n"
"\n"
": TRACE.DO.PRIMITIVE  { ip xt | oldhere --  ip' , perform code at ip }\n"
"    xt\n"
"    CASE\n"
"        0 OF -1 +-> trace_level  trace.r> -> ip ENDOF \\ EXIT\n"
"        ['] (CREATE)   OF ip cell- body_offset + ENDOF\n"
"        ['] (LITERAL)  OF ip @ cell +-> ip ENDOF\n"
"        ['] (ALITERAL) OF ip a@ cell +-> ip ENDOF\n"
"[ exists? (FLITERAL) [IF] ]\n"
"        ['] (FLITERAL) OF ip f@ 1 floats +-> ip ENDOF\n"
"[ [THEN] ]\n"
"        ['] BRANCH     OF ip @ +-> ip ENDOF\n"
"        ['] 0BRANCH    OF 0= IF ip @ +-> ip ELSE cell +-> ip THEN ENDOF\n"
"        ['] >R         OF trace.>r ENDOF\n"
"        ['] R>         OF trace.r> ENDOF\n"
"        ['] R@         OF trace.r@ ENDOF\n"
"        ['] RDROP      OF trace.rdrop ENDOF\n"
"        ['] 2>R        OF trace.>r trace.>r ENDOF\n"
"        ['] 2R>        OF trace.r> trace.r> ENDOF\n"
"        ['] 2R@        OF trace.r@ 1 trace.rpick ENDOF\n"
"        ['] i          OF 1 trace.rpick ENDOF\n"
"        ['] j          OF 3 trace.rpick ENDOF\n"
"        ['] (LEAVE)    OF trace.rdrop trace.rdrop  ip @ +-> ip ENDOF\n"
"        ['] (LOOP)     OF ip trace.(loop) -> ip  ENDOF\n"
"        ['] (+LOOP)    OF ip trace.(+loop) -> ip  ENDOF\n"
"        ['] (DO)       OF trace.>r trace.>r ENDOF\n"
"        ['] (?DO)      OF ip trace.(?do) -> ip ENDOF\n"
"        ['] (.\")       OF ip count type  ip count + aligned -> ip ENDOF\n"
"        ['] (C\")       OF ip  ip count + aligned -> ip ENDOF\n"
"        ['] (S\")       OF ip count  ip count + aligned -> ip ENDOF\n"
"        ['] (LOCAL.ENTRY) OF trace.(local.entry) ENDOF\n"
"        ['] (LOCAL.EXIT) OF trace.(local.exit) ENDOF\n"
"        ['] (LOCAL@)   OF trace.(local@)   ENDOF\n"
"        ['] (1_LOCAL@) OF trace.(1_local@) ENDOF\n"
"        ['] (2_LOCAL@) OF trace.(2_local@) ENDOF\n"
"        ['] (3_LOCAL@) OF trace.(3_local@) ENDOF\n"
"        ['] (4_LOCAL@) OF trace.(4_local@) ENDOF\n"
"        ['] (5_LOCAL@) OF trace.(5_local@) ENDOF\n"
"        ['] (6_LOCAL@) OF trace.(6_local@) ENDOF\n"
"        ['] (7_LOCAL@) OF trace.(7_local@) ENDOF\n"
"        ['] (8_LOCAL@) OF trace.(8_local@) ENDOF\n"
"        ['] (LOCAL!)   OF trace.(local!)   ENDOF\n"
"        ['] (1_LOCAL!) OF trace.(1_local!) ENDOF\n"
"        ['] (2_LOCAL!) OF trace.(2_local!) ENDOF\n"
"        ['] (3_LOCAL!) OF trace.(3_local!) ENDOF\n"
"        ['] (4_LOCAL!) OF trace.(4_local!) ENDOF\n"
"        ['] (5_LOCAL!) OF trace.(5_local!) ENDOF\n"
"        ['] (6_LOCAL!) OF trace.(6_local!) ENDOF\n"
"        ['] (7_LOCAL!) OF trace.(7_local!) ENDOF\n"
"        ['] (8_LOCAL!) OF trace.(8_local!) ENDOF\n"
"        ['] (LOCAL+!)  OF trace.(local+!)  ENDOF\n"
"        >r xt EXECUTE r>\n"
"    ENDCASE\n"
"    ip\n"
";\n"
"\n"
": TRACE.DO.NEXT  { ip | xt oldhere --  ip' , perform code at ip }\n"
"    ip trace.check.ip\n"
"\\ set context for word under test\n"
"    trace.save.state1\n"
"    here -> oldhere\n"
"    trace.restore.state2\n"
"    oldhere 256 + dp !\n"
"\\ get execution token\n"
"    ip code@ -> xt\n"
"    cell +-> ip\n"
"\\ execute token\n"
"    xt is.primitive?\n"
"    IF  \\ primitive\n"
"        ip xt trace.do.primitive -> ip\n"
"    ELSE \\ secondary\n"
"        trace_level trace_level_max <\n"
"        IF\n"
"            ip trace.>r         \\ threaded execution\n"
"            1 +-> trace_level\n"
"            xt codebase + -> ip\n"
"        ELSE\n"
"            \\ treat it as a primitive\n"
"            ip xt trace.do.primitive -> ip\n"
"        THEN\n"
"    THEN\n"
"\\ restore original context\n"
"    trace.rcheck\n"
"    trace.save.state2\n"
"    trace.restore.state1\n"
"    oldhere dp !\n"
"    ip\n"
";\n"
"\n"
": TRACE.NEXT { ip | xt -- ip' }\n"
"    trace_level 0>\n"
"    IF\n"
"        ip trace.do.next -> ip\n"
"    THEN\n"
"    trace_level 0>\n"
"    IF\n"
"        ip trace.show.next\n"
"    ELSE\n"
"        trace-stack on\n"
"        .\" Finished.\" cr\n"
"    THEN\n"
"    ip\n"
";\n"
"\n"
"}private\n"
"\n"
": TRACE ( i*x <name> -- i*x , setup trace environment )\n"
"    ' dup is.primitive?\n"
"    IF\n"
"        drop .\" Sorry. You can't trace a primitive.\" cr\n"
"    ELSE\n"
"        1 -> trace_level\n"
"        trace_level -> trace_level_max\n"
"        trace.0rp\n"
"        >code -> trace_ip\n"
"        trace_ip trace.show.next\n"
"        trace-stack off\n"
"        trace.save.state2\n"
"    THEN\n"
";\n"
"\n"
": s ( -- , step over )\n"
"    trace_level -> trace_level_max\n"
"    trace_ip trace.next -> trace_ip\n"
";\n"
"\n"
": sd ( -- , step down )\n"
"    trace_level 1+ -> trace_level_max\n"
"    trace_ip trace.next -> trace_ip\n"
";\n"
"\n"
": sm ( many -- , step many times )\n"
"    trace_level -> trace_level_max\n"
"    0\n"
"    ?DO\n"
"        trace_ip trace.next -> trace_ip\n"
"    LOOP\n"
";\n"
"\n"
"defer trace.user   ( IP -- stop?  )\n"
"' 0= is trace.user\n"
"\n"
": gd { more_levels | stop_level -- }\n"
"    here   what's trace.user   u<  \\ has it been forgotten?\n"
"    IF\n"
"        .\" Resetting TRACE.USER !!!\" cr\n"
"        ['] 0= is trace.user\n"
"    THEN\n"
"\n"
"    more_levels 0<\n"
"    more_levels 10 >\n"
"    or  \\ 19990930 - OR was missing\n"
"    IF\n"
"        .\" GD level out of range (0-10), = \" more_levels . cr\n"
"    ELSE\n"
"        trace_level more_levels + -> trace_level_max\n"
"        trace_level 1- -> stop_level\n"
"        BEGIN\n"
"            trace_ip trace.user \\ call deferred user word\n"
"            ?dup \\ leave flag for UNTIL \\ 19990930 - was DUP\n"
"            IF\n"
"                .\" TRACE.USER returned \" dup . .\" so stopping execution.\" cr\n"
"            ELSE\n"
"                trace_ip trace.next -> trace_ip\n"
"                trace_level stop_level > not\n"
"            THEN\n"
"        UNTIL\n"
"    THEN\n"
";\n"
"\n"
": g ( -- , execute until end of word )\n"
"    0 gd\n"
";\n"
"\n"
": TRACE.HELP ( -- )\n"
"    .\"   TRACE  ( i*x <name> -- , setup trace for Forth word )\" cr\n"
"    .\"   S      ( -- , step over )\" cr\n"
"    .\"   SM     ( many -- , step over many times )\" cr\n"
"    .\"   SD     ( -- , step down )\" cr\n"
"    .\"   G      ( -- , go to end of word )\" cr\n"
"    .\"   GD     ( n -- , go down N levels from current level,\" cr\n"
"    .\"                   stop at end of this level )\" cr\n"
";\n"
"\n"
"privatize\n"
"\n"
"0 [IF]\n"
"variable var1\n"
"100 var1 !\n"
": FOO  dup IF 1 + . THEN 77 var1 @ + . ;\n"
": ZOO 29 foo 99 22 + . ;\n"
": ROO 92 >r 1 r@ + . r> . ;\n"
": MOO  c\" hello\" count type\n"
"    .\" This is a message.\" cr\n"
"    s\" another message\" type cr\n"
";\n"
": KOO 7 FOO .\" DONE\" ;\n"
": TR.DO  4 0 DO i . LOOP ;\n"
": TR.?DO  0 ?DO i . LOOP ;\n"
": TR.LOC1 { aa bb } aa bb + . ;\n"
": TR.LOC2 789 >r 4 5 tr.loc1 r> . ;\n"
"\n"
"[THEN]\n";

const char* trace_fth = (const char*) temp_binary_data_132;

//================== tut.fth ==================
static const unsigned char temp_binary_data_133[] =
"anew task-tut.fth\n"
"\n"
": SUM.OF.N.A ( N -- SUM[N] , calculate sum of N integers )\n"
"           0  \\ starting value of SUM\n"
"           BEGIN\n"
"               OVER 0>   \\ Is N greater than zero?\n"
"           WHILE\n"
"               OVER +  \\ add N to sum\n"
"               SWAP 1- SWAP  \\ decrement N\n"
"           REPEAT\n"
"           SWAP DROP  \\ get rid on N\n"
"       ;\n"
"\n"
": SUM.OF.N.B  ( N -- SUM[N] )\n"
"    0 SWAP  \\ starting value of SUM\n"
"    1+ 0    \\ set indices for DO LOOP\n"
"    ?DO     \\ safer than DO if N=0\n"
"        I +\n"
"    LOOP\n"
";\n"
"\n"
": SUM.OF.N.C  ( N -- SUM[N] )\n"
"    0  \\ starting value of SUM\n"
"    BEGIN   ( -- N' SUM )\n"
"        OVER +\n"
"        SWAP 1- SWAP\n"
"        OVER 0<\n"
"    UNTIL\n"
"    SWAP DROP\n"
";\n"
"\n"
": SUM.OF.N.D  ( N -- SUM[N] )\n"
"    >R  \\ put NUM on return stack\n"
"    0  \\ starting value of SUM\n"
"    BEGIN   ( -- SUM )\n"
"        R@ +  \\ add num to sum\n"
"        R> 1- DUP >R\n"
"        0<\n"
"    UNTIL\n"
"    RDROP  \\ get rid of NUM\n"
";\n"
"\n"
": SUM.OF.N.E  { NUM | SUM -- SUM[N] , use return stack }\n"
"    BEGIN\n"
"        NUM +-> SUM \\ add NUM to SUM\n"
"        -1 +-> NUM  \\ decrement NUM\n"
"        NUM 0<\n"
"    UNTIL\n"
"    SUM  \\ return SUM\n"
";\n"
"\n"
": SUM.OF.N.F  ( NUM -- SUM[N] , Gauss' method )\n"
"    DUP 1+ * 2/\n"
";\n"
"\n"
"\n"
": TTT\n"
"    10 0\n"
"    DO\n"
"        I SUM.OF.N.A .\n"
"        I SUM.OF.N.B .\n"
"        I SUM.OF.N.C .\n"
"        I SUM.OF.N.D .\n"
"        I SUM.OF.N.E .\n"
"        I SUM.OF.N.F .\n"
"        CR\n"
"    LOOP\n"
";\n"
"TTT\n"
"\n";

const char* tut_fth = (const char*) temp_binary_data_133;

//================== wordslik.fth ==================
static const unsigned char temp_binary_data_134[] =
"\\ @(#) wordslik.fth 98/01/26 1.2\n"
"\\\n"
"\\ WORDS.LIKE  ( <string> -- , search for words that contain string )\n"
"\\\n"
"\\ Enter:   WORDS.LIKE +\n"
"\\ Enter:   WORDS.LIKE EMIT\n"
"\\\n"
"\\ Author: Phil Burk\n"
"\\ Copyright 1994 3DO, Phil Burk, Larry Polansky, David Rosenboom\n"
"\\\n"
"\\ The pForth software code is dedicated to the public domain,\n"
"\\ and any third party may reproduce, distribute and modify\n"
"\\ the pForth software code or any derivative works thereof\n"
"\\ without any compensation or license.  The pForth software\n"
"\\ code is provided on an \"as is\" basis without any warranty\n"
"\\ of any kind, including, without limitation, the implied\n"
"\\ warranties of merchantability and fitness for a particular\n"
"\\ purpose and their equivalents under the laws of any jurisdiction.\n"
"\n"
"anew task-wordslik.fth\n"
"decimal\n"
"\n"
"\n"
": PARTIAL.MATCH.NAME  ( $str1 nfa  -- flag , is $str1 in nfa ?\?? )\n"
"    count $ 1F and\n"
"    rot count\n"
"    search\n"
"    >r 2drop r>\n"
";\n"
"\n"
": WORDS.LIKE  ( <name> -- , print all words containing substring )\n"
"    BL word latest\n"
"    >newline\n"
"    BEGIN\n"
"        prevname dup 0<> \\ get previous name in dictionary\n"
"    WHILE\n"
"        2dup partial.match.name\n"
"        IF\n"
"            dup id. tab\n"
"            cr?\n"
"        THEN\n"
"    REPEAT 2drop\n"
"    >newline\n"
";\n";

const char* wordslik_fth = (const char*) temp_binary_data_134;


const char* getNamedResource (const char* resourceNameUTF8, int& numBytes)
{
    unsigned int hash = 0;

    if (resourceNameUTF8 != nullptr)
        while (*resourceNameUTF8 != 0)
            hash = 31 * hash + (unsigned int) *resourceNameUTF8++;

    switch (hash)
    {
        case 0x085160b0:  numBytes = 7868; return action_screen_fth;
        case 0xe5670ea0:  numBytes = 7193; return action_table_fth;
        case 0x49e45a67:  numBytes = 1284; return action_top_fth;
        case 0xa272ba03:  numBytes = 3389; return action_utils_fth;
        case 0x95643540:  numBytes = 3094; return actobj_fth;
        case 0xc9e39926:  numBytes = 2770; return allocator_fth;
        case 0xd2a0a015:  numBytes = 530; return bevel_fth;
        case 0x29b1c8fe:  numBytes = 1692; return build_menus_fth;
        case 0x02686574:  numBytes = 1188; return charmacr_fth;
        case 0xa1af5bba:  numBytes = 2096; return circular_fth;
        case 0x128dec39:  numBytes = 10256; return collection_fth;
        case 0xdb4bb4a7:  numBytes = 1934; return cond_comp_fth;
        case 0x99c82b78:  numBytes = 19604; return control_fth;
        case 0xa192e156:  numBytes = 2578; return ctrl_count_fth;
        case 0x1d4dfe3d:  numBytes = 3423; return ctrl_fader_fth;
        case 0x05ee6154:  numBytes = 5768; return ctrl_numeric_fth;
        case 0xdf959a9c:  numBytes = 11976; return ctrl_text_fth;
        case 0x943c1f70:  numBytes = 7835; return ctrl_xy_fth;
        case 0x658bdfaa:  numBytes = 2575; return dbl_list_fth;
        case 0x21cb3cc4:  numBytes = 666; return deck_fth;
        case 0xb0197a22:  numBytes = 14309; return elmnts_fth;
        case 0xfbb11094:  numBytes = 1854; return errormsg_fth;
        case 0x1726fa3e:  numBytes = 2115; return event_list_fth;
        case 0x845e7328:  numBytes = 4774; return exmember_fth;
        case 0x406f231f:  numBytes = 1079; return float_port_fth;
        case 0xb75a5c61:  numBytes = 333; return global_data_fth;
        case 0x93b5e36e:  numBytes = 1503; return graph_util_fth;
        case 0x696f29a6:  numBytes = 9179; return graphics_fth;
        case 0x180b624f:  numBytes = 9152; return hmsl_top_fth;
        case 0xff9abcd2:  numBytes = 169; return hmsl_version_fth;
        case 0x74a7d502:  numBytes = 7246; return instrument_fth;
        case 0x26121154:  numBytes = 4234; return interpreters_fth;
        case 0xaa5031d8:  numBytes = 5116; return job_fth;
        case 0x55e7faf2:  numBytes = 5579; return load_hmsl_fth;
        case 0x756e7772:  numBytes = 1286; return load_ode_fth;
        case 0x9dec62ea:  numBytes = 688; return make_hmsl_fth;
        case 0x1d3ad71b:  numBytes = 1100; return memalloc_fth;
        case 0x9de7673c:  numBytes = 14014; return midi_fth;
        case 0x9e4eedad:  numBytes = 3511; return midi_globals_fth;
        case 0x05a459e0:  numBytes = 3375; return midi_instrument_fth;
        case 0x40dc7518:  numBytes = 11904; return midi_parser_fth;
        case 0x415ae802:  numBytes = 454; return midi_stubs_fth;
        case 0xdab3a6a6:  numBytes = 1711; return midi_text_fth;
        case 0x97f10963:  numBytes = 5080; return misc_tools_fth;
        case 0x7f5129a3:  numBytes = 16340; return morph_fth;
        case 0xa1ebcf39:  numBytes = 2760; return morph_lists_fth;
        case 0x77b586ac:  numBytes = 7094; return ob_actions_fth;
        case 0xa7ea7708:  numBytes = 8462; return ob_array_fth;
        case 0x50b07b44:  numBytes = 9246; return ob_bind_fth;
        case 0x37c96731:  numBytes = 4242; return ob_dlist_fth;
        case 0x82f688c4:  numBytes = 3815; return ob_ivars_fth;
        case 0x18303ec0:  numBytes = 12185; return ob_main_fth;
        case 0x63d717b7:  numBytes = 1706; return ob_stack_fth;
        case 0x2a80570f:  numBytes = 7473; return obmethod_fth;
        case 0x952eca6d:  numBytes = 7915; return obobject_fth;
        case 0x22a9f624:  numBytes = 6272; return p4thbase_fth;
        case 0x272ad323:  numBytes = 1811; return packed_midi_fth;
        case 0x7cf0fefc:  numBytes = 16234; return player_fth;
        case 0x4fcf657b:  numBytes = 2820; return popup_text_fth;
        case 0x0ae0a8d4:  numBytes = 1666; return production_fth;
        case 0x2bd2986c:  numBytes = 7206; return record_fth;
        case 0x72349532:  numBytes = 6621; return scg_fth;
        case 0xe7246707:  numBytes = 11304; return screen_fth;
        case 0x9990641f:  numBytes = 916; return service_tasks_fth;
        case 0x8c1d53ce:  numBytes = 1373; return set_vectors_fth;
        case 0x9e4f53bc:  numBytes = 18623; return shape_fth;
        case 0xb13b06e6:  numBytes = 32664; return shape_editor_fth;
        case 0x7a72de06:  numBytes = 1871; return stacks_fth;
        case 0xca887898:  numBytes = 430; return startup_fth;
        case 0x1bd1b44f:  numBytes = 2991; return stock_morphs_fth;
        case 0xf2bff88e:  numBytes = 3334; return structure_fth;
        case 0x87bb7fa0:  numBytes = 553; return stubs_fth;
        case 0x6e0c96eb:  numBytes = 786; return test_actions_fth;
        case 0xf1e24b01:  numBytes = 1313; return test_events_fth;
        case 0x2da3cc33:  numBytes = 2044; return test_graphics_fth;
        case 0x537d8b1e:  numBytes = 958; return test_ode_fth;
        case 0x3ca914bf:  numBytes = 763; return test_ode_locals_fth;
        case 0x8432e0e8:  numBytes = 4146; return time_fth;
        case 0xbc13cb70:  numBytes = 875; return top_fth;
        case 0xe4b651b4:  numBytes = 5098; return translators_fth;
        case 0x468a0ccc:  numBytes = 3504; return utils_fth;
        case 0xdabaa378:  numBytes = 12929; return clone_fth;
        case 0x8b71711b:  numBytes = 2602; return dump_struct_fth;
        case 0xa6382350:  numBytes = 1043; return load_file_fth;
        case 0x746dab9e:  numBytes = 1050; return make_all256_fth;
        case 0xe3e78091:  numBytes = 5337; return ansilocs_fth;
        case 0x27ccb6cb:  numBytes = 4444; return bench_fth;
        case 0x458f9f4c:  numBytes = 7012; return c_struct_fth;
        case 0x014a1fcb:  numBytes = 2016; return case_fth;
        case 0x4765b94c:  numBytes = 1413; return condcomp_fth;
        case 0x8c3b08cc:  numBytes = 25851; return coretest_fth;
        case 0xd42d9417:  numBytes = 4707; return file_fth;
        case 0x8819e750:  numBytes = 2902; return filefind_fth;
        case 0xc47442b2:  numBytes = 12389; return floats_fth;
        case 0xdcbfe008:  numBytes = 2748; return forget_fth;
        case 0x1500372f:  numBytes = 11407; return history_fth;
        case 0xf95fb9a3:  numBytes = 221; return loadhist_fth;
        case 0x45ca9ab9:  numBytes = 1535; return loadp4th_fth;
        case 0x4ec55703:  numBytes = 2229; return locals_fth;
        case 0x11f4ffa3:  numBytes = 2167; return math_fth;
        case 0xb0146a35:  numBytes = 4970; return member_fth;
        case 0x2bba4ae0:  numBytes = 3729; return misc1_fth;
        case 0x2bc86261:  numBytes = 6263; return misc2_fth;
        case 0x6425474a:  numBytes = 5689; return numberio_fth;
        case 0x7589689e:  numBytes = 1144; return private_fth;
        case 0x15a28380:  numBytes = 1168; return require_fth;
        case 0x7752ba88:  numBytes = 2277; return saveinput_fth;
        case 0xed5079be:  numBytes = 4038; return savedicd_fth;
        case 0x7582176e:  numBytes = 4227; return see_fth;
        case 0x0f9a7ea2:  numBytes = 731; return siev_fth;
        case 0xdce9f66e:  numBytes = 1915; return smart_if_fth;
        case 0xa70a4e1d:  numBytes = 1950; return strings_fth;
        case 0x26567f4a:  numBytes = 19751; return system_fth;
        case 0x33f9b745:  numBytes = 2647; return t_alloc_fth;
        case 0xb7f69336:  numBytes = 323; return t_case_fth;
        case 0xc1a2f6c9:  numBytes = 9142; return t_corex_fth;
        case 0x8ada0782:  numBytes = 10846; return t_file_fth;
        case 0x81d1875d:  numBytes = 3993; return t_floats_fth;
        case 0xfeb6cdf8:  numBytes = 209; return t_include_fth;
        case 0x24b311ec:  numBytes = 137; return t_load_fth;
        case 0xaae6a61f:  numBytes = 107; return t_load_defer_fth;
        case 0xb386f006:  numBytes = 62; return t_load_pairs_fth;
        case 0xa3b5abb7:  numBytes = 84; return t_load_semi_fth;
        case 0xbfe70879:  numBytes = 95; return t_load_undef_fth;
        case 0x0c229bae:  numBytes = 989; return t_locals_fth;
        case 0x0756e981:  numBytes = 120; return t_nolf_fth;
        case 0xba5387a9:  numBytes = 31; return t_required_helper1_fth;
        case 0xba619f2a:  numBytes = 31; return t_required_helper2_fth;
        case 0x95559ed2:  numBytes = 3389; return t_strings_fth;
        case 0x07271aeb:  numBytes = 1890; return t_tools_fth;
        case 0xb20a0a2d:  numBytes = 1666; return termio_fth;
        case 0x858db9da:  numBytes = 1760; return tester_fth;
        case 0x2b308360:  numBytes = 13067; return trace_fth;
        case 0xc6893d2e:  numBytes = 1343; return tut_fth;
        case 0x8ab2ad60:  numBytes = 1203; return wordslik_fth;
        default: break;
    }

    numBytes = 0;
    return nullptr;
}

const char* namedResourceList[] =
{
    "action_screen_fth",
    "action_table_fth",
    "action_top_fth",
    "action_utils_fth",
    "actobj_fth",
    "allocator_fth",
    "bevel_fth",
    "build_menus_fth",
    "charmacr_fth",
    "circular_fth",
    "collection_fth",
    "cond_comp_fth",
    "control_fth",
    "ctrl_count_fth",
    "ctrl_fader_fth",
    "ctrl_numeric_fth",
    "ctrl_text_fth",
    "ctrl_xy_fth",
    "dbl_list_fth",
    "deck_fth",
    "elmnts_fth",
    "errormsg_fth",
    "event_list_fth",
    "exmember_fth",
    "float_port_fth",
    "global_data_fth",
    "graph_util_fth",
    "graphics_fth",
    "hmsl_top_fth",
    "hmsl_version_fth",
    "instrument_fth",
    "interpreters_fth",
    "job_fth",
    "load_hmsl_fth",
    "load_ode_fth",
    "make_hmsl_fth",
    "memalloc_fth",
    "midi_fth",
    "midi_globals_fth",
    "midi_instrument_fth",
    "midi_parser_fth",
    "midi_stubs_fth",
    "midi_text_fth",
    "misc_tools_fth",
    "morph_fth",
    "morph_lists_fth",
    "ob_actions_fth",
    "ob_array_fth",
    "ob_bind_fth",
    "ob_dlist_fth",
    "ob_ivars_fth",
    "ob_main_fth",
    "ob_stack_fth",
    "obmethod_fth",
    "obobject_fth",
    "p4thbase_fth",
    "packed_midi_fth",
    "player_fth",
    "popup_text_fth",
    "production_fth",
    "record_fth",
    "scg_fth",
    "screen_fth",
    "service_tasks_fth",
    "set_vectors_fth",
    "shape_fth",
    "shape_editor_fth",
    "stacks_fth",
    "startup_fth",
    "stock_morphs_fth",
    "structure_fth",
    "stubs_fth",
    "test_actions_fth",
    "test_events_fth",
    "test_graphics_fth",
    "test_ode_fth",
    "test_ode_locals_fth",
    "time_fth",
    "top_fth",
    "translators_fth",
    "utils_fth",
    "clone_fth",
    "dump_struct_fth",
    "load_file_fth",
    "make_all256_fth",
    "ansilocs_fth",
    "bench_fth",
    "c_struct_fth",
    "case_fth",
    "condcomp_fth",
    "coretest_fth",
    "file_fth",
    "filefind_fth",
    "floats_fth",
    "forget_fth",
    "history_fth",
    "loadhist_fth",
    "loadp4th_fth",
    "locals_fth",
    "math_fth",
    "member_fth",
    "misc1_fth",
    "misc2_fth",
    "numberio_fth",
    "private_fth",
    "require_fth",
    "saveinput_fth",
    "savedicd_fth",
    "see_fth",
    "siev_fth",
    "smart_if_fth",
    "strings_fth",
    "system_fth",
    "t_alloc_fth",
    "t_case_fth",
    "t_corex_fth",
    "t_file_fth",
    "t_floats_fth",
    "t_include_fth",
    "t_load_fth",
    "t_load_defer_fth",
    "t_load_pairs_fth",
    "t_load_semi_fth",
    "t_load_undef_fth",
    "t_locals_fth",
    "t_nolf_fth",
    "t_required_helper1_fth",
    "t_required_helper2_fth",
    "t_strings_fth",
    "t_tools_fth",
    "termio_fth",
    "tester_fth",
    "trace_fth",
    "tut_fth",
    "wordslik_fth"
};

const char* originalFilenames[] =
{
    "action_screen.fth",
    "action_table.fth",
    "action_top.fth",
    "action_utils.fth",
    "actobj.fth",
    "allocator.fth",
    "bevel.fth",
    "build_menus.fth",
    "charmacr.fth",
    "circular.fth",
    "collection.fth",
    "cond_comp.fth",
    "control.fth",
    "ctrl_count.fth",
    "ctrl_fader.fth",
    "ctrl_numeric.fth",
    "ctrl_text.fth",
    "ctrl_xy.fth",
    "dbl_list.fth",
    "deck.fth",
    "elmnts.fth",
    "errormsg.fth",
    "event_list.fth",
    "exmember.fth",
    "float_port.fth",
    "global_data.fth",
    "graph_util.fth",
    "graphics.fth",
    "hmsl_top.fth",
    "hmsl_version.fth",
    "instrument.fth",
    "interpreters.fth",
    "job.fth",
    "load_hmsl.fth",
    "load_ode.fth",
    "make_hmsl.fth",
    "memalloc.fth",
    "midi.fth",
    "midi_globals.fth",
    "midi_instrument.fth",
    "midi_parser.fth",
    "midi_stubs.fth",
    "midi_text.fth",
    "misc_tools.fth",
    "morph.fth",
    "morph_lists.fth",
    "ob_actions.fth",
    "ob_array.fth",
    "ob_bind.fth",
    "ob_dlist.fth",
    "ob_ivars.fth",
    "ob_main.fth",
    "ob_stack.fth",
    "obmethod.fth",
    "obobject.fth",
    "p4thbase.fth",
    "packed_midi.fth",
    "player.fth",
    "popup_text.fth",
    "production.fth",
    "record.fth",
    "scg.fth",
    "screen.fth",
    "service_tasks.fth",
    "set_vectors.fth",
    "shape.fth",
    "shape_editor.fth",
    "stacks.fth",
    "startup.fth",
    "stock_morphs.fth",
    "structure.fth",
    "stubs.fth",
    "test_actions.fth",
    "test_events.fth",
    "test_graphics.fth",
    "test_ode.fth",
    "test_ode_locals.fth",
    "time.fth",
    "top.fth",
    "translators.fth",
    "utils.fth",
    "clone.fth",
    "dump_struct.fth",
    "load_file.fth",
    "make_all256.fth",
    "ansilocs.fth",
    "bench.fth",
    "c_struct.fth",
    "case.fth",
    "condcomp.fth",
    "coretest.fth",
    "file.fth",
    "filefind.fth",
    "floats.fth",
    "forget.fth",
    "history.fth",
    "loadhist.fth",
    "loadp4th.fth",
    "locals.fth",
    "math.fth",
    "member.fth",
    "misc1.fth",
    "misc2.fth",
    "numberio.fth",
    "private.fth",
    "require.fth",
    "save-input.fth",
    "savedicd.fth",
    "see.fth",
    "siev.fth",
    "smart_if.fth",
    "strings.fth",
    "system.fth",
    "t_alloc.fth",
    "t_case.fth",
    "t_corex.fth",
    "t_file.fth",
    "t_floats.fth",
    "t_include.fth",
    "t_load.fth",
    "t_load_defer.fth",
    "t_load_pairs.fth",
    "t_load_semi.fth",
    "t_load_undef.fth",
    "t_locals.fth",
    "t_nolf.fth",
    "t_required_helper1.fth",
    "t_required_helper2.fth",
    "t_strings.fth",
    "t_tools.fth",
    "termio.fth",
    "tester.fth",
    "trace.fth",
    "tut.fth",
    "wordslik.fth"
};

const char* getNamedResourceOriginalFilename (const char* resourceNameUTF8)
{
    for (unsigned int i = 0; i < (sizeof (namedResourceList) / sizeof (namedResourceList[0])); ++i)
    {
        if (namedResourceList[i] == resourceNameUTF8)
            return originalFilenames[i];
    }

    return nullptr;
}

}
